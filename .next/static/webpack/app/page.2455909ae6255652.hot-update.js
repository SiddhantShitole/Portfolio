"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/Observer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/Observer.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observer: function() { return /* binding */ Observer; },\n/* harmony export */   _getProxyProp: function() { return /* binding */ _getProxyProp; },\n/* harmony export */   _getScrollFunc: function() { return /* binding */ _getScrollFunc; },\n/* harmony export */   _getTarget: function() { return /* binding */ _getTarget; },\n/* harmony export */   _getVelocityProp: function() { return /* binding */ _getVelocityProp; },\n/* harmony export */   _horizontal: function() { return /* binding */ _horizontal; },\n/* harmony export */   _isViewport: function() { return /* binding */ _isViewport; },\n/* harmony export */   _proxies: function() { return /* binding */ _proxies; },\n/* harmony export */   _scrollers: function() { return /* binding */ _scrollers; },\n/* harmony export */   _vertical: function() { return /* binding */ _vertical; },\n/* harmony export */   \"default\": function() { return /* binding */ Observer; }\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n/*!\n * Observer 3.14.2\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context, _getGSAP = function _getGSAP() {\n    return gsap ||  true && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge(name, value) {\n    return value;\n}, _integrate = function _integrate() {\n    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;\n    scrollers.push.apply(scrollers, _scrollers);\n    proxies.push.apply(proxies, _proxies);\n    _scrollers = scrollers;\n    _proxies = proxies;\n    _bridge = function _bridge(name, value) {\n        return data[name](value);\n    };\n}, _getProxyProp = function _getProxyProp(element, property) {\n    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n}, _isViewport = function _isViewport(el) {\n    return !!~_root.indexOf(el);\n}, _addListener = function _addListener(element, type, func, passive, capture) {\n    return element.addEventListener(type, func, {\n        passive: passive !== false,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _scrollLeft = \"scrollLeft\", _scrollTop = \"scrollTop\", _onScroll = function _onScroll() {\n    return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n}, _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n    var cachingFunc = function cachingFunc(value) {\n        // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n        if (value || value === 0) {\n            _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n            var isNormalizing = _normalizer && _normalizer.isPressed;\n            value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n            f(value);\n            cachingFunc.cacheID = _scrollers.cache;\n            isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n            cachingFunc.cacheID = _scrollers.cache;\n            cachingFunc.v = f();\n        }\n        return cachingFunc.v + cachingFunc.offset;\n    };\n    cachingFunc.offset = 0;\n    return f && cachingFunc;\n}, _horizontal = {\n    s: _scrollLeft,\n    p: \"left\",\n    p2: \"Left\",\n    os: \"right\",\n    os2: \"Right\",\n    d: \"width\",\n    d2: \"Width\",\n    a: \"x\",\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n    })\n}, _vertical = {\n    s: _scrollTop,\n    p: \"top\",\n    p2: \"Top\",\n    os: \"bottom\",\n    os2: \"Bottom\",\n    d: \"height\",\n    d2: \"Height\",\n    a: \"y\",\n    op: _horizontal,\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n    })\n}, _getTarget = function _getTarget(t, self) {\n    return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n}, _isWithin = function _isWithin(element, list) {\n    // check if the element is in the list or is a descendant of an element in the list.\n    var i = list.length;\n    while(i--){\n        if (list[i] === element || list[i].contains(element)) {\n            return true;\n        }\n    }\n    return false;\n}, _getScrollFunc = function _getScrollFunc(element, _ref) {\n    var s = _ref.s, sc = _ref.sc;\n    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n    _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;\n    !~i && (i = _scrollers.push(element) - 1);\n    _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {\n        return arguments.length ? element[s] = value : element[s];\n    })));\n    func.target = element;\n    prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n    return func;\n}, _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update(value, force) {\n        var t = _getTime();\n        if (force || t - t1 > min) {\n            v2 = v1;\n            v1 = value;\n            t2 = t1;\n            t1 = t;\n        } else if (useDelta) {\n            v1 += value;\n        } else {\n            // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n            v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n        }\n    }, reset = function reset() {\n        v2 = v1 = useDelta ? 0 : v1;\n        t2 = t1 = 0;\n    }, getVelocity = function getVelocity(latestValue) {\n        var tOld = t2, vOld = v2, t = _getTime();\n        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n    };\n    return {\n        update: update,\n        reset: reset,\n        getVelocity: getVelocity\n    };\n}, _getEvent = function _getEvent(e, preventDefault) {\n    preventDefault && !e._gsapAllow && e.preventDefault();\n    return e.changedTouches ? e.changedTouches[0] : e;\n}, _getAbsoluteMax = function _getAbsoluteMax(a) {\n    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);\n    return Math.abs(max) >= Math.abs(min) ? max : min;\n}, _setScrollTrigger = function _setScrollTrigger() {\n    ScrollTrigger = gsap.core.globals().ScrollTrigger;\n    ScrollTrigger && ScrollTrigger.core && _integrate();\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        _root = [\n            _win,\n            _doc,\n            _docEl,\n            _body\n        ];\n        _clamp = gsap.utils.clamp;\n        _context = gsap.core.context || function() {};\n        _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n        _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n        _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n        setTimeout(function() {\n            return _startup = 0;\n        }, 500);\n        _setScrollTrigger();\n        _coreInitted = 1;\n    }\n    return _coreInitted;\n};\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = /*#__PURE__*/ function() {\n    function Observer(vars) {\n        this.init(vars);\n    }\n    var _proto = Observer.prototype;\n    _proto.init = function init(vars) {\n        _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n        ScrollTrigger || _setScrollTrigger();\n        var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;\n        this.target = target = _getTarget(target) || _docEl;\n        this.vars = vars;\n        ignore && (ignore = gsap.utils.toArray(ignore));\n        tolerance = tolerance || 1e-9;\n        dragMinimum = dragMinimum || 0;\n        wheelSpeed = wheelSpeed || 1;\n        scrollSpeed = scrollSpeed || 1;\n        type = type || \"wheel,touch,pointer\";\n        debounce = debounce !== false;\n        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n        var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault && vars.passive !== false, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\", // for devices that accommodate mouse events and touch events, we need to distinguish.\n        isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc, deltaX = [\n            0,\n            0,\n            0\n        ], // wheel, scroll, pointer/touch\n        deltaY = [\n            0,\n            0,\n            0\n        ], onClickTime = 0, clickCapture = function clickCapture() {\n            return onClickTime = _getTime();\n        }, _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n            return (self.event = e) && ignore && _isWithin(e.target, ignore) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n        }, onStopFunc = function onStopFunc() {\n            self._vx.reset();\n            self._vy.reset();\n            onStopDelayedCall.pause();\n            onStop && onStop(self);\n        }, update = function update() {\n            var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;\n            onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n            if (changedX) {\n                onRight && self.deltaX > 0 && onRight(self);\n                onLeft && self.deltaX < 0 && onLeft(self);\n                onChangeX && onChangeX(self);\n                onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n                prevDeltaX = self.deltaX;\n                deltaX[0] = deltaX[1] = deltaX[2] = 0;\n            }\n            if (changedY) {\n                onDown && self.deltaY > 0 && onDown(self);\n                onUp && self.deltaY < 0 && onUp(self);\n                onChangeY && onChangeY(self);\n                onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n                prevDeltaY = self.deltaY;\n                deltaY[0] = deltaY[1] = deltaY[2] = 0;\n            }\n            if (moved || dragged) {\n                onMove && onMove(self);\n                if (dragged) {\n                    onDragStart && dragged === 1 && onDragStart(self);\n                    onDrag && onDrag(self);\n                    dragged = 0;\n                }\n                moved = false;\n            }\n            locked && !(locked = false) && onLockAxis && onLockAxis(self);\n            if (wheeled) {\n                onWheel(self);\n                wheeled = false;\n            }\n            id = 0;\n        }, onDelta = function onDelta(x, y, index) {\n            deltaX[index] += x;\n            deltaY[index] += y;\n            self._vx.update(x);\n            self._vy.update(y);\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n            if (lockAxis && !axis) {\n                self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n                locked = true;\n            }\n            if (axis !== \"y\") {\n                deltaX[2] += x;\n                self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n            }\n            if (axis !== \"x\") {\n                deltaY[2] += y;\n                self._vy.update(y, true);\n            }\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, _onDrag = function _onDrag(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;\n            self.x = x;\n            self.y = y;\n            if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {\n                dragged || (dragged = isDragging ? 2 : 1); // dragged: 0 = not dragging, 1 = first drag, 2 = normal drag\n                isDragging || (self.isDragging = true);\n                onTouchOrPointerDelta(dx, dy);\n            }\n        }, _onPress = self.onPress = function(e) {\n            if (_ignoreCheck(e, 1) || e && e.button) {\n                return;\n            }\n            self.axis = axis = null;\n            onStopDelayedCall.pause();\n            self.isPressed = true;\n            e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n            prevDeltaX = prevDeltaY = 0;\n            self.startX = self.x = e.clientX;\n            self.startY = self.y = e.clientY;\n            self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n            self._vy.reset();\n            _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n            self.deltaX = self.deltaY = 0;\n            onPress && onPress(self);\n        }, _onRelease = self.onRelease = function(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n            var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n            eventData = _getEvent(e);\n            if (!isDragNotClick && isTrackingDrag) {\n                self._vx.reset();\n                self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n                if (preventDefault && allowClicks) {\n                    gsap.delayedCall(0.08, function() {\n                        // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n                        if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n                            if (e.target.click) {\n                                //some browsers (like mobile Safari) don't properly trigger the click event\n                                e.target.click();\n                            } else if (ownerDoc.createEvent) {\n                                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                                e.target.dispatchEvent(syntheticEvent);\n                            }\n                        }\n                    });\n                }\n            }\n            self.isDragging = self.isGesturing = self.isPressed = false;\n            onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n            dragged && update(); // in case debouncing, we don't want onDrag to fire AFTER onDragEnd().\n            onDragEnd && wasDragging && onDragEnd(self);\n            onRelease && onRelease(self, isDragNotClick);\n        }, _onGestureStart = function _onGestureStart(e) {\n            return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n        }, _onGestureEnd = function _onGestureEnd() {\n            return (self.isGesturing = false) || onGestureEnd(self);\n        }, onScroll = function onScroll(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = scrollFuncX(), y = scrollFuncY();\n            onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n            scrollX = x;\n            scrollY = y;\n            onStop && onStopDelayedCall.restart(true);\n        }, _onWheel = function _onWheel(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            onWheel && (wheeled = true);\n            var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n            onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n            onStop && !isNormalizer && onStopDelayedCall.restart(true);\n        }, _onMove = function _onMove(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;\n            self.x = x;\n            self.y = y;\n            moved = true;\n            onStop && onStopDelayedCall.restart(true);\n            (dx || dy) && onTouchOrPointerDelta(dx, dy);\n        }, _onHover = function _onHover(e) {\n            self.event = e;\n            onHover(self);\n        }, _onHoverEnd = function _onHoverEnd(e) {\n            self.event = e;\n            onHoverEnd(self);\n        }, _onClick = function _onClick(e) {\n            return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n        };\n        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n        self.deltaX = self.deltaY = 0;\n        self._vx = _getVelocityProp(0, 50, true);\n        self._vy = _getVelocityProp(0, 50, true);\n        self.scrollX = scrollFuncX;\n        self.scrollY = scrollFuncY;\n        self.isDragging = self.isGesturing = self.isPressed = false;\n        _context(this);\n        self.enable = function(e) {\n            if (!self.isEnabled) {\n                _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n                type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n                if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n                    _addListener(target, _eventTypes[0], _onPress, passive, capture);\n                    _addListener(ownerDoc, _eventTypes[2], _onRelease);\n                    _addListener(ownerDoc, _eventTypes[3], _onRelease);\n                    allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n                    onClick && _addListener(target, \"click\", _onClick);\n                    onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                    onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                    onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n                    onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n                    onMove && _addListener(target, _pointerType + \"move\", _onMove);\n                }\n                self.isEnabled = true;\n                self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;\n                self._vx.reset();\n                self._vy.reset();\n                scrollX = scrollFuncX();\n                scrollY = scrollFuncY();\n                e && e.type && _onPress(e);\n                onEnable && onEnable(self);\n            }\n            return self;\n        };\n        self.disable = function() {\n            if (self.isEnabled) {\n                // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n                _observers.filter(function(o) {\n                    return o !== self && _isViewport(o.target);\n                }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                if (self.isPressed) {\n                    self._vx.reset();\n                    self._vy.reset();\n                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n                }\n                _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n                _removeListener(target, \"wheel\", _onWheel, capture);\n                _removeListener(target, _eventTypes[0], _onPress, capture);\n                _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n                _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n                _removeListener(target, \"click\", clickCapture, true);\n                _removeListener(target, \"click\", _onClick);\n                _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                _removeListener(target, _pointerType + \"enter\", _onHover);\n                _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n                _removeListener(target, _pointerType + \"move\", _onMove);\n                self.isEnabled = self.isPressed = self.isDragging = false;\n                onDisable && onDisable(self);\n            }\n        };\n        self.kill = self.revert = function() {\n            self.disable();\n            var i = _observers.indexOf(self);\n            i >= 0 && _observers.splice(i, 1);\n            _normalizer === self && (_normalizer = 0);\n        };\n        _observers.push(self);\n        isNormalizer && _isViewport(target) && (_normalizer = self);\n        self.enable(event);\n    };\n    _createClass(Observer, [\n        {\n            key: \"velocityX\",\n            get: function get() {\n                return this._vx.getVelocity();\n            }\n        },\n        {\n            key: \"velocityY\",\n            get: function get() {\n                return this._vy.getVelocity();\n            }\n        }\n    ]);\n    return Observer;\n}();\nObserver.version = \"3.14.2\";\nObserver.create = function(vars) {\n    return new Observer(vars);\n};\nObserver.register = _initCore;\nObserver.getAll = function() {\n    return _observers.slice();\n};\nObserver.getById = function(id) {\n    return _observers.filter(function(o) {\n        return o.vars.id === id;\n    })[0];\n};\n_getGSAP() && gsap.registerPlugin(Observer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTQuMi9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47SUFBYTtBQUFFO0FBRTVULFNBQVNPLGFBQWFDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWWQsa0JBQWtCYSxZQUFZRyxTQUFTLEVBQUVGO0lBQWEsSUFBSUMsYUFBYWYsa0JBQWtCYSxhQUFhRTtJQUFjLE9BQU9GO0FBQWE7QUFFdE47Ozs7Ozs7QUFPQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJSSxNQUNBQyxjQUNBQyxRQUNBQyxNQUNBQyxNQUNBQyxRQUNBQyxPQUNBQyxVQUNBQyxjQUNBQyxlQUNBQyxPQUNBQyxhQUNBQyxhQUNBQyxVQUNBQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9kLFFBQVEsS0FBNkIsSUFBS0EsQ0FBQUEsT0FBT2UsT0FBT2YsSUFBSSxLQUFLQSxLQUFLZ0IsY0FBYyxJQUFJaEI7QUFDakcsR0FDSWlCLFdBQVcsR0FDWEMsYUFBYSxFQUFFLEVBQ2ZDLGFBQWEsRUFBRSxFQUNmQyxXQUFXLEVBQUUsRUFDYkMsV0FBV0MsS0FBS0MsR0FBRyxFQUNuQkMsVUFBVSxTQUFTQSxRQUFRQyxJQUFJLEVBQUVDLEtBQUs7SUFDeEMsT0FBT0E7QUFDVCxHQUNJQyxhQUFhLFNBQVNBO0lBQ3hCLElBQUlDLE9BQU9uQixjQUFjbUIsSUFBSSxFQUN6QkMsT0FBT0QsS0FBS0UsTUFBTSxJQUFJLENBQUMsR0FDdkJDLFlBQVlILEtBQUtULFVBQVUsRUFDM0JhLFVBQVVKLEtBQUtSLFFBQVE7SUFDM0JXLFVBQVVFLElBQUksQ0FBQ0MsS0FBSyxDQUFDSCxXQUFXWjtJQUNoQ2EsUUFBUUMsSUFBSSxDQUFDQyxLQUFLLENBQUNGLFNBQVNaO0lBQzVCRCxhQUFhWTtJQUNiWCxXQUFXWTtJQUVYUixVQUFVLFNBQVNBLFFBQVFDLElBQUksRUFBRUMsS0FBSztRQUNwQyxPQUFPRyxJQUFJLENBQUNKLEtBQUssQ0FBQ0M7SUFDcEI7QUFDRixHQUNJUyxnQkFBZ0IsU0FBU0EsY0FBY0MsT0FBTyxFQUFFQyxRQUFRO0lBQzFELE9BQU8sQ0FBQ2pCLFNBQVNrQixPQUFPLENBQUNGLFlBQVloQixRQUFRLENBQUNBLFNBQVNrQixPQUFPLENBQUNGLFdBQVcsRUFBRSxDQUFDQyxTQUFTO0FBQ3hGLEdBQ0lFLGNBQWMsU0FBU0EsWUFBWUMsRUFBRTtJQUN2QyxPQUFPLENBQUMsQ0FBQyxDQUFDOUIsTUFBTTRCLE9BQU8sQ0FBQ0U7QUFDMUIsR0FDSUMsZUFBZSxTQUFTQSxhQUFhTCxPQUFPLEVBQUVNLElBQUksRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDNUUsT0FBT1QsUUFBUVUsZ0JBQWdCLENBQUNKLE1BQU1DLE1BQU07UUFDMUNDLFNBQVNBLFlBQVk7UUFDckJDLFNBQVMsQ0FBQyxDQUFDQTtJQUNiO0FBQ0YsR0FDSUUsa0JBQWtCLFNBQVNBLGdCQUFnQlgsT0FBTyxFQUFFTSxJQUFJLEVBQUVDLElBQUksRUFBRUUsT0FBTztJQUN6RSxPQUFPVCxRQUFRWSxtQkFBbUIsQ0FBQ04sTUFBTUMsTUFBTSxDQUFDLENBQUNFO0FBQ25ELEdBQ0lJLGNBQWMsY0FDZEMsYUFBYSxhQUNiQyxZQUFZLFNBQVNBO0lBQ3ZCLE9BQU94QyxlQUFlQSxZQUFZeUMsU0FBUyxJQUFJakMsV0FBV2tDLEtBQUs7QUFDakUsR0FDSUMsbUJBQW1CLFNBQVNBLGlCQUFpQkMsQ0FBQyxFQUFFQyxVQUFVO0lBQzVELElBQUlDLGNBQWMsU0FBU0EsWUFBWS9CLEtBQUs7UUFDMUMsa1pBQWtaO1FBQ2xaLElBQUlBLFNBQVNBLFVBQVUsR0FBRztZQUN4QlQsWUFBYWQsQ0FBQUEsS0FBS3VELE9BQU8sQ0FBQ0MsaUJBQWlCLEdBQUcsUUFBTyxHQUFJLHlFQUF5RTtZQUVsSSxJQUFJQyxnQkFBZ0JqRCxlQUFlQSxZQUFZeUMsU0FBUztZQUN4RDFCLFFBQVErQixZQUFZSSxDQUFDLEdBQUdDLEtBQUtDLEtBQUssQ0FBQ3JDLFVBQVdmLENBQUFBLGVBQWVBLFlBQVlxRCxHQUFHLEdBQUcsSUFBSSxJQUFJLDBIQUEwSDtZQUVqTlQsRUFBRTdCO1lBQ0YrQixZQUFZUSxPQUFPLEdBQUc5QyxXQUFXa0MsS0FBSztZQUN0Q08saUJBQWlCcEMsUUFBUSxNQUFNRSxRQUFRLHlGQUF5RjtRQUNsSSxPQUFPLElBQUk4QixjQUFjckMsV0FBV2tDLEtBQUssS0FBS0ksWUFBWVEsT0FBTyxJQUFJekMsUUFBUSxRQUFRO1lBQ25GaUMsWUFBWVEsT0FBTyxHQUFHOUMsV0FBV2tDLEtBQUs7WUFDdENJLFlBQVlJLENBQUMsR0FBR047UUFDbEI7UUFFQSxPQUFPRSxZQUFZSSxDQUFDLEdBQUdKLFlBQVlTLE1BQU07SUFDM0M7SUFFQVQsWUFBWVMsTUFBTSxHQUFHO0lBQ3JCLE9BQU9YLEtBQUtFO0FBQ2QsR0FDSVUsY0FBYztJQUNoQkMsR0FBR25CO0lBQ0hvQixHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxLQUFLO0lBQ0xDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLElBQUl0QixpQkFBaUIsU0FBVTVCLEtBQUs7UUFDbEMsT0FBT21ELFVBQVUxRixNQUFNLEdBQUdnQixLQUFLMkUsUUFBUSxDQUFDcEQsT0FBT3FELFVBQVVILEVBQUUsTUFBTXpFLEtBQUs2RSxXQUFXLElBQUk1RSxJQUFJLENBQUM2QyxZQUFZLElBQUk1QyxNQUFNLENBQUM0QyxZQUFZLElBQUkzQyxLQUFLLENBQUMyQyxZQUFZLElBQUk7SUFDeko7QUFDRixHQUNJOEIsWUFBWTtJQUNkWCxHQUFHbEI7SUFDSG1CLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEtBQUs7SUFDTEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSE0sSUFBSWQ7SUFDSlMsSUFBSXRCLGlCQUFpQixTQUFVNUIsS0FBSztRQUNsQyxPQUFPbUQsVUFBVTFGLE1BQU0sR0FBR2dCLEtBQUsyRSxRQUFRLENBQUNYLFlBQVlTLEVBQUUsSUFBSWxELFNBQVN2QixLQUFLK0UsV0FBVyxJQUFJOUUsSUFBSSxDQUFDOEMsV0FBVyxJQUFJN0MsTUFBTSxDQUFDNkMsV0FBVyxJQUFJNUMsS0FBSyxDQUFDNEMsV0FBVyxJQUFJO0lBQ3hKO0FBQ0YsR0FDSWlDLGFBQWEsU0FBU0EsV0FBV0MsQ0FBQyxFQUFFQyxJQUFJO0lBQzFDLE9BQU8sQ0FBQ0EsUUFBUUEsS0FBS0MsSUFBSSxJQUFJRCxLQUFLQyxJQUFJLENBQUNDLFFBQVEsSUFBSXZGLEtBQUt3RixLQUFLLENBQUNDLE9BQU8sRUFBRUwsRUFBRSxDQUFDLEVBQUUsSUFBSyxRQUFPQSxNQUFNLFlBQVlwRixLQUFLMEYsTUFBTSxHQUFHQyxjQUFjLEtBQUssUUFBUUMsUUFBUUMsSUFBSSxDQUFDLHNCQUFzQlQsS0FBSyxJQUFHO0FBQ2hNLEdBQ0lVLFlBQVksU0FBU0EsVUFBVTFELE9BQU8sRUFBRTJELElBQUk7SUFDOUMsb0ZBQW9GO0lBQ3BGLElBQUk3RyxJQUFJNkcsS0FBSzVHLE1BQU07SUFFbkIsTUFBT0QsSUFBSztRQUNWLElBQUk2RyxJQUFJLENBQUM3RyxFQUFFLEtBQUtrRCxXQUFXMkQsSUFBSSxDQUFDN0csRUFBRSxDQUFDOEcsUUFBUSxDQUFDNUQsVUFBVTtZQUNwRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCxHQUNJNkQsaUJBQWlCLFNBQVNBLGVBQWU3RCxPQUFPLEVBQUU4RCxJQUFJO0lBQ3hELElBQUk5QixJQUFJOEIsS0FBSzlCLENBQUMsRUFDVlEsS0FBS3NCLEtBQUt0QixFQUFFO0lBQ2hCLG1VQUFtVTtJQUNuVXJDLFlBQVlILFlBQWFBLENBQUFBLFVBQVVoQyxLQUFLK0YsZ0JBQWdCLElBQUk5RixNQUFLO0lBRWpFLElBQUluQixJQUFJaUMsV0FBV21CLE9BQU8sQ0FBQ0YsVUFDdkI4QixTQUFTVSxPQUFPRyxVQUFVSCxFQUFFLEdBQUcsSUFBSTtJQUV2QyxDQUFDLENBQUMxRixLQUFNQSxDQUFBQSxJQUFJaUMsV0FBV2MsSUFBSSxDQUFDRyxXQUFXO0lBQ3ZDakIsVUFBVSxDQUFDakMsSUFBSWdGLE9BQU8sSUFBSXpCLGFBQWFMLFNBQVMsVUFBVWUsWUFBWSx1Q0FBdUM7SUFFN0csSUFBSWlELE9BQU9qRixVQUFVLENBQUNqQyxJQUFJZ0YsT0FBTyxFQUM3QnZCLE9BQU95RCxRQUFTakYsQ0FBQUEsVUFBVSxDQUFDakMsSUFBSWdGLE9BQU8sR0FBR1osaUJBQWlCbkIsY0FBY0MsU0FBU2dDLElBQUksU0FBVTdCLENBQUFBLFlBQVlILFdBQVd3QyxLQUFLdEIsaUJBQWlCLFNBQVU1QixLQUFLO1FBQzdKLE9BQU9tRCxVQUFVMUYsTUFBTSxHQUFHaUQsT0FBTyxDQUFDZ0MsRUFBRSxHQUFHMUMsUUFBUVUsT0FBTyxDQUFDZ0MsRUFBRTtJQUMzRCxFQUFDLENBQUM7SUFDRnpCLEtBQUszRCxNQUFNLEdBQUdvRDtJQUNkZ0UsUUFBU3pELENBQUFBLEtBQUswRCxNQUFNLEdBQUdyRyxLQUFLc0csV0FBVyxDQUFDbEUsU0FBUyxzQkFBc0IsUUFBTyxHQUFJLGtLQUFrSztJQUVwUCxPQUFPTztBQUNULEdBQ0k0RCxtQkFBbUIsU0FBU0EsaUJBQWlCN0UsS0FBSyxFQUFFOEUsY0FBYyxFQUFFQyxRQUFRO0lBQzlFLElBQUlDLEtBQUtoRixPQUNMaUYsS0FBS2pGLE9BQ0xrRixLQUFLdkYsWUFDTHdGLEtBQUtELElBQ0xFLE1BQU1OLGtCQUFrQixJQUN4Qk8saUJBQWlCakQsS0FBS2tELEdBQUcsQ0FBQyxLQUFLRixNQUFNLElBQ3JDRyxTQUFTLFNBQVNBLE9BQU92RixLQUFLLEVBQUV3RixLQUFLO1FBQ3ZDLElBQUk5QixJQUFJL0Q7UUFFUixJQUFJNkYsU0FBUzlCLElBQUl3QixLQUFLRSxLQUFLO1lBQ3pCSCxLQUFLRDtZQUNMQSxLQUFLaEY7WUFDTG1GLEtBQUtEO1lBQ0xBLEtBQUt4QjtRQUNQLE9BQU8sSUFBSXFCLFVBQVU7WUFDbkJDLE1BQU1oRjtRQUNSLE9BQU87WUFDTCxtUkFBbVI7WUFDblJnRixLQUFLQyxLQUFLLENBQUNqRixRQUFRaUYsRUFBQyxJQUFNdkIsQ0FBQUEsSUFBSXlCLEVBQUMsSUFBTUQsQ0FBQUEsS0FBS0MsRUFBQztRQUM3QztJQUNGLEdBQ0lNLFFBQVEsU0FBU0E7UUFDbkJSLEtBQUtELEtBQUtELFdBQVcsSUFBSUM7UUFDekJHLEtBQUtELEtBQUs7SUFDWixHQUNJUSxjQUFjLFNBQVNBLFlBQVlDLFdBQVc7UUFDaEQsSUFBSUMsT0FBT1QsSUFDUFUsT0FBT1osSUFDUHZCLElBQUkvRDtRQUVQZ0csQ0FBQUEsZUFBZUEsZ0JBQWdCLE1BQU1BLGdCQUFnQlgsTUFBTU8sT0FBT0k7UUFDbkUsT0FBT1QsT0FBT0MsTUFBTXpCLElBQUl5QixLQUFLRSxpQkFBaUIsSUFBSSxDQUFDTCxLQUFNRCxDQUFBQSxXQUFXYyxPQUFPLENBQUNBLElBQUcsQ0FBQyxJQUFNLEVBQUNkLFdBQVdyQixJQUFJd0IsRUFBQyxJQUFLVSxJQUFHLElBQUs7SUFDdEg7SUFFQSxPQUFPO1FBQ0xMLFFBQVFBO1FBQ1JFLE9BQU9BO1FBQ1BDLGFBQWFBO0lBQ2Y7QUFDRixHQUNJSSxZQUFZLFNBQVNBLFVBQVVDLENBQUMsRUFBRUMsY0FBYztJQUNsREEsa0JBQWtCLENBQUNELEVBQUVFLFVBQVUsSUFBSUYsRUFBRUMsY0FBYztJQUNuRCxPQUFPRCxFQUFFRyxjQUFjLEdBQUdILEVBQUVHLGNBQWMsQ0FBQyxFQUFFLEdBQUdIO0FBQ2xELEdBQ0lJLGtCQUFrQixTQUFTQSxnQkFBZ0JsRCxDQUFDO0lBQzlDLElBQUlxQyxNQUFNbEQsS0FBS2tELEdBQUcsQ0FBQzlFLEtBQUssQ0FBQzRCLE1BQU1hLElBQzNCbUMsTUFBTWhELEtBQUtnRCxHQUFHLENBQUM1RSxLQUFLLENBQUM0QixNQUFNYTtJQUMvQixPQUFPYixLQUFLZ0UsR0FBRyxDQUFDZCxRQUFRbEQsS0FBS2dFLEdBQUcsQ0FBQ2hCLE9BQU9FLE1BQU1GO0FBQ2hELEdBQ0lpQixvQkFBb0IsU0FBU0E7SUFDL0J0SCxnQkFBZ0JULEtBQUs0QixJQUFJLENBQUNvRyxPQUFPLEdBQUd2SCxhQUFhO0lBQ2pEQSxpQkFBaUJBLGNBQWNtQixJQUFJLElBQUlEO0FBQ3pDLEdBQ0lzRyxZQUFZLFNBQVNBLFVBQVVyRyxJQUFJO0lBQ3JDNUIsT0FBTzRCLFFBQVFkO0lBRWYsSUFBSSxDQUFDYixnQkFBZ0JELFFBQVEsT0FBT2tJLGFBQWEsZUFBZUEsU0FBU0MsSUFBSSxFQUFFO1FBQzdFaEksT0FBT1k7UUFDUFgsT0FBTzhIO1FBQ1A3SCxTQUFTRCxLQUFLZ0ksZUFBZTtRQUM3QjlILFFBQVFGLEtBQUsrSCxJQUFJO1FBQ2pCekgsUUFBUTtZQUFDUDtZQUFNQztZQUFNQztZQUFRQztTQUFNO1FBQ25DSixTQUFTRixLQUFLd0YsS0FBSyxDQUFDNkMsS0FBSztRQUV6QnhILFdBQVdiLEtBQUs0QixJQUFJLENBQUMwRyxPQUFPLElBQUksWUFBYTtRQUU3QzlILGVBQWUsb0JBQW9CRixRQUFRLFlBQVksU0FBUyx3SEFBd0g7UUFFeExDLFdBQVdnSSxTQUFTQyxPQUFPLEdBQUdySSxLQUFLc0ksVUFBVSxJQUFJdEksS0FBS3NJLFVBQVUsQ0FBQyxvQ0FBb0NDLE9BQU8sR0FBRyxJQUFJLGtCQUFrQnZJLFFBQVF3SSxVQUFVQyxjQUFjLEdBQUcsS0FBS0QsVUFBVUUsZ0JBQWdCLEdBQUcsSUFBSSxJQUFJO1FBQ2xOakksY0FBYzJILFNBQVNPLFVBQVUsR0FBRyxDQUFDLGtCQUFrQnpJLFNBQVMsOENBQThDLENBQUUsb0JBQW1CQSxNQUFLLElBQUssd0NBQXdDLGlEQUFnRCxFQUFHMEksS0FBSyxDQUFDO1FBQzlPQyxXQUFXO1lBQ1QsT0FBTy9ILFdBQVc7UUFDcEIsR0FBRztRQUVIOEc7UUFFQTlILGVBQWU7SUFDakI7SUFFQSxPQUFPQTtBQUNUO0FBRUFrRSxZQUFZYyxFQUFFLEdBQUdGO0FBQ2pCNUQsV0FBV2tDLEtBQUssR0FBRztBQUNaLElBQUlrRixXQUFXLFdBQVcsR0FBRTtJQUNqQyxTQUFTQSxTQUFTVSxJQUFJO1FBQ3BCLElBQUksQ0FBQ0MsSUFBSSxDQUFDRDtJQUNaO0lBRUEsSUFBSUUsU0FBU1osU0FBU3hJLFNBQVM7SUFFL0JvSixPQUFPRCxJQUFJLEdBQUcsU0FBU0EsS0FBS0QsSUFBSTtRQUM5QmhKLGdCQUFnQmdJLFVBQVVqSSxTQUFTNEYsUUFBUUMsSUFBSSxDQUFDO1FBQ2hEcEYsaUJBQWlCc0g7UUFDakIsSUFBSXFCLFlBQVlILEtBQUtHLFNBQVMsRUFDMUJDLGNBQWNKLEtBQUtJLFdBQVcsRUFDOUIzRyxPQUFPdUcsS0FBS3ZHLElBQUksRUFDaEIxRCxTQUFTaUssS0FBS2pLLE1BQU0sRUFDcEJzSyxhQUFhTCxLQUFLSyxVQUFVLEVBQzVCQyxXQUFXTixLQUFLTSxRQUFRLEVBQ3hCN0IsaUJBQWlCdUIsS0FBS3ZCLGNBQWMsRUFDcEM4QixTQUFTUCxLQUFLTyxNQUFNLEVBQ3BCQyxjQUFjUixLQUFLUSxXQUFXLEVBQzlCQyxTQUFTVCxLQUFLUyxNQUFNLEVBQ3BCQyxhQUFhVixLQUFLVSxVQUFVLEVBQzVCQyxRQUFRWCxLQUFLVyxLQUFLLEVBQ2xCQyxjQUFjWixLQUFLWSxXQUFXLEVBQzlCQyxZQUFZYixLQUFLYSxTQUFTLEVBQzFCQyxTQUFTZCxLQUFLYyxNQUFNLEVBQ3BCQyxVQUFVZixLQUFLZSxPQUFPLEVBQ3RCQyxZQUFZaEIsS0FBS2dCLFNBQVMsRUFDMUJDLFVBQVVqQixLQUFLaUIsT0FBTyxFQUN0QkMsU0FBU2xCLEtBQUtrQixNQUFNLEVBQ3BCQyxPQUFPbkIsS0FBS21CLElBQUksRUFDaEJDLFNBQVNwQixLQUFLb0IsTUFBTSxFQUNwQkMsWUFBWXJCLEtBQUtxQixTQUFTLEVBQzFCQyxZQUFZdEIsS0FBS3NCLFNBQVMsRUFDMUJDLFdBQVd2QixLQUFLdUIsUUFBUSxFQUN4QkMsWUFBWXhCLEtBQUt3QixTQUFTLEVBQzFCQyxZQUFZekIsS0FBS3lCLFNBQVMsRUFDMUJDLFVBQVUxQixLQUFLMEIsT0FBTyxFQUN0QkMsYUFBYTNCLEtBQUsyQixVQUFVLEVBQzVCQyxTQUFTNUIsS0FBSzRCLE1BQU0sRUFDcEJDLGNBQWM3QixLQUFLNkIsV0FBVyxFQUM5QkMsZUFBZTlCLEtBQUs4QixZQUFZLEVBQ2hDQyxpQkFBaUIvQixLQUFLK0IsY0FBYyxFQUNwQ0MsZUFBZWhDLEtBQUtnQyxZQUFZLEVBQ2hDQyxVQUFVakMsS0FBS2lDLE9BQU8sRUFDdEJDLFdBQVdsQyxLQUFLa0MsUUFBUSxFQUN4QkMsWUFBWW5DLEtBQUttQyxTQUFTLEVBQzFCQyxVQUFVcEMsS0FBS29DLE9BQU8sRUFDdEJDLGNBQWNyQyxLQUFLcUMsV0FBVyxFQUM5QnpJLFVBQVVvRyxLQUFLcEcsT0FBTyxFQUN0QjBJLGNBQWN0QyxLQUFLc0MsV0FBVyxFQUM5QkMsV0FBV3ZDLEtBQUt1QyxRQUFRLEVBQ3hCQyxhQUFheEMsS0FBS3dDLFVBQVU7UUFDaEMsSUFBSSxDQUFDek0sTUFBTSxHQUFHQSxTQUFTbUcsV0FBV25HLFdBQVdxQjtRQUM3QyxJQUFJLENBQUM0SSxJQUFJLEdBQUdBO1FBQ1pTLFVBQVdBLENBQUFBLFNBQVMxSixLQUFLd0YsS0FBSyxDQUFDQyxPQUFPLENBQUNpRSxPQUFNO1FBQzdDTixZQUFZQSxhQUFhO1FBQ3pCQyxjQUFjQSxlQUFlO1FBQzdCTSxhQUFhQSxjQUFjO1FBQzNCMkIsY0FBY0EsZUFBZTtRQUM3QjVJLE9BQU9BLFFBQVE7UUFDZjZHLFdBQVdBLGFBQWE7UUFDeEJELGNBQWVBLENBQUFBLGFBQWFvQyxXQUFXdkwsS0FBS3dMLGdCQUFnQixDQUFDckwsT0FBT2dKLFVBQVUsS0FBSyxFQUFDLEdBQUksdURBQXVEO1FBRS9JLElBQUlzQyxJQUNBQyxtQkFDQUMsU0FDQUMsT0FDQUMsU0FDQUMsUUFDQUMsTUFDQTdHLE9BQU8sSUFBSSxFQUNYOEcsYUFBYSxHQUNiQyxhQUFhLEdBQ2J4SixVQUFVcUcsS0FBS3JHLE9BQU8sSUFBSSxDQUFDOEUsa0JBQWtCdUIsS0FBS3JHLE9BQU8sS0FBSyxPQUM5RHlKLGNBQWNwRyxlQUFlakgsUUFBUW1GLGNBQ3JDbUksY0FBY3JHLGVBQWVqSCxRQUFRK0YsWUFDckN3SCxVQUFVRixlQUNWRyxVQUFVRixlQUNWRyxlQUFlLENBQUMvSixLQUFLSixPQUFPLENBQUMsWUFBWSxDQUFDLENBQUNJLEtBQUtKLE9BQU8sQ0FBQyxjQUFjMUIsV0FBVyxDQUFDLEVBQUUsS0FBSyxlQUN6RixzRkFBc0Y7UUFDMUY4TCxhQUFhbkssWUFBWXZELFNBQ3JCMk4sV0FBVzNOLE9BQU80TixhQUFhLElBQUl4TSxNQUNuQ3lNLFNBQVM7WUFBQztZQUFHO1lBQUc7U0FBRSxFQUNsQiwrQkFBK0I7UUFDbkNDLFNBQVM7WUFBQztZQUFHO1lBQUc7U0FBRSxFQUNkQyxjQUFjLEdBQ2RDLGVBQWUsU0FBU0E7WUFDMUIsT0FBT0QsY0FBYzFMO1FBQ3ZCLEdBQ0k0TCxlQUFlLFNBQVNBLGFBQWF4RixDQUFDLEVBQUV5RixnQkFBZ0I7WUFDMUQsT0FBTyxDQUFDN0gsS0FBS3VFLEtBQUssR0FBR25DLENBQUFBLEtBQU1pQyxVQUFVNUQsVUFBVTJCLEVBQUV6SSxNQUFNLEVBQUUwSyxXQUFXd0Qsb0JBQW9CVCxnQkFBZ0JoRixFQUFFMEYsV0FBVyxLQUFLLFdBQVdyQyxlQUFlQSxZQUFZckQsR0FBR3lGO1FBQ3JLLEdBQ0lFLGFBQWEsU0FBU0E7WUFDeEIvSCxLQUFLZ0ksR0FBRyxDQUFDbEcsS0FBSztZQUVkOUIsS0FBS2lJLEdBQUcsQ0FBQ25HLEtBQUs7WUFFZDBFLGtCQUFrQjBCLEtBQUs7WUFDdkIvRCxVQUFVQSxPQUFPbkU7UUFDbkIsR0FDSTRCLFNBQVMsU0FBU0E7WUFDcEIsSUFBSXVHLEtBQUtuSSxLQUFLd0gsTUFBTSxHQUFHaEYsZ0JBQWdCZ0YsU0FDbkNZLEtBQUtwSSxLQUFLeUgsTUFBTSxHQUFHakYsZ0JBQWdCaUYsU0FDbkNZLFdBQVc1SixLQUFLZ0UsR0FBRyxDQUFDMEYsT0FBT3BFLFdBQzNCdUUsV0FBVzdKLEtBQUtnRSxHQUFHLENBQUMyRixPQUFPckU7WUFFL0JvQixZQUFha0QsQ0FBQUEsWUFBWUMsUUFBTyxLQUFNbkQsU0FBU25GLE1BQU1tSSxJQUFJQyxJQUFJWixRQUFRQyxTQUFTLHNKQUFzSjtZQUVwTyxJQUFJWSxVQUFVO2dCQUNaeEQsV0FBVzdFLEtBQUt3SCxNQUFNLEdBQUcsS0FBSzNDLFFBQVE3RTtnQkFDdEM4RSxVQUFVOUUsS0FBS3dILE1BQU0sR0FBRyxLQUFLMUMsT0FBTzlFO2dCQUNwQ2lGLGFBQWFBLFVBQVVqRjtnQkFDdkJvRixhQUFhcEYsS0FBS3dILE1BQU0sR0FBRyxNQUFNVixhQUFhLEtBQUsxQixVQUFVcEY7Z0JBQzdEOEcsYUFBYTlHLEtBQUt3SCxNQUFNO2dCQUN4QkEsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUUsR0FBRztZQUN0QztZQUVBLElBQUljLFVBQVU7Z0JBQ1p0RCxVQUFVaEYsS0FBS3lILE1BQU0sR0FBRyxLQUFLekMsT0FBT2hGO2dCQUNwQytFLFFBQVEvRSxLQUFLeUgsTUFBTSxHQUFHLEtBQUsxQyxLQUFLL0U7Z0JBQ2hDa0YsYUFBYUEsVUFBVWxGO2dCQUN2QnFGLGFBQWFyRixLQUFLeUgsTUFBTSxHQUFHLE1BQU1WLGFBQWEsS0FBSzFCLFVBQVVyRjtnQkFDN0QrRyxhQUFhL0csS0FBS3lILE1BQU07Z0JBQ3hCQSxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHO1lBQ3RDO1lBRUEsSUFBSWYsU0FBU0QsU0FBUztnQkFDcEJqQixVQUFVQSxPQUFPeEY7Z0JBRWpCLElBQUl5RyxTQUFTO29CQUNYakMsZUFBZWlDLFlBQVksS0FBS2pDLFlBQVl4RTtvQkFDNUMwRSxVQUFVQSxPQUFPMUU7b0JBQ2pCeUcsVUFBVTtnQkFDWjtnQkFFQUMsUUFBUTtZQUNWO1lBRUFFLFVBQVUsQ0FBRUEsQ0FBQUEsU0FBUyxLQUFJLEtBQU1SLGNBQWNBLFdBQVdwRztZQUV4RCxJQUFJMkcsU0FBUztnQkFDWGQsUUFBUTdGO2dCQUNSMkcsVUFBVTtZQUNaO1lBRUFKLEtBQUs7UUFDUCxHQUNJZ0MsVUFBVSxTQUFTQSxRQUFRQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztZQUN4Q2xCLE1BQU0sQ0FBQ2tCLE1BQU0sSUFBSUY7WUFDakJmLE1BQU0sQ0FBQ2lCLE1BQU0sSUFBSUQ7WUFFakJ6SSxLQUFLZ0ksR0FBRyxDQUFDcEcsTUFBTSxDQUFDNEc7WUFFaEJ4SSxLQUFLaUksR0FBRyxDQUFDckcsTUFBTSxDQUFDNkc7WUFFaEJ2RSxXQUFXcUMsTUFBT0EsQ0FBQUEsS0FBS29DLHNCQUFzQi9HLE9BQU0sSUFBS0E7UUFDMUQsR0FDSWdILHdCQUF3QixTQUFTQSxzQkFBc0JKLENBQUMsRUFBRUMsQ0FBQztZQUM3RCxJQUFJdEMsWUFBWSxDQUFDVSxNQUFNO2dCQUNyQjdHLEtBQUs2RyxJQUFJLEdBQUdBLE9BQU9wSSxLQUFLZ0UsR0FBRyxDQUFDK0YsS0FBSy9KLEtBQUtnRSxHQUFHLENBQUNnRyxLQUFLLE1BQU07Z0JBQ3JEN0IsU0FBUztZQUNYO1lBRUEsSUFBSUMsU0FBUyxLQUFLO2dCQUNoQlcsTUFBTSxDQUFDLEVBQUUsSUFBSWdCO2dCQUVieEksS0FBS2dJLEdBQUcsQ0FBQ3BHLE1BQU0sQ0FBQzRHLEdBQUcsT0FBTyx1T0FBdU87WUFFblE7WUFFQSxJQUFJM0IsU0FBUyxLQUFLO2dCQUNoQlksTUFBTSxDQUFDLEVBQUUsSUFBSWdCO2dCQUViekksS0FBS2lJLEdBQUcsQ0FBQ3JHLE1BQU0sQ0FBQzZHLEdBQUc7WUFDckI7WUFFQXZFLFdBQVdxQyxNQUFPQSxDQUFBQSxLQUFLb0Msc0JBQXNCL0csT0FBTSxJQUFLQTtRQUMxRCxHQUNJaUgsVUFBVSxTQUFTQSxRQUFRekcsQ0FBQztZQUM5QixJQUFJd0YsYUFBYXhGLEdBQUcsSUFBSTtnQkFDdEI7WUFDRjtZQUVBQSxJQUFJRCxVQUFVQyxHQUFHQztZQUNqQixJQUFJbUcsSUFBSXBHLEVBQUUwRyxPQUFPLEVBQ2JMLElBQUlyRyxFQUFFMkcsT0FBTyxFQUNiWixLQUFLSyxJQUFJeEksS0FBS3dJLENBQUMsRUFDZkosS0FBS0ssSUFBSXpJLEtBQUt5SSxDQUFDLEVBQ2ZPLGFBQWFoSixLQUFLZ0osVUFBVTtZQUNoQ2hKLEtBQUt3SSxDQUFDLEdBQUdBO1lBQ1R4SSxLQUFLeUksQ0FBQyxHQUFHQTtZQUVULElBQUlPLGNBQWMsQ0FBQ2IsTUFBTUMsRUFBQyxLQUFPM0osQ0FBQUEsS0FBS2dFLEdBQUcsQ0FBQ3pDLEtBQUtpSixNQUFNLEdBQUdULE1BQU14RSxlQUFldkYsS0FBS2dFLEdBQUcsQ0FBQ3pDLEtBQUtrSixNQUFNLEdBQUdULE1BQU16RSxXQUFVLEdBQUk7Z0JBQ3RIeUMsV0FBWUEsQ0FBQUEsVUFBVXVDLGFBQWEsSUFBSSxJQUFJLDZEQUE2RDtnQkFFeEdBLGNBQWVoSixDQUFBQSxLQUFLZ0osVUFBVSxHQUFHLElBQUc7Z0JBQ3BDSixzQkFBc0JULElBQUlDO1lBQzVCO1FBQ0YsR0FDSWUsV0FBV25KLEtBQUsyRSxPQUFPLEdBQUcsU0FBVXZDLENBQUM7WUFDdkMsSUFBSXdGLGFBQWF4RixHQUFHLE1BQU1BLEtBQUtBLEVBQUVnSCxNQUFNLEVBQUU7Z0JBQ3ZDO1lBQ0Y7WUFFQXBKLEtBQUs2RyxJQUFJLEdBQUdBLE9BQU87WUFDbkJMLGtCQUFrQjBCLEtBQUs7WUFDdkJsSSxLQUFLakMsU0FBUyxHQUFHO1lBQ2pCcUUsSUFBSUQsVUFBVUMsSUFBSSx3RkFBd0Y7WUFFMUcwRSxhQUFhQyxhQUFhO1lBQzFCL0csS0FBS2lKLE1BQU0sR0FBR2pKLEtBQUt3SSxDQUFDLEdBQUdwRyxFQUFFMEcsT0FBTztZQUNoQzlJLEtBQUtrSixNQUFNLEdBQUdsSixLQUFLeUksQ0FBQyxHQUFHckcsRUFBRTJHLE9BQU87WUFFaEMvSSxLQUFLZ0ksR0FBRyxDQUFDbEcsS0FBSyxJQUFJLDZKQUE2SjtZQUcvSzlCLEtBQUtpSSxHQUFHLENBQUNuRyxLQUFLO1lBRWQxRSxhQUFhc0ksZUFBZS9MLFNBQVMyTixVQUFVL0wsV0FBVyxDQUFDLEVBQUUsRUFBRXNOLFNBQVN0TCxTQUFTO1lBRWpGeUMsS0FBS3dILE1BQU0sR0FBR3hILEtBQUt5SCxNQUFNLEdBQUc7WUFDNUI5QyxXQUFXQSxRQUFRM0U7UUFDckIsR0FDSXFKLGFBQWFySixLQUFLNEUsU0FBUyxHQUFHLFNBQVV4QyxDQUFDO1lBQzNDLElBQUl3RixhQUFheEYsR0FBRyxJQUFJO2dCQUN0QjtZQUNGO1lBRUExRSxnQkFBZ0JnSSxlQUFlL0wsU0FBUzJOLFVBQVUvTCxXQUFXLENBQUMsRUFBRSxFQUFFc04sU0FBUztZQUUzRSxJQUFJUyxpQkFBaUIsQ0FBQ0MsTUFBTXZKLEtBQUt5SSxDQUFDLEdBQUd6SSxLQUFLa0osTUFBTSxHQUM1Q00sY0FBY3hKLEtBQUtnSixVQUFVLEVBQzdCUyxpQkFBaUJELGVBQWdCL0ssQ0FBQUEsS0FBS2dFLEdBQUcsQ0FBQ3pDLEtBQUt3SSxDQUFDLEdBQUd4SSxLQUFLaUosTUFBTSxJQUFJLEtBQUt4SyxLQUFLZ0UsR0FBRyxDQUFDekMsS0FBS3lJLENBQUMsR0FBR3pJLEtBQUtrSixNQUFNLElBQUksSUFDeEcsMEdBQTBHO1lBQzlHUSxZQUFZdkgsVUFBVUM7WUFFdEIsSUFBSSxDQUFDcUgsa0JBQWtCSCxnQkFBZ0I7Z0JBQ3JDdEosS0FBS2dJLEdBQUcsQ0FBQ2xHLEtBQUs7Z0JBRWQ5QixLQUFLaUksR0FBRyxDQUFDbkcsS0FBSyxJQUFJLDhVQUE4VTtnQkFHaFcsSUFBSU8sa0JBQWtCNkQsYUFBYTtvQkFDakN2TCxLQUFLZ1AsV0FBVyxDQUFDLE1BQU07d0JBQ3JCLHFuQkFBcW5CO3dCQUNybkIsSUFBSTNOLGFBQWEwTCxjQUFjLE9BQU8sQ0FBQ3RGLEVBQUV3SCxnQkFBZ0IsRUFBRTs0QkFDekQsSUFBSXhILEVBQUV6SSxNQUFNLENBQUNrUSxLQUFLLEVBQUU7Z0NBQ2xCLDJFQUEyRTtnQ0FDM0V6SCxFQUFFekksTUFBTSxDQUFDa1EsS0FBSzs0QkFDaEIsT0FBTyxJQUFJdkMsU0FBU3dDLFdBQVcsRUFBRTtnQ0FDL0IsSUFBSUMsaUJBQWlCekMsU0FBU3dDLFdBQVcsQ0FBQztnQ0FDMUNDLGVBQWVDLGNBQWMsQ0FBQyxTQUFTLE1BQU0sTUFBTWxQLE1BQU0sR0FBRzRPLFVBQVVPLE9BQU8sRUFBRVAsVUFBVVEsT0FBTyxFQUFFUixVQUFVWixPQUFPLEVBQUVZLFVBQVVYLE9BQU8sRUFBRSxPQUFPLE9BQU8sT0FBTyxPQUFPLEdBQUc7Z0NBQ3ZLM0csRUFBRXpJLE1BQU0sQ0FBQ3dRLGFBQWEsQ0FBQ0o7NEJBQ3pCO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQS9KLEtBQUtnSixVQUFVLEdBQUdoSixLQUFLb0ssV0FBVyxHQUFHcEssS0FBS2pDLFNBQVMsR0FBRztZQUN0RG9HLFVBQVVxRixlQUFlLENBQUM5RCxnQkFBZ0JjLGtCQUFrQjZELE9BQU8sQ0FBQztZQUNwRTVELFdBQVc3RSxVQUFVLHNFQUFzRTtZQUUzRjZDLGFBQWErRSxlQUFlL0UsVUFBVXpFO1lBQ3RDNEUsYUFBYUEsVUFBVTVFLE1BQU15SjtRQUMvQixHQUNJYSxrQkFBa0IsU0FBU0EsZ0JBQWdCbEksQ0FBQztZQUM5QyxPQUFPQSxFQUFFbUksT0FBTyxJQUFJbkksRUFBRW1JLE9BQU8sQ0FBQ3pRLE1BQU0sR0FBRyxLQUFNa0csQ0FBQUEsS0FBS29LLFdBQVcsR0FBRyxJQUFHLEtBQU16RSxlQUFldkQsR0FBR3BDLEtBQUtnSixVQUFVO1FBQzVHLEdBQ0l3QixnQkFBZ0IsU0FBU0E7WUFDM0IsT0FBTyxDQUFDeEssS0FBS29LLFdBQVcsR0FBRyxLQUFJLEtBQU14RSxhQUFhNUY7UUFDcEQsR0FDSXlLLFdBQVcsU0FBU0EsU0FBU3JJLENBQUM7WUFDaEMsSUFBSXdGLGFBQWF4RixJQUFJO2dCQUNuQjtZQUNGO1lBRUEsSUFBSW9HLElBQUl4QixlQUNKeUIsSUFBSXhCO1lBQ1JzQixRQUFRLENBQUNDLElBQUl0QixPQUFNLElBQUtqQixhQUFhLENBQUN3QyxJQUFJdEIsT0FBTSxJQUFLbEIsYUFBYTtZQUNsRWlCLFVBQVVzQjtZQUNWckIsVUFBVXNCO1lBQ1Z0RSxVQUFVcUMsa0JBQWtCNkQsT0FBTyxDQUFDO1FBQ3RDLEdBQ0lLLFdBQVcsU0FBU0EsU0FBU3RJLENBQUM7WUFDaEMsSUFBSXdGLGFBQWF4RixJQUFJO2dCQUNuQjtZQUNGO1lBRUFBLElBQUlELFVBQVVDLEdBQUdDO1lBQ2pCd0QsV0FBWWMsQ0FBQUEsVUFBVSxJQUFHO1lBQ3pCLElBQUlnRSxhQUFhLENBQUN2SSxFQUFFd0ksU0FBUyxLQUFLLElBQUkzRyxhQUFhN0IsRUFBRXdJLFNBQVMsS0FBSyxJQUFJOVAsS0FBSytQLFdBQVcsR0FBRyxLQUFLdkc7WUFDL0ZpRSxRQUFRbkcsRUFBRW9GLE1BQU0sR0FBR21ELFlBQVl2SSxFQUFFcUYsTUFBTSxHQUFHa0QsWUFBWTtZQUN0RHhHLFVBQVUsQ0FBQ3VCLGdCQUFnQmMsa0JBQWtCNkQsT0FBTyxDQUFDO1FBQ3ZELEdBQ0lTLFVBQVUsU0FBU0EsUUFBUTFJLENBQUM7WUFDOUIsSUFBSXdGLGFBQWF4RixJQUFJO2dCQUNuQjtZQUNGO1lBRUEsSUFBSW9HLElBQUlwRyxFQUFFMEcsT0FBTyxFQUNiTCxJQUFJckcsRUFBRTJHLE9BQU8sRUFDYlosS0FBS0ssSUFBSXhJLEtBQUt3SSxDQUFDLEVBQ2ZKLEtBQUtLLElBQUl6SSxLQUFLeUksQ0FBQztZQUNuQnpJLEtBQUt3SSxDQUFDLEdBQUdBO1lBQ1R4SSxLQUFLeUksQ0FBQyxHQUFHQTtZQUNUL0IsUUFBUTtZQUNSdkMsVUFBVXFDLGtCQUFrQjZELE9BQU8sQ0FBQztZQUNuQ2xDLENBQUFBLE1BQU1DLEVBQUMsS0FBTVEsc0JBQXNCVCxJQUFJQztRQUMxQyxHQUNJMkMsV0FBVyxTQUFTQSxTQUFTM0ksQ0FBQztZQUNoQ3BDLEtBQUt1RSxLQUFLLEdBQUduQztZQUNia0QsUUFBUXRGO1FBQ1YsR0FDSWdMLGNBQWMsU0FBU0EsWUFBWTVJLENBQUM7WUFDdENwQyxLQUFLdUUsS0FBSyxHQUFHbkM7WUFDYm1ELFdBQVd2RjtRQUNiLEdBQ0lpTCxXQUFXLFNBQVNBLFNBQVM3SSxDQUFDO1lBQ2hDLE9BQU93RixhQUFheEYsTUFBTUQsVUFBVUMsR0FBR0MsbUJBQW1CMkQsUUFBUWhHO1FBQ3BFO1FBRUF3RyxvQkFBb0J4RyxLQUFLa0wsR0FBRyxHQUFHdlEsS0FBS2dQLFdBQVcsQ0FBQ3ZGLGVBQWUsTUFBTTJELFlBQVlHLEtBQUs7UUFDdEZsSSxLQUFLd0gsTUFBTSxHQUFHeEgsS0FBS3lILE1BQU0sR0FBRztRQUM1QnpILEtBQUtnSSxHQUFHLEdBQUc5RyxpQkFBaUIsR0FBRyxJQUFJO1FBQ25DbEIsS0FBS2lJLEdBQUcsR0FBRy9HLGlCQUFpQixHQUFHLElBQUk7UUFDbkNsQixLQUFLa0gsT0FBTyxHQUFHRjtRQUNmaEgsS0FBS21ILE9BQU8sR0FBR0Y7UUFDZmpILEtBQUtnSixVQUFVLEdBQUdoSixLQUFLb0ssV0FBVyxHQUFHcEssS0FBS2pDLFNBQVMsR0FBRztRQUV0RHZDLFNBQVMsSUFBSTtRQUVid0UsS0FBS21MLE1BQU0sR0FBRyxTQUFVL0ksQ0FBQztZQUN2QixJQUFJLENBQUNwQyxLQUFLb0wsU0FBUyxFQUFFO2dCQUNuQmhPLGFBQWFpSyxhQUFhQyxXQUFXM04sUUFBUSxVQUFVbUU7Z0JBRXZEVCxLQUFLSixPQUFPLENBQUMsYUFBYSxLQUFLRyxhQUFhaUssYUFBYUMsV0FBVzNOLFFBQVEsVUFBVThRLFVBQVVsTixTQUFTQztnQkFDekdILEtBQUtKLE9BQU8sQ0FBQyxZQUFZLEtBQUtHLGFBQWF6RCxRQUFRLFNBQVMrUSxVQUFVbk4sU0FBU0M7Z0JBRS9FLElBQUlILEtBQUtKLE9BQU8sQ0FBQyxZQUFZLEtBQUsvQixZQUFZbUMsS0FBS0osT0FBTyxDQUFDLGNBQWMsR0FBRztvQkFDMUVHLGFBQWF6RCxRQUFRNEIsV0FBVyxDQUFDLEVBQUUsRUFBRTROLFVBQVU1TCxTQUFTQztvQkFFeERKLGFBQWFrSyxVQUFVL0wsV0FBVyxDQUFDLEVBQUUsRUFBRThOO29CQUV2Q2pNLGFBQWFrSyxVQUFVL0wsV0FBVyxDQUFDLEVBQUUsRUFBRThOO29CQUV2Q25ELGVBQWU5SSxhQUFhekQsUUFBUSxTQUFTZ08sY0FBYyxNQUFNO29CQUNqRTNCLFdBQVc1SSxhQUFhekQsUUFBUSxTQUFTc1I7b0JBQ3pDdEYsa0JBQWtCdkksYUFBYWtLLFVBQVUsZ0JBQWdCZ0Q7b0JBQ3pEMUUsZ0JBQWdCeEksYUFBYWtLLFVBQVUsY0FBY2tEO29CQUNyRGxGLFdBQVdsSSxhQUFhekQsUUFBUXdCLGVBQWUsU0FBUzRQO29CQUN4RHhGLGNBQWNuSSxhQUFhekQsUUFBUXdCLGVBQWUsU0FBUzZQO29CQUMzRHhGLFVBQVVwSSxhQUFhekQsUUFBUXdCLGVBQWUsUUFBUTJQO2dCQUN4RDtnQkFFQTlLLEtBQUtvTCxTQUFTLEdBQUc7Z0JBQ2pCcEwsS0FBS2dKLFVBQVUsR0FBR2hKLEtBQUtvSyxXQUFXLEdBQUdwSyxLQUFLakMsU0FBUyxHQUFHMkksUUFBUUQsVUFBVTtnQkFFeEV6RyxLQUFLZ0ksR0FBRyxDQUFDbEcsS0FBSztnQkFFZDlCLEtBQUtpSSxHQUFHLENBQUNuRyxLQUFLO2dCQUVkb0YsVUFBVUY7Z0JBQ1ZHLFVBQVVGO2dCQUNWN0UsS0FBS0EsRUFBRS9FLElBQUksSUFBSThMLFNBQVMvRztnQkFDeEIwRCxZQUFZQSxTQUFTOUY7WUFDdkI7WUFFQSxPQUFPQTtRQUNUO1FBRUFBLEtBQUtxTCxPQUFPLEdBQUc7WUFDYixJQUFJckwsS0FBS29MLFNBQVMsRUFBRTtnQkFDbEIsZ0dBQWdHO2dCQUNoR3ZQLFdBQVd5UCxNQUFNLENBQUMsU0FBVUMsQ0FBQztvQkFDM0IsT0FBT0EsTUFBTXZMLFFBQVE5QyxZQUFZcU8sRUFBRTVSLE1BQU07Z0JBQzNDLEdBQUdHLE1BQU0sSUFBSTRELGdCQUFnQjJKLGFBQWFDLFdBQVczTixRQUFRLFVBQVVtRTtnQkFFdkUsSUFBSWtDLEtBQUtqQyxTQUFTLEVBQUU7b0JBQ2xCaUMsS0FBS2dJLEdBQUcsQ0FBQ2xHLEtBQUs7b0JBRWQ5QixLQUFLaUksR0FBRyxDQUFDbkcsS0FBSztvQkFFZHBFLGdCQUFnQmdJLGVBQWUvTCxTQUFTMk4sVUFBVS9MLFdBQVcsQ0FBQyxFQUFFLEVBQUVzTixTQUFTO2dCQUM3RTtnQkFFQW5MLGdCQUFnQjJKLGFBQWFDLFdBQVczTixRQUFRLFVBQVU4USxVQUFVak47Z0JBRXBFRSxnQkFBZ0IvRCxRQUFRLFNBQVMrUSxVQUFVbE47Z0JBRTNDRSxnQkFBZ0IvRCxRQUFRNEIsV0FBVyxDQUFDLEVBQUUsRUFBRTROLFVBQVUzTDtnQkFFbERFLGdCQUFnQjRKLFVBQVUvTCxXQUFXLENBQUMsRUFBRSxFQUFFOE47Z0JBRTFDM0wsZ0JBQWdCNEosVUFBVS9MLFdBQVcsQ0FBQyxFQUFFLEVBQUU4TjtnQkFFMUMzTCxnQkFBZ0IvRCxRQUFRLFNBQVNnTyxjQUFjO2dCQUUvQ2pLLGdCQUFnQi9ELFFBQVEsU0FBU3NSO2dCQUVqQ3ZOLGdCQUFnQjRKLFVBQVUsZ0JBQWdCZ0Q7Z0JBRTFDNU0sZ0JBQWdCNEosVUFBVSxjQUFja0Q7Z0JBRXhDOU0sZ0JBQWdCL0QsUUFBUXdCLGVBQWUsU0FBUzRQO2dCQUVoRHJOLGdCQUFnQi9ELFFBQVF3QixlQUFlLFNBQVM2UDtnQkFFaER0TixnQkFBZ0IvRCxRQUFRd0IsZUFBZSxRQUFRMlA7Z0JBRS9DOUssS0FBS29MLFNBQVMsR0FBR3BMLEtBQUtqQyxTQUFTLEdBQUdpQyxLQUFLZ0osVUFBVSxHQUFHO2dCQUNwRGpELGFBQWFBLFVBQVUvRjtZQUN6QjtRQUNGO1FBRUFBLEtBQUt3TCxJQUFJLEdBQUd4TCxLQUFLeUwsTUFBTSxHQUFHO1lBQ3hCekwsS0FBS3FMLE9BQU87WUFFWixJQUFJeFIsSUFBSWdDLFdBQVdvQixPQUFPLENBQUMrQztZQUUzQm5HLEtBQUssS0FBS2dDLFdBQVc2UCxNQUFNLENBQUM3UixHQUFHO1lBQy9CeUIsZ0JBQWdCMEUsUUFBUzFFLENBQUFBLGNBQWM7UUFDekM7UUFFQU8sV0FBV2UsSUFBSSxDQUFDb0Q7UUFFaEIwRixnQkFBZ0J4SSxZQUFZdkQsV0FBWTJCLENBQUFBLGNBQWMwRSxJQUFHO1FBQ3pEQSxLQUFLbUwsTUFBTSxDQUFDNUc7SUFDZDtJQUVBakssYUFBYTRJLFVBQVU7UUFBQztZQUN0QjdJLEtBQUs7WUFDTHNSLEtBQUssU0FBU0E7Z0JBQ1osT0FBTyxJQUFJLENBQUMzRCxHQUFHLENBQUNqRyxXQUFXO1lBQzdCO1FBQ0Y7UUFBRztZQUNEMUgsS0FBSztZQUNMc1IsS0FBSyxTQUFTQTtnQkFDWixPQUFPLElBQUksQ0FBQzFELEdBQUcsQ0FBQ2xHLFdBQVc7WUFDN0I7UUFDRjtLQUFFO0lBRUYsT0FBT21CO0FBQ1QsSUFBSTtBQUNKQSxTQUFTMEksT0FBTyxHQUFHO0FBRW5CMUksU0FBUzJJLE1BQU0sR0FBRyxTQUFVakksSUFBSTtJQUM5QixPQUFPLElBQUlWLFNBQVNVO0FBQ3RCO0FBRUFWLFNBQVM0SSxRQUFRLEdBQUdsSjtBQUVwQk0sU0FBUzZJLE1BQU0sR0FBRztJQUNoQixPQUFPbFEsV0FBV21RLEtBQUs7QUFDekI7QUFFQTlJLFNBQVMrSSxPQUFPLEdBQUcsU0FBVTFGLEVBQUU7SUFDN0IsT0FBTzFLLFdBQVd5UCxNQUFNLENBQUMsU0FBVUMsQ0FBQztRQUNsQyxPQUFPQSxFQUFFM0gsSUFBSSxDQUFDMkMsRUFBRSxLQUFLQTtJQUN2QixFQUFFLENBQUMsRUFBRTtBQUNQO0FBRUE5SyxjQUFjZCxLQUFLZ0IsY0FBYyxDQUFDdUg7QUFDcUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xNC4yL25vZGVfbW9kdWxlcy9nc2FwL09ic2VydmVyLmpzP2M1Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKiFcbiAqIE9ic2VydmVyIDMuMTQuMlxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZVxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9jbGFtcCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsLFxuICAgIF9ib2R5LFxuICAgIF9pc1RvdWNoLFxuICAgIF9wb2ludGVyVHlwZSxcbiAgICBTY3JvbGxUcmlnZ2VyLFxuICAgIF9yb290LFxuICAgIF9ub3JtYWxpemVyLFxuICAgIF9ldmVudFR5cGVzLFxuICAgIF9jb250ZXh0LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfc3RhcnR1cCA9IDEsXG4gICAgX29ic2VydmVycyA9IFtdLFxuICAgIF9zY3JvbGxlcnMgPSBbXSxcbiAgICBfcHJveGllcyA9IFtdLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufSxcbiAgICBfaW50ZWdyYXRlID0gZnVuY3Rpb24gX2ludGVncmF0ZSgpIHtcbiAgdmFyIGNvcmUgPSBTY3JvbGxUcmlnZ2VyLmNvcmUsXG4gICAgICBkYXRhID0gY29yZS5icmlkZ2UgfHwge30sXG4gICAgICBzY3JvbGxlcnMgPSBjb3JlLl9zY3JvbGxlcnMsXG4gICAgICBwcm94aWVzID0gY29yZS5fcHJveGllcztcbiAgc2Nyb2xsZXJzLnB1c2guYXBwbHkoc2Nyb2xsZXJzLCBfc2Nyb2xsZXJzKTtcbiAgcHJveGllcy5wdXNoLmFwcGx5KHByb3hpZXMsIF9wcm94aWVzKTtcbiAgX3Njcm9sbGVycyA9IHNjcm9sbGVycztcbiAgX3Byb3hpZXMgPSBwcm94aWVzO1xuXG4gIF9icmlkZ2UgPSBmdW5jdGlvbiBfYnJpZGdlKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGRhdGFbbmFtZV0odmFsdWUpO1xuICB9O1xufSxcbiAgICBfZ2V0UHJveHlQcm9wID0gZnVuY3Rpb24gX2dldFByb3h5UHJvcChlbGVtZW50LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgJiYgX3Byb3hpZXNbX3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSArIDFdW3Byb3BlcnR5XTtcbn0sXG4gICAgX2lzVmlld3BvcnQgPSBmdW5jdGlvbiBfaXNWaWV3cG9ydChlbCkge1xuICByZXR1cm4gISF+X3Jvb3QuaW5kZXhPZihlbCk7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBwYXNzaXZlLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xuICAgIHBhc3NpdmU6IHBhc3NpdmUgIT09IGZhbHNlLFxuICAgIGNhcHR1cmU6ICEhY2FwdHVyZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xufSxcbiAgICBfc2Nyb2xsTGVmdCA9IFwic2Nyb2xsTGVmdFwiLFxuICAgIF9zY3JvbGxUb3AgPSBcInNjcm9sbFRvcFwiLFxuICAgIF9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgcmV0dXJuIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlzUHJlc3NlZCB8fCBfc2Nyb2xsZXJzLmNhY2hlKys7XG59LFxuICAgIF9zY3JvbGxDYWNoZUZ1bmMgPSBmdW5jdGlvbiBfc2Nyb2xsQ2FjaGVGdW5jKGYsIGRvTm90Q2FjaGUpIHtcbiAgdmFyIGNhY2hpbmdGdW5jID0gZnVuY3Rpb24gY2FjaGluZ0Z1bmModmFsdWUpIHtcbiAgICAvLyBzaW5jZSByZWFkaW5nIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdC9wYWdlT2Zmc2V0WS9wYWdlT2Zmc2V0WCBjYW4gdHJpZ2dlciBhIGxheW91dCwgdGhpcyBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gY2FjaGUgdGhlIHZhbHVlIHNvIGl0IG9ubHkgZ2V0cyByZWFkIGZyZXNoIGFmdGVyIGEgXCJzY3JvbGxcIiBldmVudCBmaXJlcyAob3Igd2hpbGUgd2UncmUgcmVmcmVzaGluZyBiZWNhdXNlIHRoYXQgY2FuIGxlbmd0aGVuIHRoZSBwYWdlIGFuZCBhbHRlciB0aGUgc2Nyb2xsIHBvc2l0aW9uKS4gd2hlbiBcInNvZnRcIiBpcyB0cnVlLCB0aGF0IG1lYW5zIGRvbid0IGFjdHVhbGx5IHNldCB0aGUgc2Nyb2xsLCBidXQgY2FjaGUgdGhlIG5ldyB2YWx1ZSBpbnN0ZWFkICh1c2VmdWwgaW4gU2Nyb2xsU21vb3RoZXIpXG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICBfc3RhcnR1cCAmJiAoX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIik7IC8vIG90aGVyd2lzZSB0aGUgbmV3IHBvc2l0aW9uIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IHRoZSBicm93c2VyIG9ubG9hZC5cblxuICAgICAgdmFyIGlzTm9ybWFsaXppbmcgPSBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pc1ByZXNzZWQ7XG4gICAgICB2YWx1ZSA9IGNhY2hpbmdGdW5jLnYgPSBNYXRoLnJvdW5kKHZhbHVlKSB8fCAoX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaU9TID8gMSA6IDApOyAvL1RPRE86IGlPUyBCdWc6IGlmIHlvdSBhbGxvdyBpdCB0byBnbyB0byAwLCBTYWZhcmkgY2FuIHN0YXJ0IHRvIHJlcG9ydCBzdXBlciBzdHJhbmdlICh3aWxkbHkgaW5hY2N1cmF0ZSkgdG91Y2ggcG9zaXRpb25zIVxuXG4gICAgICBmKHZhbHVlKTtcbiAgICAgIGNhY2hpbmdGdW5jLmNhY2hlSUQgPSBfc2Nyb2xsZXJzLmNhY2hlO1xuICAgICAgaXNOb3JtYWxpemluZyAmJiBfYnJpZGdlKFwic3NcIiwgdmFsdWUpOyAvLyBzZXQgc2Nyb2xsIChub3RpZnkgU2Nyb2xsVHJpZ2dlciBzbyBpdCBjYW4gZGlzcGF0Y2ggYSBcInNjcm9sbFN0YXJ0XCIgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gICAgfSBlbHNlIGlmIChkb05vdENhY2hlIHx8IF9zY3JvbGxlcnMuY2FjaGUgIT09IGNhY2hpbmdGdW5jLmNhY2hlSUQgfHwgX2JyaWRnZShcInJlZlwiKSkge1xuICAgICAgY2FjaGluZ0Z1bmMuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG4gICAgICBjYWNoaW5nRnVuYy52ID0gZigpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoaW5nRnVuYy52ICsgY2FjaGluZ0Z1bmMub2Zmc2V0O1xuICB9O1xuXG4gIGNhY2hpbmdGdW5jLm9mZnNldCA9IDA7XG4gIHJldHVybiBmICYmIGNhY2hpbmdGdW5jO1xufSxcbiAgICBfaG9yaXpvbnRhbCA9IHtcbiAgczogX3Njcm9sbExlZnQsXG4gIHA6IFwibGVmdFwiLFxuICBwMjogXCJMZWZ0XCIsXG4gIG9zOiBcInJpZ2h0XCIsXG4gIG9zMjogXCJSaWdodFwiLFxuICBkOiBcIndpZHRoXCIsXG4gIGQyOiBcIldpZHRoXCIsXG4gIGE6IFwieFwiLFxuICBzYzogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8odmFsdWUsIF92ZXJ0aWNhbC5zYygpKSA6IF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsTGVmdF0gfHwgX2RvY0VsW19zY3JvbGxMZWZ0XSB8fCBfYm9keVtfc2Nyb2xsTGVmdF0gfHwgMDtcbiAgfSlcbn0sXG4gICAgX3ZlcnRpY2FsID0ge1xuICBzOiBfc2Nyb2xsVG9wLFxuICBwOiBcInRvcFwiLFxuICBwMjogXCJUb3BcIixcbiAgb3M6IFwiYm90dG9tXCIsXG4gIG9zMjogXCJCb3R0b21cIixcbiAgZDogXCJoZWlnaHRcIixcbiAgZDI6IFwiSGVpZ2h0XCIsXG4gIGE6IFwieVwiLFxuICBvcDogX2hvcml6b250YWwsXG4gIHNjOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyhfaG9yaXpvbnRhbC5zYygpLCB2YWx1ZSkgOiBfd2luLnBhZ2VZT2Zmc2V0IHx8IF9kb2NbX3Njcm9sbFRvcF0gfHwgX2RvY0VsW19zY3JvbGxUb3BdIHx8IF9ib2R5W19zY3JvbGxUb3BdIHx8IDA7XG4gIH0pXG59LFxuICAgIF9nZXRUYXJnZXQgPSBmdW5jdGlvbiBfZ2V0VGFyZ2V0KHQsIHNlbGYpIHtcbiAgcmV0dXJuIChzZWxmICYmIHNlbGYuX2N0eCAmJiBzZWxmLl9jdHguc2VsZWN0b3IgfHwgZ3NhcC51dGlscy50b0FycmF5KSh0KVswXSB8fCAodHlwZW9mIHQgPT09IFwic3RyaW5nXCIgJiYgZ3NhcC5jb25maWcoKS5udWxsVGFyZ2V0V2FybiAhPT0gZmFsc2UgPyBjb25zb2xlLndhcm4oXCJFbGVtZW50IG5vdCBmb3VuZDpcIiwgdCkgOiBudWxsKTtcbn0sXG4gICAgX2lzV2l0aGluID0gZnVuY3Rpb24gX2lzV2l0aGluKGVsZW1lbnQsIGxpc3QpIHtcbiAgLy8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxpc3Qgb3IgaXMgYSBkZXNjZW5kYW50IG9mIGFuIGVsZW1lbnQgaW4gdGhlIGxpc3QuXG4gIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsaXN0W2ldID09PSBlbGVtZW50IHx8IGxpc3RbaV0uY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0sXG4gICAgX2dldFNjcm9sbEZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsRnVuYyhlbGVtZW50LCBfcmVmKSB7XG4gIHZhciBzID0gX3JlZi5zLFxuICAgICAgc2MgPSBfcmVmLnNjO1xuICAvLyB3ZSBzdG9yZSB0aGUgc2Nyb2xsZXIgZnVuY3Rpb25zIGluIGFuIGFsdGVybmF0aW5nIHNlcXVlbmNlZCBBcnJheSBsaWtlIFtlbGVtZW50LCB2ZXJ0aWNhbFNjcm9sbEZ1bmMsIGhvcml6b250YWxTY3JvbGxGdW5jLCAuLi5dIHNvIHRoYXQgd2UgY2FuIG1pbmltaXplIG1lbW9yeSwgbWF4aW1pemUgcGVyZm9ybWFuY2UsIGFuZCB3ZSBhbHNvIHJlY29yZCB0aGUgbGFzdCBwb3NpdGlvbiBhcyBhIFwiLnJlY1wiIHByb3BlcnR5IGluIG9yZGVyIHRvIHJldmVydCB0byB0aGF0IGFmdGVyIHJlZnJlc2hpbmcgdG8gZW5zdXJlIHRoaW5ncyBkb24ndCBzaGlmdCBhcm91bmQuXG4gIF9pc1ZpZXdwb3J0KGVsZW1lbnQpICYmIChlbGVtZW50ID0gX2RvYy5zY3JvbGxpbmdFbGVtZW50IHx8IF9kb2NFbCk7XG5cbiAgdmFyIGkgPSBfc2Nyb2xsZXJzLmluZGV4T2YoZWxlbWVudCksXG4gICAgICBvZmZzZXQgPSBzYyA9PT0gX3ZlcnRpY2FsLnNjID8gMSA6IDI7XG5cbiAgIX5pICYmIChpID0gX3Njcm9sbGVycy5wdXNoKGVsZW1lbnQpIC0gMSk7XG4gIF9zY3JvbGxlcnNbaSArIG9mZnNldF0gfHwgX2FkZExpc3RlbmVyKGVsZW1lbnQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7IC8vIGNsZWFyIHRoZSBjYWNoZSB3aGVuIGEgc2Nyb2xsIG9jY3Vyc1xuXG4gIHZhciBwcmV2ID0gX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSxcbiAgICAgIGZ1bmMgPSBwcmV2IHx8IChfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdID0gX3Njcm9sbENhY2hlRnVuYyhfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHMpLCB0cnVlKSB8fCAoX2lzVmlld3BvcnQoZWxlbWVudCkgPyBzYyA6IF9zY3JvbGxDYWNoZUZ1bmMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBlbGVtZW50W3NdID0gdmFsdWUgOiBlbGVtZW50W3NdO1xuICB9KSkpO1xuICBmdW5jLnRhcmdldCA9IGVsZW1lbnQ7XG4gIHByZXYgfHwgKGZ1bmMuc21vb3RoID0gZ3NhcC5nZXRQcm9wZXJ0eShlbGVtZW50LCBcInNjcm9sbEJlaGF2aW9yXCIpID09PSBcInNtb290aFwiKTsgLy8gb25seSBzZXQgaXQgdGhlIGZpcnN0IHRpbWUgKGRvbid0IHJlc2V0IGV2ZXJ5IHRpbWUgYSBzY3JvbGxGdW5jIGlzIHJlcXVlc3RlZCBiZWNhdXNlIHBlcmhhcHMgaXQgaGFwcGVucyBkdXJpbmcgYSByZWZyZXNoKCkgd2hlbiBpdCdzIGRpc2FibGVkIGluIFNjcm9sbFRyaWdnZXIuXG5cbiAgcmV0dXJuIGZ1bmM7XG59LFxuICAgIF9nZXRWZWxvY2l0eVByb3AgPSBmdW5jdGlvbiBfZ2V0VmVsb2NpdHlQcm9wKHZhbHVlLCBtaW5UaW1lUmVmcmVzaCwgdXNlRGVsdGEpIHtcbiAgdmFyIHYxID0gdmFsdWUsXG4gICAgICB2MiA9IHZhbHVlLFxuICAgICAgdDEgPSBfZ2V0VGltZSgpLFxuICAgICAgdDIgPSB0MSxcbiAgICAgIG1pbiA9IG1pblRpbWVSZWZyZXNoIHx8IDUwLFxuICAgICAgZHJvcFRvWmVyb1RpbWUgPSBNYXRoLm1heCg1MDAsIG1pbiAqIDMpLFxuICAgICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHZhbHVlLCBmb3JjZSkge1xuICAgIHZhciB0ID0gX2dldFRpbWUoKTtcblxuICAgIGlmIChmb3JjZSB8fCB0IC0gdDEgPiBtaW4pIHtcbiAgICAgIHYyID0gdjE7XG4gICAgICB2MSA9IHZhbHVlO1xuICAgICAgdDIgPSB0MTtcbiAgICAgIHQxID0gdDtcbiAgICB9IGVsc2UgaWYgKHVzZURlbHRhKSB7XG4gICAgICB2MSArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90IHRvdGFsbHkgbmVjZXNzYXJ5LCBidXQgbWFrZXMgaXQgYSBiaXQgbW9yZSBhY2N1cmF0ZSBieSBhZGp1c3RpbmcgdGhlIHYxIHZhbHVlIGFjY29yZGluZyB0byB0aGUgbmV3IHNsb3BlLiBUaGlzIHdheSB3ZSdyZSBub3QganVzdCBpZ25vcmluZyB0aGUgaW5jb21pbmcgZGF0YS4gUmVtb3ZpbmcgZm9yIG5vdyBiZWNhdXNlIGl0IGRvZXNuJ3Qgc2VlbSB0byBtYWtlIG11Y2ggcHJhY3RpY2FsIGRpZmZlcmVuY2UgYW5kIGl0J3MgcHJvYmFibHkgbm90IHdvcnRoIHRoZSBrYi5cbiAgICAgIHYxID0gdjIgKyAodmFsdWUgLSB2MikgLyAodCAtIHQyKSAqICh0MSAtIHQyKTtcbiAgICB9XG4gIH0sXG4gICAgICByZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHYyID0gdjEgPSB1c2VEZWx0YSA/IDAgOiB2MTtcbiAgICB0MiA9IHQxID0gMDtcbiAgfSxcbiAgICAgIGdldFZlbG9jaXR5ID0gZnVuY3Rpb24gZ2V0VmVsb2NpdHkobGF0ZXN0VmFsdWUpIHtcbiAgICB2YXIgdE9sZCA9IHQyLFxuICAgICAgICB2T2xkID0gdjIsXG4gICAgICAgIHQgPSBfZ2V0VGltZSgpO1xuXG4gICAgKGxhdGVzdFZhbHVlIHx8IGxhdGVzdFZhbHVlID09PSAwKSAmJiBsYXRlc3RWYWx1ZSAhPT0gdjEgJiYgdXBkYXRlKGxhdGVzdFZhbHVlKTtcbiAgICByZXR1cm4gdDEgPT09IHQyIHx8IHQgLSB0MiA+IGRyb3BUb1plcm9UaW1lID8gMCA6ICh2MSArICh1c2VEZWx0YSA/IHZPbGQgOiAtdk9sZCkpIC8gKCh1c2VEZWx0YSA/IHQgOiB0MSkgLSB0T2xkKSAqIDEwMDA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICByZXNldDogcmVzZXQsXG4gICAgZ2V0VmVsb2NpdHk6IGdldFZlbG9jaXR5XG4gIH07XG59LFxuICAgIF9nZXRFdmVudCA9IGZ1bmN0aW9uIF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCkge1xuICBwcmV2ZW50RGVmYXVsdCAmJiAhZS5fZ3NhcEFsbG93ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcbn0sXG4gICAgX2dldEFic29sdXRlTWF4ID0gZnVuY3Rpb24gX2dldEFic29sdXRlTWF4KGEpIHtcbiAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGEpLFxuICAgICAgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgYSk7XG4gIHJldHVybiBNYXRoLmFicyhtYXgpID49IE1hdGguYWJzKG1pbikgPyBtYXggOiBtaW47XG59LFxuICAgIF9zZXRTY3JvbGxUcmlnZ2VyID0gZnVuY3Rpb24gX3NldFNjcm9sbFRyaWdnZXIoKSB7XG4gIFNjcm9sbFRyaWdnZXIgPSBnc2FwLmNvcmUuZ2xvYmFscygpLlNjcm9sbFRyaWdnZXI7XG4gIFNjcm9sbFRyaWdnZXIgJiYgU2Nyb2xsVHJpZ2dlci5jb3JlICYmIF9pbnRlZ3JhdGUoKTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBnc2FwICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gICAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG4gICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcblxuICAgIF9jb250ZXh0ID0gZ3NhcC5jb3JlLmNvbnRleHQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBfcG9pbnRlclR5cGUgPSBcIm9ucG9pbnRlcmVudGVyXCIgaW4gX2JvZHkgPyBcInBvaW50ZXJcIiA6IFwibW91c2VcIjsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICBfaXNUb3VjaCA9IE9ic2VydmVyLmlzVG91Y2ggPSBfd2luLm1hdGNoTWVkaWEgJiYgX3dpbi5tYXRjaE1lZGlhKFwiKGhvdmVyOiBub25lKSwgKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlcyA/IDEgOiBcIm9udG91Y2hzdGFydFwiIGluIF93aW4gfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDAgPyAyIDogMDtcbiAgICBfZXZlbnRUeXBlcyA9IE9ic2VydmVyLmV2ZW50VHlwZXMgPSAoXCJvbnRvdWNoc3RhcnRcIiBpbiBfZG9jRWwgPyBcInRvdWNoc3RhcnQsdG91Y2htb3ZlLHRvdWNoY2FuY2VsLHRvdWNoZW5kXCIgOiAhKFwib25wb2ludGVyZG93blwiIGluIF9kb2NFbCkgPyBcIm1vdXNlZG93bixtb3VzZW1vdmUsbW91c2V1cCxtb3VzZXVwXCIgOiBcInBvaW50ZXJkb3duLHBvaW50ZXJtb3ZlLHBvaW50ZXJjYW5jZWwscG9pbnRlcnVwXCIpLnNwbGl0KFwiLFwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfc3RhcnR1cCA9IDA7XG4gICAgfSwgNTAwKTtcblxuICAgIF9zZXRTY3JvbGxUcmlnZ2VyKCk7XG5cbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG5cbiAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcbn07XG5cbl9ob3Jpem9udGFsLm9wID0gX3ZlcnRpY2FsO1xuX3Njcm9sbGVycy5jYWNoZSA9IDA7XG5leHBvcnQgdmFyIE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFycykge1xuICAgIHRoaXMuaW5pdCh2YXJzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKVwiKTtcbiAgICBTY3JvbGxUcmlnZ2VyIHx8IF9zZXRTY3JvbGxUcmlnZ2VyKCk7XG4gICAgdmFyIHRvbGVyYW5jZSA9IHZhcnMudG9sZXJhbmNlLFxuICAgICAgICBkcmFnTWluaW11bSA9IHZhcnMuZHJhZ01pbmltdW0sXG4gICAgICAgIHR5cGUgPSB2YXJzLnR5cGUsXG4gICAgICAgIHRhcmdldCA9IHZhcnMudGFyZ2V0LFxuICAgICAgICBsaW5lSGVpZ2h0ID0gdmFycy5saW5lSGVpZ2h0LFxuICAgICAgICBkZWJvdW5jZSA9IHZhcnMuZGVib3VuY2UsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdmFycy5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgb25TdG9wID0gdmFycy5vblN0b3AsXG4gICAgICAgIG9uU3RvcERlbGF5ID0gdmFycy5vblN0b3BEZWxheSxcbiAgICAgICAgaWdub3JlID0gdmFycy5pZ25vcmUsXG4gICAgICAgIHdoZWVsU3BlZWQgPSB2YXJzLndoZWVsU3BlZWQsXG4gICAgICAgIGV2ZW50ID0gdmFycy5ldmVudCxcbiAgICAgICAgb25EcmFnU3RhcnQgPSB2YXJzLm9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWdFbmQgPSB2YXJzLm9uRHJhZ0VuZCxcbiAgICAgICAgb25EcmFnID0gdmFycy5vbkRyYWcsXG4gICAgICAgIG9uUHJlc3MgPSB2YXJzLm9uUHJlc3MsXG4gICAgICAgIG9uUmVsZWFzZSA9IHZhcnMub25SZWxlYXNlLFxuICAgICAgICBvblJpZ2h0ID0gdmFycy5vblJpZ2h0LFxuICAgICAgICBvbkxlZnQgPSB2YXJzLm9uTGVmdCxcbiAgICAgICAgb25VcCA9IHZhcnMub25VcCxcbiAgICAgICAgb25Eb3duID0gdmFycy5vbkRvd24sXG4gICAgICAgIG9uQ2hhbmdlWCA9IHZhcnMub25DaGFuZ2VYLFxuICAgICAgICBvbkNoYW5nZVkgPSB2YXJzLm9uQ2hhbmdlWSxcbiAgICAgICAgb25DaGFuZ2UgPSB2YXJzLm9uQ2hhbmdlLFxuICAgICAgICBvblRvZ2dsZVggPSB2YXJzLm9uVG9nZ2xlWCxcbiAgICAgICAgb25Ub2dnbGVZID0gdmFycy5vblRvZ2dsZVksXG4gICAgICAgIG9uSG92ZXIgPSB2YXJzLm9uSG92ZXIsXG4gICAgICAgIG9uSG92ZXJFbmQgPSB2YXJzLm9uSG92ZXJFbmQsXG4gICAgICAgIG9uTW92ZSA9IHZhcnMub25Nb3ZlLFxuICAgICAgICBpZ25vcmVDaGVjayA9IHZhcnMuaWdub3JlQ2hlY2ssXG4gICAgICAgIGlzTm9ybWFsaXplciA9IHZhcnMuaXNOb3JtYWxpemVyLFxuICAgICAgICBvbkdlc3R1cmVTdGFydCA9IHZhcnMub25HZXN0dXJlU3RhcnQsXG4gICAgICAgIG9uR2VzdHVyZUVuZCA9IHZhcnMub25HZXN0dXJlRW5kLFxuICAgICAgICBvbldoZWVsID0gdmFycy5vbldoZWVsLFxuICAgICAgICBvbkVuYWJsZSA9IHZhcnMub25FbmFibGUsXG4gICAgICAgIG9uRGlzYWJsZSA9IHZhcnMub25EaXNhYmxlLFxuICAgICAgICBvbkNsaWNrID0gdmFycy5vbkNsaWNrLFxuICAgICAgICBzY3JvbGxTcGVlZCA9IHZhcnMuc2Nyb2xsU3BlZWQsXG4gICAgICAgIGNhcHR1cmUgPSB2YXJzLmNhcHR1cmUsXG4gICAgICAgIGFsbG93Q2xpY2tzID0gdmFycy5hbGxvd0NsaWNrcyxcbiAgICAgICAgbG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzLFxuICAgICAgICBvbkxvY2tBeGlzID0gdmFycy5vbkxvY2tBeGlzO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0ID0gX2dldFRhcmdldCh0YXJnZXQpIHx8IF9kb2NFbDtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIGlnbm9yZSAmJiAoaWdub3JlID0gZ3NhcC51dGlscy50b0FycmF5KGlnbm9yZSkpO1xuICAgIHRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCAxZS05O1xuICAgIGRyYWdNaW5pbXVtID0gZHJhZ01pbmltdW0gfHwgMDtcbiAgICB3aGVlbFNwZWVkID0gd2hlZWxTcGVlZCB8fCAxO1xuICAgIHNjcm9sbFNwZWVkID0gc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICB0eXBlID0gdHlwZSB8fCBcIndoZWVsLHRvdWNoLHBvaW50ZXJcIjtcbiAgICBkZWJvdW5jZSA9IGRlYm91bmNlICE9PSBmYWxzZTtcbiAgICBsaW5lSGVpZ2h0IHx8IChsaW5lSGVpZ2h0ID0gcGFyc2VGbG9hdChfd2luLmdldENvbXB1dGVkU3R5bGUoX2JvZHkpLmxpbmVIZWlnaHQpIHx8IDIyKTsgLy8gbm90ZTogYnJvd3NlciBtYXkgcmVwb3J0IFwibm9ybWFsXCIsIHNvIGRlZmF1bHQgdG8gMjIuXG5cbiAgICB2YXIgaWQsXG4gICAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLFxuICAgICAgICBkcmFnZ2VkLFxuICAgICAgICBtb3ZlZCxcbiAgICAgICAgd2hlZWxlZCxcbiAgICAgICAgbG9ja2VkLFxuICAgICAgICBheGlzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgcHJldkRlbHRhWCA9IDAsXG4gICAgICAgIHByZXZEZWx0YVkgPSAwLFxuICAgICAgICBwYXNzaXZlID0gdmFycy5wYXNzaXZlIHx8ICFwcmV2ZW50RGVmYXVsdCAmJiB2YXJzLnBhc3NpdmUgIT09IGZhbHNlLFxuICAgICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxuICAgICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYKCksXG4gICAgICAgIHNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpLFxuICAgICAgICBsaW1pdFRvVG91Y2ggPSB+dHlwZS5pbmRleE9mKFwidG91Y2hcIikgJiYgIX50eXBlLmluZGV4T2YoXCJwb2ludGVyXCIpICYmIF9ldmVudFR5cGVzWzBdID09PSBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgIC8vIGZvciBkZXZpY2VzIHRoYXQgYWNjb21tb2RhdGUgbW91c2UgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMsIHdlIG5lZWQgdG8gZGlzdGluZ3Vpc2guXG4gICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHRhcmdldCksXG4gICAgICAgIG93bmVyRG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgICAgZGVsdGFYID0gWzAsIDAsIDBdLFxuICAgICAgICAvLyB3aGVlbCwgc2Nyb2xsLCBwb2ludGVyL3RvdWNoXG4gICAgZGVsdGFZID0gWzAsIDAsIDBdLFxuICAgICAgICBvbkNsaWNrVGltZSA9IDAsXG4gICAgICAgIGNsaWNrQ2FwdHVyZSA9IGZ1bmN0aW9uIGNsaWNrQ2FwdHVyZSgpIHtcbiAgICAgIHJldHVybiBvbkNsaWNrVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAgICAgX2lnbm9yZUNoZWNrID0gZnVuY3Rpb24gX2lnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpIHtcbiAgICAgIHJldHVybiAoc2VsZi5ldmVudCA9IGUpICYmIGlnbm9yZSAmJiBfaXNXaXRoaW4oZS50YXJnZXQsIGlnbm9yZSkgfHwgaXNQb2ludGVyT3JUb3VjaCAmJiBsaW1pdFRvVG91Y2ggJiYgZS5wb2ludGVyVHlwZSAhPT0gXCJ0b3VjaFwiIHx8IGlnbm9yZUNoZWNrICYmIGlnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpO1xuICAgIH0sXG4gICAgICAgIG9uU3RvcEZ1bmMgPSBmdW5jdGlvbiBvblN0b3BGdW5jKCkge1xuICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgb25TdG9wRGVsYXllZENhbGwucGF1c2UoKTtcbiAgICAgIG9uU3RvcCAmJiBvblN0b3Aoc2VsZik7XG4gICAgfSxcbiAgICAgICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIGR4ID0gc2VsZi5kZWx0YVggPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFYKSxcbiAgICAgICAgICBkeSA9IHNlbGYuZGVsdGFZID0gX2dldEFic29sdXRlTWF4KGRlbHRhWSksXG4gICAgICAgICAgY2hhbmdlZFggPSBNYXRoLmFicyhkeCkgPj0gdG9sZXJhbmNlLFxuICAgICAgICAgIGNoYW5nZWRZID0gTWF0aC5hYnMoZHkpID49IHRvbGVyYW5jZTtcblxuICAgICAgb25DaGFuZ2UgJiYgKGNoYW5nZWRYIHx8IGNoYW5nZWRZKSAmJiBvbkNoYW5nZShzZWxmLCBkeCwgZHksIGRlbHRhWCwgZGVsdGFZKTsgLy8gaW4gU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwoKSwgd2UgbmVlZCB0byBrbm93IGlmIGl0IHdhcyB0b3VjaC9wb2ludGVyIHNvIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBkZWx0YVgvZGVsdGFZIEFycmF5cyBiZWZvcmUgd2UgY2xlYXIgdGhlbSBvdXQuXG5cbiAgICAgIGlmIChjaGFuZ2VkWCkge1xuICAgICAgICBvblJpZ2h0ICYmIHNlbGYuZGVsdGFYID4gMCAmJiBvblJpZ2h0KHNlbGYpO1xuICAgICAgICBvbkxlZnQgJiYgc2VsZi5kZWx0YVggPCAwICYmIG9uTGVmdChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VYICYmIG9uQ2hhbmdlWChzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVYICYmIHNlbGYuZGVsdGFYIDwgMCAhPT0gcHJldkRlbHRhWCA8IDAgJiYgb25Ub2dnbGVYKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFYID0gc2VsZi5kZWx0YVg7XG4gICAgICAgIGRlbHRhWFswXSA9IGRlbHRhWFsxXSA9IGRlbHRhWFsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkWSkge1xuICAgICAgICBvbkRvd24gJiYgc2VsZi5kZWx0YVkgPiAwICYmIG9uRG93bihzZWxmKTtcbiAgICAgICAgb25VcCAmJiBzZWxmLmRlbHRhWSA8IDAgJiYgb25VcChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VZICYmIG9uQ2hhbmdlWShzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVZICYmIHNlbGYuZGVsdGFZIDwgMCAhPT0gcHJldkRlbHRhWSA8IDAgJiYgb25Ub2dnbGVZKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFZID0gc2VsZi5kZWx0YVk7XG4gICAgICAgIGRlbHRhWVswXSA9IGRlbHRhWVsxXSA9IGRlbHRhWVsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCB8fCBkcmFnZ2VkKSB7XG4gICAgICAgIG9uTW92ZSAmJiBvbk1vdmUoc2VsZik7XG5cbiAgICAgICAgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgICBvbkRyYWdTdGFydCAmJiBkcmFnZ2VkID09PSAxICYmIG9uRHJhZ1N0YXJ0KHNlbGYpO1xuICAgICAgICAgIG9uRHJhZyAmJiBvbkRyYWcoc2VsZik7XG4gICAgICAgICAgZHJhZ2dlZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtb3ZlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsb2NrZWQgJiYgIShsb2NrZWQgPSBmYWxzZSkgJiYgb25Mb2NrQXhpcyAmJiBvbkxvY2tBeGlzKHNlbGYpO1xuXG4gICAgICBpZiAod2hlZWxlZCkge1xuICAgICAgICBvbldoZWVsKHNlbGYpO1xuICAgICAgICB3aGVlbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlkID0gMDtcbiAgICB9LFxuICAgICAgICBvbkRlbHRhID0gZnVuY3Rpb24gb25EZWx0YSh4LCB5LCBpbmRleCkge1xuICAgICAgZGVsdGFYW2luZGV4XSArPSB4O1xuICAgICAgZGVsdGFZW2luZGV4XSArPSB5O1xuXG4gICAgICBzZWxmLl92eC51cGRhdGUoeCk7XG5cbiAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5KTtcblxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcbiAgICB9LFxuICAgICAgICBvblRvdWNoT3JQb2ludGVyRGVsdGEgPSBmdW5jdGlvbiBvblRvdWNoT3JQb2ludGVyRGVsdGEoeCwgeSkge1xuICAgICAgaWYgKGxvY2tBeGlzICYmICFheGlzKSB7XG4gICAgICAgIHNlbGYuYXhpcyA9IGF4aXMgPSBNYXRoLmFicyh4KSA+IE1hdGguYWJzKHkpID8gXCJ4XCIgOiBcInlcIjtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgIT09IFwieVwiKSB7XG4gICAgICAgIGRlbHRhWFsyXSArPSB4O1xuXG4gICAgICAgIHNlbGYuX3Z4LnVwZGF0ZSh4LCB0cnVlKTsgLy8gdXBkYXRlIHRoZSB2ZWxvY2l0eSBhcyBmcmVxdWVudGx5IGFzIHBvc3NpYmxlIGluc3RlYWQgb2YgaW4gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBzbyB0aGF0IHZlcnkgcXVpY2sgdG91Y2gtc2Nyb2xscyAoZmxpY2tzKSBmZWVsIG5hdHVyYWwuIElmIGl0J3MgdGhlIG1vdXNlL3RvdWNoL3BvaW50ZXIsIGZvcmNlIGl0IHNvIHRoYXQgd2UgZ2V0IHNuYXBweS9hY2N1cmF0ZSBtb21lbnR1bSBzY3JvbGwuXG5cbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgIT09IFwieFwiKSB7XG4gICAgICAgIGRlbHRhWVsyXSArPSB5O1xuXG4gICAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcbiAgICB9LFxuICAgICAgICBfb25EcmFnID0gZnVuY3Rpb24gX29uRHJhZyhlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgIGR4ID0geCAtIHNlbGYueCxcbiAgICAgICAgICBkeSA9IHkgLSBzZWxmLnksXG4gICAgICAgICAgaXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgIHNlbGYueCA9IHg7XG4gICAgICBzZWxmLnkgPSB5O1xuXG4gICAgICBpZiAoaXNEcmFnZ2luZyB8fCAoZHggfHwgZHkpICYmIChNYXRoLmFicyhzZWxmLnN0YXJ0WCAtIHgpID49IGRyYWdNaW5pbXVtIHx8IE1hdGguYWJzKHNlbGYuc3RhcnRZIC0geSkgPj0gZHJhZ01pbmltdW0pKSB7XG4gICAgICAgIGRyYWdnZWQgfHwgKGRyYWdnZWQgPSBpc0RyYWdnaW5nID8gMiA6IDEpOyAvLyBkcmFnZ2VkOiAwID0gbm90IGRyYWdnaW5nLCAxID0gZmlyc3QgZHJhZywgMiA9IG5vcm1hbCBkcmFnXG5cbiAgICAgICAgaXNEcmFnZ2luZyB8fCAoc2VsZi5pc0RyYWdnaW5nID0gdHJ1ZSk7XG4gICAgICAgIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIF9vblByZXNzID0gc2VsZi5vblByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkgfHwgZSAmJiBlLmJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYXhpcyA9IGF4aXMgPSBudWxsO1xuICAgICAgb25TdG9wRGVsYXllZENhbGwucGF1c2UoKTtcbiAgICAgIHNlbGYuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgIGUgPSBfZ2V0RXZlbnQoZSk7IC8vIG5vdGU6IG1heSBuZWVkIHRvIHByZXZlbnREZWZhdWx0KD8pIFdvbid0IHNpZGUtc2Nyb2xsIG9uIGlPUyBTYWZhcmkgaWYgd2UgZG8sIHRob3VnaC5cblxuICAgICAgcHJldkRlbHRhWCA9IHByZXZEZWx0YVkgPSAwO1xuICAgICAgc2VsZi5zdGFydFggPSBzZWxmLnggPSBlLmNsaWVudFg7XG4gICAgICBzZWxmLnN0YXJ0WSA9IHNlbGYueSA9IGUuY2xpZW50WTtcblxuICAgICAgc2VsZi5fdngucmVzZXQoKTsgLy8gb3RoZXJ3aXNlIHRoZSB0MiBtYXkgYmUgc3RhbGUgaWYgdGhlIHVzZXIgdG91Y2hlcyBhbmQgZmxpY2tzIHN1cGVyIGZhc3QgYW5kIHJlbGVhc2VzIGluIGxlc3MgdGhhbiAyIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0aWNrcywgY2F1c2luZyB2ZWxvY2l0eSB0byBiZSAwLlxuXG5cbiAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgIF9hZGRMaXN0ZW5lcihpc05vcm1hbGl6ZXIgPyB0YXJnZXQgOiBvd25lckRvYywgX2V2ZW50VHlwZXNbMV0sIF9vbkRyYWcsIHBhc3NpdmUsIHRydWUpO1xuXG4gICAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcbiAgICAgIG9uUHJlc3MgJiYgb25QcmVzcyhzZWxmKTtcbiAgICB9LFxuICAgICAgICBfb25SZWxlYXNlID0gc2VsZi5vblJlbGVhc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc05vcm1hbGl6ZXIgPyB0YXJnZXQgOiBvd25lckRvYywgX2V2ZW50VHlwZXNbMV0sIF9vbkRyYWcsIHRydWUpO1xuXG4gICAgICB2YXIgaXNUcmFja2luZ0RyYWcgPSAhaXNOYU4oc2VsZi55IC0gc2VsZi5zdGFydFkpLFxuICAgICAgICAgIHdhc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nLFxuICAgICAgICAgIGlzRHJhZ05vdENsaWNrID0gd2FzRHJhZ2dpbmcgJiYgKE1hdGguYWJzKHNlbGYueCAtIHNlbGYuc3RhcnRYKSA+IDMgfHwgTWF0aC5hYnMoc2VsZi55IC0gc2VsZi5zdGFydFkpID4gMyksXG4gICAgICAgICAgLy8gc29tZSB0b3VjaCBkZXZpY2VzIG5lZWQgc29tZSB3aWdnbGUgcm9vbSBpbiB0ZXJtcyBvZiBzZW5zaW5nIGNsaWNrcyAtIHRoZSBmaW5nZXIgbWF5IG1vdmUgYSBmZXcgcGl4ZWxzLlxuICAgICAgZXZlbnREYXRhID0gX2dldEV2ZW50KGUpO1xuXG4gICAgICBpZiAoIWlzRHJhZ05vdENsaWNrICYmIGlzVHJhY2tpbmdEcmFnKSB7XG4gICAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7XG5cbiAgICAgICAgc2VsZi5fdnkucmVzZXQoKTsgLy9pZiAocHJldmVudERlZmF1bHQgJiYgYWxsb3dDbGlja3MgJiYgc2VsZi5pc1ByZXNzZWQpIHsgLy8gY2hlY2sgaXNQcmVzc2VkIGJlY2F1c2UgaW4gYSByYXJlIGVkZ2UgY2FzZSwgdGhlIGlucHV0T2JzZXJ2ZXIgaW4gU2Nyb2xsVHJpZ2dlciBtYXkgc3RvcFByb3BhZ2F0aW9uKCkgb24gdGhlIHByZXNzL2RyYWcsIHNvIHRoZSBvblJlbGVhc2UgbWF5IGdldCBmaXJlZCB3aXRob3V0IHRoZSBvblByZXNzL29uRHJhZyBldmVyIGdldHRpbmcgY2FsbGVkLCB0aHVzIGl0IGNvdWxkIHRyaWdnZXIgYSBjbGljayB0byBvY2N1ciBvbiBhIGxpbmsgYWZ0ZXIgc2Nyb2xsLWRyYWdnaW5nIGl0LlxuXG5cbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ICYmIGFsbG93Q2xpY2tzKSB7XG4gICAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjA4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxuICAgICAgICAgICAgaWYgKF9nZXRUaW1lKCkgLSBvbkNsaWNrVGltZSA+IDMwMCAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ludGhldGljRXZlbnQgPSBvd25lckRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V2ZW50LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgX3dpbiwgMSwgZXZlbnREYXRhLnNjcmVlblgsIGV2ZW50RGF0YS5zY3JlZW5ZLCBldmVudERhdGEuY2xpZW50WCwgZXZlbnREYXRhLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHN5bnRoZXRpY0V2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgb25TdG9wICYmIHdhc0RyYWdnaW5nICYmICFpc05vcm1hbGl6ZXIgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIGRyYWdnZWQgJiYgdXBkYXRlKCk7IC8vIGluIGNhc2UgZGVib3VuY2luZywgd2UgZG9uJ3Qgd2FudCBvbkRyYWcgdG8gZmlyZSBBRlRFUiBvbkRyYWdFbmQoKS5cblxuICAgICAgb25EcmFnRW5kICYmIHdhc0RyYWdnaW5nICYmIG9uRHJhZ0VuZChzZWxmKTtcbiAgICAgIG9uUmVsZWFzZSAmJiBvblJlbGVhc2Uoc2VsZiwgaXNEcmFnTm90Q2xpY2spO1xuICAgIH0sXG4gICAgICAgIF9vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIF9vbkdlc3R1cmVTdGFydChlKSB7XG4gICAgICByZXR1cm4gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxICYmIChzZWxmLmlzR2VzdHVyaW5nID0gdHJ1ZSkgJiYgb25HZXN0dXJlU3RhcnQoZSwgc2VsZi5pc0RyYWdnaW5nKTtcbiAgICB9LFxuICAgICAgICBfb25HZXN0dXJlRW5kID0gZnVuY3Rpb24gX29uR2VzdHVyZUVuZCgpIHtcbiAgICAgIHJldHVybiAoc2VsZi5pc0dlc3R1cmluZyA9IGZhbHNlKSB8fCBvbkdlc3R1cmVFbmQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgb25TY3JvbGwgPSBmdW5jdGlvbiBvblNjcm9sbChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzY3JvbGxGdW5jWCgpLFxuICAgICAgICAgIHkgPSBzY3JvbGxGdW5jWSgpO1xuICAgICAgb25EZWx0YSgoeCAtIHNjcm9sbFgpICogc2Nyb2xsU3BlZWQsICh5IC0gc2Nyb2xsWSkgKiBzY3JvbGxTcGVlZCwgMSk7XG4gICAgICBzY3JvbGxYID0geDtcbiAgICAgIHNjcm9sbFkgPSB5O1xuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgX29uV2hlZWwgPSBmdW5jdGlvbiBfb25XaGVlbChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICBvbldoZWVsICYmICh3aGVlbGVkID0gdHJ1ZSk7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IChlLmRlbHRhTW9kZSA9PT0gMSA/IGxpbmVIZWlnaHQgOiBlLmRlbHRhTW9kZSA9PT0gMiA/IF93aW4uaW5uZXJIZWlnaHQgOiAxKSAqIHdoZWVsU3BlZWQ7XG4gICAgICBvbkRlbHRhKGUuZGVsdGFYICogbXVsdGlwbGllciwgZS5kZWx0YVkgKiBtdWx0aXBsaWVyLCAwKTtcbiAgICAgIG9uU3RvcCAmJiAhaXNOb3JtYWxpemVyICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgX29uTW92ZSA9IGZ1bmN0aW9uIF9vbk1vdmUoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgZHggPSB4IC0gc2VsZi54LFxuICAgICAgICAgIGR5ID0geSAtIHNlbGYueTtcbiAgICAgIHNlbGYueCA9IHg7XG4gICAgICBzZWxmLnkgPSB5O1xuICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAoZHggfHwgZHkpICYmIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyID0gZnVuY3Rpb24gX29uSG92ZXIoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyRW5kID0gZnVuY3Rpb24gX29uSG92ZXJFbmQoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyRW5kKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkNsaWNrID0gZnVuY3Rpb24gX29uQ2xpY2soZSkge1xuICAgICAgcmV0dXJuIF9pZ25vcmVDaGVjayhlKSB8fCBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpICYmIG9uQ2xpY2soc2VsZik7XG4gICAgfTtcblxuICAgIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGMgPSBnc2FwLmRlbGF5ZWRDYWxsKG9uU3RvcERlbGF5IHx8IDAuMjUsIG9uU3RvcEZ1bmMpLnBhdXNlKCk7XG4gICAgc2VsZi5kZWx0YVggPSBzZWxmLmRlbHRhWSA9IDA7XG4gICAgc2VsZi5fdnggPSBfZ2V0VmVsb2NpdHlQcm9wKDAsIDUwLCB0cnVlKTtcbiAgICBzZWxmLl92eSA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYO1xuICAgIHNlbGYuc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZO1xuICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgX2NvbnRleHQodGhpcyk7XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgdHlwZS5pbmRleE9mKFwic2Nyb2xsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIHBhc3NpdmUsIGNhcHR1cmUpO1xuICAgICAgICB0eXBlLmluZGV4T2YoXCJ3aGVlbFwiKSA+PSAwICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwid2hlZWxcIiwgX29uV2hlZWwsIHBhc3NpdmUsIGNhcHR1cmUpO1xuXG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+PSAwICYmIF9pc1RvdWNoIHx8IHR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPj0gMCkge1xuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgcGFzc2l2ZSwgY2FwdHVyZSk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgICAgYWxsb3dDbGlja3MgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG9uQ2xpY2sgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBfb25DbGljayk7XG4gICAgICAgICAgb25HZXN0dXJlU3RhcnQgJiYgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVzdGFydFwiLCBfb25HZXN0dXJlU3RhcnQpO1xuICAgICAgICAgIG9uR2VzdHVyZUVuZCAmJiBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZWVuZFwiLCBfb25HZXN0dXJlRW5kKTtcbiAgICAgICAgICBvbkhvdmVyICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwiZW50ZXJcIiwgX29uSG92ZXIpO1xuICAgICAgICAgIG9uSG92ZXJFbmQgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XG4gICAgICAgICAgb25Nb3ZlICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gbW92ZWQgPSBkcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICAgIHNjcm9sbFggPSBzY3JvbGxGdW5jWCgpO1xuICAgICAgICBzY3JvbGxZID0gc2Nyb2xsRnVuY1koKTtcbiAgICAgICAgZSAmJiBlLnR5cGUgJiYgX29uUHJlc3MoZSk7XG4gICAgICAgIG9uRW5hYmxlICYmIG9uRW5hYmxlKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgc2VsZi5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBfb25TY3JvbGwgbGlzdGVuZXIgaWYgdGhlcmUgYXJlbid0IGFueSBvdGhlcnMgdGhhdCByZWx5IG9uIHRoZSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBfb2JzZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvICE9PSBzZWxmICYmIF9pc1ZpZXdwb3J0KG8udGFyZ2V0KTtcbiAgICAgICAgfSkubGVuZ3RoIHx8IF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcIndoZWVsXCIsIF9vbldoZWVsLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfZXZlbnRUeXBlc1swXSwgX29uUHJlc3MsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbMl0sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgY2xpY2tDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIF9vbkNsaWNrKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZXN0YXJ0XCIsIF9vbkdlc3R1cmVTdGFydCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVlbmRcIiwgX29uR2VzdHVyZUVuZCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJlbnRlclwiLCBfb25Ib3Zlcik7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJtb3ZlXCIsIF9vbk1vdmUpO1xuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gc2VsZi5pc1ByZXNzZWQgPSBzZWxmLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgb25EaXNhYmxlICYmIG9uRGlzYWJsZShzZWxmKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmRpc2FibGUoKTtcblxuICAgICAgdmFyIGkgPSBfb2JzZXJ2ZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfb2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIF9ub3JtYWxpemVyID09PSBzZWxmICYmIChfbm9ybWFsaXplciA9IDApO1xuICAgIH07XG5cbiAgICBfb2JzZXJ2ZXJzLnB1c2goc2VsZik7XG5cbiAgICBpc05vcm1hbGl6ZXIgJiYgX2lzVmlld3BvcnQodGFyZ2V0KSAmJiAoX25vcm1hbGl6ZXIgPSBzZWxmKTtcbiAgICBzZWxmLmVuYWJsZShldmVudCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmVyLCBbe1xuICAgIGtleTogXCJ2ZWxvY2l0eVhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eC5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZWxvY2l0eVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eS5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcbk9ic2VydmVyLnZlcnNpb24gPSBcIjMuMTQuMlwiO1xuXG5PYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuT2JzZXJ2ZXIucmVnaXN0ZXIgPSBfaW5pdENvcmU7XG5cbk9ic2VydmVyLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuc2xpY2UoKTtcbn07XG5cbk9ic2VydmVyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8udmFycy5pZCA9PT0gaWQ7XG4gIH0pWzBdO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKTtcbmV4cG9ydCB7IE9ic2VydmVyIGFzIGRlZmF1bHQsIF9pc1ZpZXdwb3J0LCBfc2Nyb2xsZXJzLCBfZ2V0U2Nyb2xsRnVuYywgX2dldFByb3h5UHJvcCwgX3Byb3hpZXMsIF9nZXRWZWxvY2l0eVByb3AsIF92ZXJ0aWNhbCwgX2hvcml6b250YWwsIF9nZXRUYXJnZXQgfTsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfY2xhbXAiLCJfd2luIiwiX2RvYyIsIl9kb2NFbCIsIl9ib2R5IiwiX2lzVG91Y2giLCJfcG9pbnRlclR5cGUiLCJTY3JvbGxUcmlnZ2VyIiwiX3Jvb3QiLCJfbm9ybWFsaXplciIsIl9ldmVudFR5cGVzIiwiX2NvbnRleHQiLCJfZ2V0R1NBUCIsIndpbmRvdyIsInJlZ2lzdGVyUGx1Z2luIiwiX3N0YXJ0dXAiLCJfb2JzZXJ2ZXJzIiwiX3Njcm9sbGVycyIsIl9wcm94aWVzIiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiX2JyaWRnZSIsIm5hbWUiLCJ2YWx1ZSIsIl9pbnRlZ3JhdGUiLCJjb3JlIiwiZGF0YSIsImJyaWRnZSIsInNjcm9sbGVycyIsInByb3hpZXMiLCJwdXNoIiwiYXBwbHkiLCJfZ2V0UHJveHlQcm9wIiwiZWxlbWVudCIsInByb3BlcnR5IiwiaW5kZXhPZiIsIl9pc1ZpZXdwb3J0IiwiZWwiLCJfYWRkTGlzdGVuZXIiLCJ0eXBlIiwiZnVuYyIsInBhc3NpdmUiLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9yZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc2Nyb2xsTGVmdCIsIl9zY3JvbGxUb3AiLCJfb25TY3JvbGwiLCJpc1ByZXNzZWQiLCJjYWNoZSIsIl9zY3JvbGxDYWNoZUZ1bmMiLCJmIiwiZG9Ob3RDYWNoZSIsImNhY2hpbmdGdW5jIiwiaGlzdG9yeSIsInNjcm9sbFJlc3RvcmF0aW9uIiwiaXNOb3JtYWxpemluZyIsInYiLCJNYXRoIiwicm91bmQiLCJpT1MiLCJjYWNoZUlEIiwib2Zmc2V0IiwiX2hvcml6b250YWwiLCJzIiwicCIsInAyIiwib3MiLCJvczIiLCJkIiwiZDIiLCJhIiwic2MiLCJhcmd1bWVudHMiLCJzY3JvbGxUbyIsIl92ZXJ0aWNhbCIsInBhZ2VYT2Zmc2V0Iiwib3AiLCJwYWdlWU9mZnNldCIsIl9nZXRUYXJnZXQiLCJ0Iiwic2VsZiIsIl9jdHgiLCJzZWxlY3RvciIsInV0aWxzIiwidG9BcnJheSIsImNvbmZpZyIsIm51bGxUYXJnZXRXYXJuIiwiY29uc29sZSIsIndhcm4iLCJfaXNXaXRoaW4iLCJsaXN0IiwiY29udGFpbnMiLCJfZ2V0U2Nyb2xsRnVuYyIsIl9yZWYiLCJzY3JvbGxpbmdFbGVtZW50IiwicHJldiIsInNtb290aCIsImdldFByb3BlcnR5IiwiX2dldFZlbG9jaXR5UHJvcCIsIm1pblRpbWVSZWZyZXNoIiwidXNlRGVsdGEiLCJ2MSIsInYyIiwidDEiLCJ0MiIsIm1pbiIsImRyb3BUb1plcm9UaW1lIiwibWF4IiwidXBkYXRlIiwiZm9yY2UiLCJyZXNldCIsImdldFZlbG9jaXR5IiwibGF0ZXN0VmFsdWUiLCJ0T2xkIiwidk9sZCIsIl9nZXRFdmVudCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsIl9nc2FwQWxsb3ciLCJjaGFuZ2VkVG91Y2hlcyIsIl9nZXRBYnNvbHV0ZU1heCIsImFicyIsIl9zZXRTY3JvbGxUcmlnZ2VyIiwiZ2xvYmFscyIsIl9pbml0Q29yZSIsImRvY3VtZW50IiwiYm9keSIsImRvY3VtZW50RWxlbWVudCIsImNsYW1wIiwiY29udGV4dCIsIk9ic2VydmVyIiwiaXNUb3VjaCIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiZXZlbnRUeXBlcyIsInNwbGl0Iiwic2V0VGltZW91dCIsInZhcnMiLCJpbml0IiwiX3Byb3RvIiwidG9sZXJhbmNlIiwiZHJhZ01pbmltdW0iLCJsaW5lSGVpZ2h0IiwiZGVib3VuY2UiLCJvblN0b3AiLCJvblN0b3BEZWxheSIsImlnbm9yZSIsIndoZWVsU3BlZWQiLCJldmVudCIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnRW5kIiwib25EcmFnIiwib25QcmVzcyIsIm9uUmVsZWFzZSIsIm9uUmlnaHQiLCJvbkxlZnQiLCJvblVwIiwib25Eb3duIiwib25DaGFuZ2VYIiwib25DaGFuZ2VZIiwib25DaGFuZ2UiLCJvblRvZ2dsZVgiLCJvblRvZ2dsZVkiLCJvbkhvdmVyIiwib25Ib3ZlckVuZCIsIm9uTW92ZSIsImlnbm9yZUNoZWNrIiwiaXNOb3JtYWxpemVyIiwib25HZXN0dXJlU3RhcnQiLCJvbkdlc3R1cmVFbmQiLCJvbldoZWVsIiwib25FbmFibGUiLCJvbkRpc2FibGUiLCJvbkNsaWNrIiwic2Nyb2xsU3BlZWQiLCJhbGxvd0NsaWNrcyIsImxvY2tBeGlzIiwib25Mb2NrQXhpcyIsInBhcnNlRmxvYXQiLCJnZXRDb21wdXRlZFN0eWxlIiwiaWQiLCJvblN0b3BEZWxheWVkQ2FsbCIsImRyYWdnZWQiLCJtb3ZlZCIsIndoZWVsZWQiLCJsb2NrZWQiLCJheGlzIiwicHJldkRlbHRhWCIsInByZXZEZWx0YVkiLCJzY3JvbGxGdW5jWCIsInNjcm9sbEZ1bmNZIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJsaW1pdFRvVG91Y2giLCJpc1ZpZXdwb3J0Iiwib3duZXJEb2MiLCJvd25lckRvY3VtZW50IiwiZGVsdGFYIiwiZGVsdGFZIiwib25DbGlja1RpbWUiLCJjbGlja0NhcHR1cmUiLCJfaWdub3JlQ2hlY2siLCJpc1BvaW50ZXJPclRvdWNoIiwicG9pbnRlclR5cGUiLCJvblN0b3BGdW5jIiwiX3Z4IiwiX3Z5IiwicGF1c2UiLCJkeCIsImR5IiwiY2hhbmdlZFgiLCJjaGFuZ2VkWSIsIm9uRGVsdGEiLCJ4IiwieSIsImluZGV4IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25Ub3VjaE9yUG9pbnRlckRlbHRhIiwiX29uRHJhZyIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNEcmFnZ2luZyIsInN0YXJ0WCIsInN0YXJ0WSIsIl9vblByZXNzIiwiYnV0dG9uIiwiX29uUmVsZWFzZSIsImlzVHJhY2tpbmdEcmFnIiwiaXNOYU4iLCJ3YXNEcmFnZ2luZyIsImlzRHJhZ05vdENsaWNrIiwiZXZlbnREYXRhIiwiZGVsYXllZENhbGwiLCJkZWZhdWx0UHJldmVudGVkIiwiY2xpY2siLCJjcmVhdGVFdmVudCIsInN5bnRoZXRpY0V2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImRpc3BhdGNoRXZlbnQiLCJpc0dlc3R1cmluZyIsInJlc3RhcnQiLCJfb25HZXN0dXJlU3RhcnQiLCJ0b3VjaGVzIiwiX29uR2VzdHVyZUVuZCIsIm9uU2Nyb2xsIiwiX29uV2hlZWwiLCJtdWx0aXBsaWVyIiwiZGVsdGFNb2RlIiwiaW5uZXJIZWlnaHQiLCJfb25Nb3ZlIiwiX29uSG92ZXIiLCJfb25Ib3ZlckVuZCIsIl9vbkNsaWNrIiwiX2RjIiwiZW5hYmxlIiwiaXNFbmFibGVkIiwiZGlzYWJsZSIsImZpbHRlciIsIm8iLCJraWxsIiwicmV2ZXJ0Iiwic3BsaWNlIiwiZ2V0IiwidmVyc2lvbiIsImNyZWF0ZSIsInJlZ2lzdGVyIiwiZ2V0QWxsIiwic2xpY2UiLCJnZXRCeUlkIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/Observer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/ScrollTrigger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/ScrollTrigger.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: function() { return /* binding */ ScrollTrigger; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollTrigger; }\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/Observer.js\");\n/*!\n * ScrollTrigger 3.14.2\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _div100vh, _100vh, _isReverted, _clampingMax, _limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1, _getTime = Date.now, _time1 = _getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function _parseClamp(value, type, self) {\n    var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\n    self[\"_\" + type + \"Clamp\"] = clamp;\n    return clamp ? value.substr(6, value.length - 7) : value;\n}, _keepClamp = function _keepClamp(value, clamp) {\n    return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\n}, _rafBugFix = function _rafBugFix() {\n    return _enabled && requestAnimationFrame(_rafBugFix);\n}, // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.\n_pointerDownHandler = function _pointerDownHandler() {\n    return _pointerIsDown = 1;\n}, _pointerUpHandler = function _pointerUpHandler() {\n    return _pointerIsDown = 0;\n}, _passThrough = function _passThrough(v) {\n    return v;\n}, _round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _windowExists = function _windowExists() {\n    return \"object\" !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isViewport = function _isViewport(e) {\n    return !!~_root.indexOf(e);\n}, _getViewportDimension = function _getViewportDimension(dimensionProperty) {\n    return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\n}, _getBoundsFunc = function _getBoundsFunc(element) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function() {\n        _winOffsets.width = _win.innerWidth;\n        _winOffsets.height = _100vh;\n        return _winOffsets;\n    } : function() {\n        return _getBounds(element);\n    });\n}, _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n    var d = _ref.d, d2 = _ref.d2, a = _ref.a;\n    return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function() {\n        return a()[d];\n    } : function() {\n        return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\n    };\n}, _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n    return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function() {\n        return _winOffsets;\n    };\n}, _maxScroll = function _maxScroll(element, _ref2) {\n    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;\n    return Math.max(0, (s = \"scroll\" + d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\n}, _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n    for(var i = 0; i < _autoRefresh.length; i += 3){\n        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n    }\n}, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _endAnimation = function _endAnimation(animation, reversed, pause) {\n    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n}, _callback = function _callback(self, func) {\n    if (self.enabled) {\n        var result = self._ctx ? self._ctx.add(function() {\n            return func(self);\n        }) : func(self);\n        result && result.totalTime && (self.callbackAnimation = result);\n    }\n}, _abs = Math.abs, _left = \"left\", _top = \"top\", _right = \"right\", _bottom = \"bottom\", _width = \"width\", _height = \"height\", _Right = \"Right\", _Left = \"Left\", _Top = \"Top\", _Bottom = \"Bottom\", _padding = \"padding\", _margin = \"margin\", _Width = \"Width\", _Height = \"Height\", _px = \"px\", _getComputedStyle = function _getComputedStyle(element) {\n    return _win.getComputedStyle(element);\n}, _makePositionable = function _makePositionable(element) {\n    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n    var position = _getComputedStyle(element).position;\n    element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _getBounds = function _getBounds(element, withoutTransforms) {\n    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n        x: 0,\n        y: 0,\n        xPercent: 0,\n        yPercent: 0,\n        rotation: 0,\n        rotationX: 0,\n        rotationY: 0,\n        scale: 1,\n        skewX: 0,\n        skewY: 0\n    }).progress(1), bounds = element.getBoundingClientRect();\n    tween && tween.progress(0).kill();\n    return bounds;\n}, _getSize = function _getSize(element, _ref3) {\n    var d2 = _ref3.d2;\n    return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n}, _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n    var a = [], labels = timeline.labels, duration = timeline.duration(), p;\n    for(p in labels){\n        a.push(labels[p] / duration);\n    }\n    return a;\n}, _getClosestLabel = function _getClosestLabel(animation) {\n    return function(value) {\n        return gsap.utils.snap(_getLabelRatioArray(animation), value);\n    };\n}, _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n    var snap = gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a, b) {\n        return a - b;\n    });\n    return a ? function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var i;\n        if (!direction) {\n            return snap(value);\n        }\n        if (direction > 0) {\n            value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n            for(i = 0; i < a.length; i++){\n                if (a[i] >= value) {\n                    return a[i];\n                }\n            }\n            return a[i - 1];\n        } else {\n            i = a.length;\n            value += threshold;\n            while(i--){\n                if (a[i] <= value) {\n                    return a[i];\n                }\n            }\n        }\n        return a[0];\n    } : function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var snapped = snap(value);\n        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n    };\n}, _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n    return function(value, st) {\n        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n    };\n}, _multiListener = function _multiListener(func, element, types, callback) {\n    return types.split(\",\").forEach(function(type) {\n        return func(element, type, callback);\n    });\n}, _addListener = function _addListener(element, type, func, nonPassive, capture) {\n    return element.addEventListener(type, func, {\n        passive: !nonPassive,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _wheelListener = function _wheelListener(func, el, scrollFunc) {\n    scrollFunc = scrollFunc && scrollFunc.wheelHandler;\n    if (scrollFunc) {\n        func(el, \"wheel\", scrollFunc);\n        func(el, \"touchmove\", scrollFunc);\n    }\n}, _markerDefaults = {\n    startColor: \"green\",\n    endColor: \"red\",\n    indent: 0,\n    fontSize: \"16px\",\n    fontWeight: \"normal\"\n}, _defaults = {\n    toggleActions: \"play\",\n    anticipatePin: 0\n}, _keywords = {\n    top: 0,\n    left: 0,\n    center: 0.5,\n    bottom: 1,\n    right: 1\n}, _offsetToPx = function _offsetToPx(value, size) {\n    if (_isString(value)) {\n        var eqIndex = value.indexOf(\"=\"), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n        if (~eqIndex) {\n            value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n            value = value.substr(0, eqIndex - 1);\n        }\n        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n    }\n    return value;\n}, _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;\n    var e = _doc.createElement(\"div\"), useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\", isScroller = type.indexOf(\"scroller\") !== -1, parent = useFixedPosition ? _body : container, isStart = type.indexOf(\"start\") !== -1, color = isStart ? startColor : endColor, css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n    css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n    matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n    e._isStart = isStart;\n    e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n    e.style.cssText = css;\n    e.innerText = name || name === 0 ? type + \"-\" + name : type;\n    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n    e._offset = e[\"offset\" + direction.op.d2];\n    _positionMarker(e, 0, direction, isStart);\n    return e;\n}, _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n    var vars = {\n        display: \"block\"\n    }, side = direction[flipped ? \"os2\" : \"p2\"], oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n    marker._isFlipped = flipped;\n    vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n    vars[direction.a] = flipped ? \"1px\" : 0;\n    vars[\"border\" + side + _Width] = 1;\n    vars[\"border\" + oppositeSide + _Width] = 0;\n    vars[direction.p] = start + \"px\";\n    gsap.set(marker, vars);\n}, _triggers = [], _ids = {}, _rafID, _sync = function _sync() {\n    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\n}, _onScroll = function _onScroll() {\n    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n        // if the user is dragging the scrollbar, allow it.\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n        if (_normalizer) {\n            _rafID || (_rafID = requestAnimationFrame(_updateAll));\n        } else {\n            _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110\n        }\n        _lastScrollTime || _dispatch(\"scrollStart\");\n        _lastScrollTime = _getTime();\n    }\n}, _setBaseDimensions = function _setBaseDimensions() {\n    _baseScreenWidth = _win.innerWidth;\n    _baseScreenHeight = _win.innerHeight;\n}, _onResize = function _onResize(force) {\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    (force === true || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25)) && _resizeDelay.restart(true);\n}, // ignore resizes triggered by refresh()\n_listeners = {}, _emptyArray = [], _softRefresh = function _softRefresh() {\n    return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n}, _dispatch = function _dispatch(type) {\n    return _listeners[type] && _listeners[type].map(function(f) {\n        return f();\n    }) || _emptyArray;\n}, _savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n    for(var i = 0; i < _savedStyles.length; i += 5){\n        if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n            _savedStyles[i].style.cssText = _savedStyles[i + 1];\n            _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n            _savedStyles[i + 3].uncache = 1;\n        }\n    }\n}, _recordScrollPositions = function _recordScrollPositions() {\n    return _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\n    });\n}, // record the current scroll position. Also force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\n_revertAll = function _revertAll(kill, media) {\n    var trigger;\n    for(_i = 0; _i < _triggers.length; _i++){\n        trigger = _triggers[_i];\n        if (trigger && (!media || trigger._ctx === media)) {\n            if (kill) {\n                trigger.kill(1);\n            } else {\n                trigger.revert(true, true);\n            }\n        }\n    }\n    _isReverted = true;\n    media && _revertRecorded(media);\n    media || _dispatch(\"revert\");\n}, _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\n    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n    });\n    _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n}, _refreshingAll, _refreshID = 0, _queueRefreshID, _queueRefreshAll = function _queueRefreshAll() {\n    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's \"load\" or \"DOMContentLoaded\" events to trigger it.\n    if (_queueRefreshID !== _refreshID) {\n        var id = _queueRefreshID = _refreshID;\n        requestAnimationFrame(function() {\n            return id === _refreshID && _refreshAll(true);\n        });\n    }\n}, _refresh100vh = function _refresh100vh() {\n    _body.appendChild(_div100vh);\n    _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\n    _body.removeChild(_div100vh);\n}, _hideAllMarkers = function _hideAllMarkers(hide) {\n    return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function(el) {\n        return el.style.display = hide ? \"none\" : \"block\";\n    });\n}, _refreshAll = function _refreshAll(force, skipRevert) {\n    _docEl = _doc.documentElement; // some frameworks like Astro may cache the <body> and replace it during routing, so we'll just re-record the _docEl and _body for safety (otherwise, the markers may not get added properly).\n    _body = _doc.body;\n    _root = [\n        _win,\n        _doc,\n        _docEl,\n        _body\n    ];\n    if (_lastScrollTime && !force && !_isReverted) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n        return;\n    }\n    _refresh100vh();\n    _refreshingAll = ScrollTrigger.isRefreshing = true;\n    _isReverted || _recordScrollPositions();\n    var refreshInits = _dispatch(\"refreshInit\");\n    _sort && ScrollTrigger.sort();\n    skipRevert || _revertAll();\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\n            obj(0);\n        }\n    });\n    _triggers.slice(0).forEach(function(t) {\n        return t.refresh();\n    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n    _isReverted = false;\n    _triggers.forEach(function(t) {\n        // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.\n        if (t._subPinOffset && t.pin) {\n            var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\", original = t.pin[prop];\n            t.revert(true, 1);\n            t.adjustPinSpacing(t.pin[prop] - original);\n            t.refresh();\n        }\n    });\n    _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.\n    _hideAllMarkers(true);\n    _triggers.forEach(function(t) {\n        // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\". Same for anything with a clamped end\n        var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;\n        (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\n    });\n    _hideAllMarkers(false);\n    _clampingMax = 0;\n    refreshInits.forEach(function(result) {\n        return result && result.render && result.render(-1);\n    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && requestAnimationFrame(function() {\n                return obj.target.style.scrollBehavior = \"smooth\";\n            });\n            obj.rec && obj(obj.rec);\n        }\n    });\n    _clearScrollMemory(_scrollRestoration, 1);\n    _resizeDelay.pause();\n    _refreshID++;\n    _refreshingAll = 2;\n    _updateAll(2);\n    _triggers.forEach(function(t) {\n        return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\n    });\n    _refreshingAll = ScrollTrigger.isRefreshing = false;\n    _dispatch(\"refresh\");\n}, _lastScroll = 0, _direction = 1, _primary, _updateAll = function _updateAll(force) {\n    if (force === 2 || !_refreshingAll && !_isReverted) {\n        // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.\n        ScrollTrigger.isUpdating = true;\n        _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n        var l = _triggers.length, time = _getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();\n        _direction = _lastScroll > scroll ? -1 : 1;\n        _refreshingAll || (_lastScroll = scroll);\n        if (recordVelocity) {\n            if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n                _lastScrollTime = 0;\n                _dispatch(\"scrollEnd\");\n            }\n            _time2 = _time1;\n            _time1 = time;\n        }\n        if (_direction < 0) {\n            _i = l;\n            while(_i-- > 0){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n            _direction = 1;\n        } else {\n            for(_i = 0; _i < l; _i++){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n        }\n        ScrollTrigger.isUpdating = false;\n    }\n    _rafID = 0;\n}, _propNamesToCopy = [\n    _left,\n    _top,\n    _bottom,\n    _right,\n    _margin + _Bottom,\n    _margin + _Right,\n    _margin + _Top,\n    _margin + _Left,\n    \"display\",\n    \"flexShrink\",\n    \"float\",\n    \"zIndex\",\n    \"gridColumnStart\",\n    \"gridColumnEnd\",\n    \"gridRowStart\",\n    \"gridRowEnd\",\n    \"gridArea\",\n    \"justifySelf\",\n    \"alignSelf\",\n    \"placeSelf\",\n    \"order\"\n], _stateProps = _propNamesToCopy.concat([\n    _width,\n    _height,\n    \"boxSizing\",\n    \"max\" + _Width,\n    \"max\" + _Height,\n    \"position\",\n    _margin,\n    _padding,\n    _padding + _Top,\n    _padding + _Right,\n    _padding + _Bottom,\n    _padding + _Left\n]), _swapPinOut = function _swapPinOut(pin, spacer, state) {\n    _setState(state);\n    var cache = pin._gsap;\n    if (cache.spacerIsNative) {\n        _setState(cache.spacerState);\n    } else if (pin._gsap.swappedIn) {\n        var parent = spacer.parentNode;\n        if (parent) {\n            parent.insertBefore(pin, spacer);\n            parent.removeChild(spacer);\n        }\n    }\n    pin._gsap.swappedIn = false;\n}, _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n    if (!pin._gsap.swappedIn) {\n        var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;\n        while(i--){\n            p = _propNamesToCopy[i];\n            spacerStyle[p] = cs[p];\n        }\n        spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n        cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n        pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n        spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n        spacerStyle.overflow = \"visible\";\n        spacerStyle.boxSizing = \"border-box\";\n        spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;\n        spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;\n        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n        _setState(spacerState);\n        pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n        pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n        pinStyle[_padding] = cs[_padding];\n        if (pin.parentNode !== spacer) {\n            pin.parentNode.insertBefore(spacer, pin);\n            spacer.appendChild(pin);\n        }\n        pin._gsap.swappedIn = true;\n    }\n}, _capsExp = /([A-Z])/g, _setState = function _setState(state) {\n    if (state) {\n        var style = state.t.style, l = state.length, i = 0, p, value;\n        (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n        for(; i < l; i += 2){\n            value = state[i + 1];\n            p = state[i];\n            if (value) {\n                style[p] = value;\n            } else if (style[p]) {\n                style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n            }\n        }\n    }\n}, _getState = function _getState(element) {\n    // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n    var l = _stateProps.length, style = element.style, state = [], i = 0;\n    for(; i < l; i++){\n        state.push(_stateProps[i], style[_stateProps[i]]);\n    }\n    state.t = element;\n    return state;\n}, _copyState = function _copyState(state, override, omitOffsets) {\n    var result = [], l = state.length, i = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n    p;\n    for(; i < l; i += 2){\n        p = state[i];\n        result.push(p, p in override ? override[p] : state[i + 1]);\n    }\n    result.t = state.t;\n    return result;\n}, _winOffsets = {\n    left: 0,\n    top: 0\n}, // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\n    _isFunction(value) && (value = value(self));\n    if (_isString(value) && value.substr(0, 3) === \"max\") {\n        value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n    }\n    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;\n    containerAnimation && containerAnimation.seek(0);\n    isNaN(value) || (value = +value); // convert a string number like \"45\" to an actual number\n    if (!_isNumber(value)) {\n        _isFunction(trigger) && (trigger = trigger(self));\n        var offsets = (value || \"0\").split(\" \"), bounds, localOffset, globalOffset, display;\n        element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger, self) || _body;\n        bounds = _getBounds(element) || {};\n        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n            // if display is \"none\", it won't report getBoundingClientRect() properly\n            display = element.style.display;\n            element.style.display = \"block\";\n            bounds = _getBounds(element);\n            display ? element.style.display = display : element.style.removeProperty(\"display\");\n        }\n        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n        globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n        scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n    } else {\n        containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\n        markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\n    }\n    if (clampZeroProp) {\n        self[clampZeroProp] = value || -0.001;\n        value < 0 && (value = 0);\n    }\n    if (marker) {\n        var position = value + scrollerSize, isStart = marker._isStart;\n        p1 = \"scroll\" + direction.d2;\n        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n        if (useFixedPosition) {\n            scrollerBounds = _getBounds(markerScroller);\n            useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n        }\n    }\n    if (containerAnimation && element) {\n        p1 = _getBounds(element);\n        containerAnimation.seek(scrollerMax);\n        p2 = _getBounds(element);\n        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n        value = value / containerAnimation._caScrollDist * scrollerMax;\n    }\n    containerAnimation && containerAnimation.seek(time);\n    return containerAnimation ? value : Math.round(value);\n}, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent(element, parent, top, left) {\n    if (element.parentNode !== parent) {\n        var style = element.style, p, cs;\n        if (parent === _body) {\n            element._stOrig = style.cssText; // record original inline styles so we can revert them later\n            cs = _getComputedStyle(element);\n            for(p in cs){\n                // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n                if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n                    style[p] = cs[p];\n                }\n            }\n            style.top = top;\n            style.left = left;\n        } else {\n            style.cssText = element._stOrig;\n        }\n        gsap.core.getCache(element).uncache = 1;\n        parent.appendChild(element);\n    }\n}, _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {\n    var last1 = initialValue, last2 = last1;\n    return function(value) {\n        var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.\n        if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\n            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n            value = current;\n            onInterrupt && onInterrupt();\n        }\n        last2 = last1;\n        last1 = Math.round(value);\n        return last1;\n    };\n}, _shiftMarker = function _shiftMarker(marker, direction, value) {\n    var vars = {};\n    vars[direction.p] = \"+=\" + value;\n    gsap.set(marker, vars);\n}, // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n    var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), prop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n    getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n        var tween = getTween.tween, onComplete = vars.onComplete, modifiers = {};\n        initialValue = initialValue || getScroll();\n        var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {\n            tween.kill();\n            getTween.tween = 0;\n        });\n        change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n        change1 = change1 || scrollTo - initialValue;\n        tween && tween.kill();\n        vars[prop] = scrollTo;\n        vars.inherit = false;\n        vars.modifiers = modifiers;\n        modifiers[prop] = function() {\n            return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\n        };\n        vars.onUpdate = function() {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n            getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()\n        };\n        vars.onComplete = function() {\n            getTween.tween = 0;\n            onComplete && onComplete.call(tween);\n        };\n        tween = getTween.tween = gsap.to(scroller, vars);\n        return tween;\n    };\n    scroller[prop] = getScroll;\n    getScroll.wheelHandler = function() {\n        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n    };\n    _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n    ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\n    return getTween;\n};\nvar ScrollTrigger = /*#__PURE__*/ function() {\n    function ScrollTrigger(vars, animation) {\n        _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n        _context(this);\n        this.init(vars, animation);\n    }\n    var _proto = ScrollTrigger.prototype;\n    _proto.init = function init(vars, animation) {\n        this.progress = this.start = 0;\n        this.vars && this.kill(true, true); // in case it's being initted again\n        if (!_enabled) {\n            this.update = this.refresh = this.kill = _passThrough;\n            return;\n        }\n        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n            trigger: vars\n        } : vars, _defaults);\n        var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical, isToggle = !scrub && scrub !== 0, scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win), scrollerCache = gsap.core.getCache(scroller), isViewport = _isViewport(scroller), useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\", callbacks = [\n            vars.onEnter,\n            vars.onLeave,\n            vars.onEnterBack,\n            vars.onLeaveBack\n        ], toggleActions = isToggle && vars.toggleActions.split(\" \"), markers = \"markers\" in vars ? vars.markers : _defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {\n            return vars.onRefreshInit(self);\n        }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start=\"clamp(top bottom)\" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.\n        self._startClamp = self._endClamp = false;\n        self._dir = direction;\n        anticipatePin *= 45;\n        self.scroller = scroller;\n        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n        scroll1 = scrollFunc();\n        self.vars = vars;\n        animation = animation || vars.animation;\n        if (\"refreshPriority\" in vars) {\n            _sort = 1;\n            vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n        }\n        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n            top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n            left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\n        };\n        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n        self.scrubDuration = function(value) {\n            scrubSmooth = _isNumber(value) && value;\n            if (!scrubSmooth) {\n                scrubTween && scrubTween.progress(1).kill();\n                scrubTween = 0;\n            } else {\n                scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n                    ease: \"expo\",\n                    totalProgress: \"+=0\",\n                    inherit: false,\n                    duration: scrubSmooth,\n                    paused: true,\n                    onComplete: function onComplete() {\n                        return onScrubComplete && onScrubComplete(self);\n                    }\n                });\n            }\n        };\n        if (animation) {\n            animation.vars.lazy = false;\n            animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010\n            self.animation = animation.pause();\n            animation.scrollTrigger = self;\n            self.scrubDuration(scrub);\n            snap1 = 0;\n            id || (id = animation.vars.id);\n        }\n        if (snap) {\n            // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\n            if (!_isObject(snap) || snap.push) {\n                snap = {\n                    snapTo: snap\n                };\n            }\n            \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [\n                _body,\n                _docEl\n            ] : scroller, {\n                scrollBehavior: \"auto\"\n            }); // smooth scrolling doesn't work with snap.\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(o) {\n                return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\n            }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters\n            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {\n                return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n            } : gsap.utils.snap(snap.snapTo);\n            snapDurClamp = snap.duration || {\n                min: 0.1,\n                max: 2\n            };\n            snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n            snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {\n                var scroll = scrollFunc(), refreshedRecently = _getTime() - lastRefresh < 500, tween = tweenTo.tween;\n                if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n                    var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0, change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;\n                    endValue = snapFunc(naturalEnd, self);\n                    _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd\n                    endScroll = Math.max(0, Math.round(start + endValue * change));\n                    if (scroll <= end && scroll >= start && endScroll !== scroll) {\n                        if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n                            // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n                            return;\n                        }\n                        if (snap.inertia === false) {\n                            change1 = endValue - progress;\n                        }\n                        tweenTo(endScroll, {\n                            duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n                            ease: snap.ease || \"power3\",\n                            data: _abs(endScroll - scroll),\n                            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n                            onInterrupt: function onInterrupt() {\n                                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n                            },\n                            onComplete: function onComplete() {\n                                self.update();\n                                lastSnap = scrollFunc();\n                                if (animation && !isToggle) {\n                                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap\n                                    scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\n                                }\n                                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                                onSnapComplete && onSnapComplete(self);\n                                _onComplete && _onComplete(self);\n                            }\n                        }, scroll, change1 * change, endScroll - scroll - change1 * change);\n                        onStart && onStart(self, tweenTo.tween);\n                    }\n                } else if (self.isActive && lastSnap !== scroll) {\n                    snapDelayedCall.restart(true);\n                }\n            }).pause();\n        }\n        id && (_ids[id] = self);\n        trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n        customRevertReturn && (customRevertReturn = customRevertReturn(self));\n        pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\n        _isString(toggleClass) && (toggleClass = {\n            targets: trigger,\n            className: toggleClass\n        });\n        if (pin) {\n            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)\n            self.pin = pin;\n            pinCache = gsap.core.getCache(pin);\n            if (!pinCache.spacer) {\n                // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n                if (pinSpacer) {\n                    pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\n                    pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n                    pinCache.spacerIsNative = !!pinSpacer;\n                    pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n                }\n                pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n                spacer.classList.add(\"pin-spacer\");\n                id && spacer.classList.add(\"pin-spacer-\" + id);\n                pinCache.pinState = pinOriginalState = _getState(pin);\n            } else {\n                pinOriginalState = pinCache.pinState;\n            }\n            vars.force3D !== false && gsap.set(pin, {\n                force3D: true\n            });\n            self.spacer = spacer = pinCache.spacer;\n            cs = _getComputedStyle(pin);\n            spacingStart = cs[pinSpacing + direction.os2];\n            pinGetter = gsap.getProperty(pin);\n            pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n            _swapPinIn(pin, spacer, cs);\n            pinState = _getState(pin);\n        }\n        if (markers) {\n            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n            markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n            markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n            offset = markerStartTrigger[\"offset\" + direction.op.d2];\n            var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\n            markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            containerAnimation && (caMarkerSetter = gsap.quickSetter([\n                markerStart,\n                markerEnd\n            ], direction.a, _px));\n            if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\n                _makePositionable(isViewport ? _body : scroller);\n                gsap.set([\n                    markerStartTrigger,\n                    markerEndTrigger\n                ], {\n                    force3D: true\n                });\n                markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n                markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n            }\n        }\n        if (containerAnimation) {\n            var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;\n            containerAnimation.eventCallback(\"onUpdate\", function() {\n                self.update(0, 0, 1);\n                oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\n            });\n        }\n        self.previous = function() {\n            return _triggers[_triggers.indexOf(self) - 1];\n        };\n        self.next = function() {\n            return _triggers[_triggers.indexOf(self) + 1];\n        };\n        self.revert = function(revert, temp) {\n            if (!temp) {\n                return self.kill(true);\n            } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\n            var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;\n            if (r !== self.isReverted) {\n                if (r) {\n                    prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n                    prevProgress = self.progress;\n                    prevAnimProgress = animation && animation.progress();\n                }\n                markerStart && [\n                    markerStart,\n                    markerEnd,\n                    markerStartTrigger,\n                    markerEndTrigger\n                ].forEach(function(m) {\n                    return m.style.display = r ? \"none\" : \"block\";\n                });\n                if (r) {\n                    _refreshing = self;\n                    self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out\n                }\n                if (pin && (!pinReparent || !self.isActive)) {\n                    if (r) {\n                        _swapPinOut(pin, spacer, pinOriginalState);\n                    } else {\n                        _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\n                    }\n                }\n                r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.\n                _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.\n                self.isReverted = r;\n            }\n        };\n        self.refresh = function(soft, force, position, pinOffset) {\n            // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects\n            if ((_refreshing || !self.enabled) && !force) {\n                return;\n            }\n            if (pin && soft && _lastScrollTime) {\n                _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n                return;\n            }\n            !_refreshingAll && onRefreshInit && onRefreshInit(self);\n            _refreshing = self;\n            if (tweenTo.tween && !position) {\n                // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.\n                tweenTo.tween.kill();\n                tweenTo.tween = 0;\n            }\n            scrubTween && scrubTween.pause();\n            if (invalidateOnRefresh && animation) {\n                animation.revert({\n                    kill: false\n                }).invalidate();\n                animation.getChildren ? animation.getChildren(true, true, false).forEach(function(t) {\n                    return t.vars.immediateRender && t.render(0, true, true);\n                }) : animation.vars.immediateRender && animation.render(0, true, true); // any from() or fromTo() tweens should render immediately (well, unless they have immediateRender: false)\n            }\n            self.isReverted || self.revert(true, true);\n            self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any\n            var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01 || !change, offset = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex, cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;\n            if (markers && _isObject(position)) {\n                // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.\n                markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\n            }\n            while(i-- > 0){\n                // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n                curTrigger = _triggers[i];\n                curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n                curPin = curTrigger.pin;\n                if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\n                    revertedPins || (revertedPins = []);\n                    revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n                    curTrigger.revert(true, true);\n                }\n                if (curTrigger !== _triggers[i]) {\n                    // in case it got removed.\n                    triggerIndex--;\n                    i--;\n                }\n            }\n            _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n            parsedStart = _parseClamp(parsedStart, \"start\", self);\n            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -0.001 : 0);\n            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n            if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n                if (~parsedEnd.indexOf(\" \")) {\n                    parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n                } else {\n                    offset = _offsetToPx(parsedEnd.substr(2), size);\n                    parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n                    parsedEndTrigger = trigger;\n                }\n            }\n            parsedEnd = _parseClamp(parsedEnd, \"end\", self);\n            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -0.001;\n            offset = 0;\n            i = triggerIndex;\n            while(i--){\n                curTrigger = _triggers[i] || {};\n                curPin = curTrigger.pin;\n                if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\n                    cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\n                    if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\n                        // numeric start values shouldn't be offset at all - treat them as absolute\n                        offset += cs * (1 - curTrigger.progress);\n                    }\n                    curPin === pin && (otherPinOffset += cs);\n                }\n            }\n            start += offset;\n            end += offset;\n            self._startClamp && (self._startClamp += offset);\n            if (self._endClamp && !_refreshingAll) {\n                self._endClamp = end || -0.001;\n                end = Math.min(end, _maxScroll(scroller, direction));\n            }\n            change = end - start || (start -= 0.01) && 0.001;\n            if (isFirstRefresh) {\n                // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.\n                prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\n            }\n            self._pinPush = otherPinOffset;\n            if (markerStart && offset) {\n                // offset the markers if necessary\n                cs = {};\n                cs[direction.a] = \"+=\" + offset;\n                pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n                gsap.set([\n                    markerStart,\n                    markerEnd\n                ], cs);\n            }\n            if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\n                cs = _getComputedStyle(pin);\n                isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\n                scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n                pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n                if (!max && end > 1) {\n                    // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n                    forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\n                    forcedOverflow = {\n                        style: forcedOverflow,\n                        value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\n                    };\n                    if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\n                        // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to \"scroll\"\n                        forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\n                    }\n                }\n                _swapPinIn(pin, spacer, cs);\n                pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n                bounds = _getBounds(pin, true);\n                oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\n                if (pinSpacing) {\n                    spacerState = [\n                        pinSpacing + direction.os2,\n                        change + otherPinOffset + _px\n                    ];\n                    spacerState.t = spacer;\n                    i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n                    if (i) {\n                        spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n                        spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                    }\n                    _setState(spacerState);\n                    if (pinnedContainer) {\n                        // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.\n                        _triggers.forEach(function(t) {\n                            if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\n                                t._subPinOffset = true;\n                            }\n                        });\n                    }\n                    useFixedPosition && scrollFunc(prevScroll);\n                } else {\n                    i = _getSize(pin, direction);\n                    i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                }\n                if (useFixedPosition) {\n                    override = {\n                        top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n                        left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n                        boxSizing: \"border-box\",\n                        position: \"fixed\"\n                    };\n                    override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n                    override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n                    override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n                    override[_padding] = cs[_padding];\n                    override[_padding + _Top] = cs[_padding + _Top];\n                    override[_padding + _Right] = cs[_padding + _Right];\n                    override[_padding + _Bottom] = cs[_padding + _Bottom];\n                    override[_padding + _Left] = cs[_padding + _Left];\n                    pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n                    _refreshingAll && scrollFunc(0);\n                }\n                if (animation) {\n                    // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n                    initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n                    _suppressOverwrites(1);\n                    animation.render(animation.duration(), true, true);\n                    pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n                    pinMoves = Math.abs(change - pinChange) > 1;\n                    useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n                    animation.render(0, true, true);\n                    initted || animation.invalidate(true);\n                    animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\n                    _suppressOverwrites(0);\n                } else {\n                    pinChange = change;\n                }\n                forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\n            } else if (trigger && scrollFunc() && !containerAnimation) {\n                // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n                bounds = trigger.parentNode;\n                while(bounds && bounds !== _body){\n                    if (bounds._pinOffset) {\n                        start -= bounds._pinOffset;\n                        end -= bounds._pinOffset;\n                    }\n                    bounds = bounds.parentNode;\n                }\n            }\n            revertedPins && revertedPins.forEach(function(t) {\n                return t.revert(false, true);\n            });\n            self.start = start;\n            self.end = end;\n            scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\n            if (!containerAnimation && !_refreshingAll) {\n                scroll1 < prevScroll && scrollFunc(prevScroll);\n                self.scroll.rec = 0;\n            }\n            self.revert(false, true);\n            lastRefresh = _getTime();\n            if (snapDelayedCall) {\n                lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value\n                // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.\n                snapDelayedCall.restart(true);\n            }\n            _refreshing = 0;\n            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n            if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {\n                // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n                animation && !isToggle && (animation._initted || prevProgress || animation.vars.immediateRender !== false) && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n                self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n            }\n            pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n            scrubTween && scrubTween.invalidate();\n            if (!isNaN(markerStartOffset)) {\n                // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like \"top\", \"center\", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.\n                markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\n                _shiftMarker(markerStartTrigger, direction, markerStartOffset);\n                _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\n                _shiftMarker(markerEndTrigger, direction, markerEndOffset);\n                _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\n            }\n            isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a \"scroll\" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.\n            if (onRefresh && !_refreshingAll && !executingOnRefresh) {\n                // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.\n                executingOnRefresh = true;\n                onRefresh(self);\n                executingOnRefresh = false;\n            }\n        };\n        self.getVelocity = function() {\n            return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n        };\n        self.endAnimation = function() {\n            _endAnimation(self.callbackAnimation);\n            if (animation) {\n                scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n            }\n        };\n        self.labelToScroll = function(label) {\n            return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n        };\n        self.getTrailing = function(name) {\n            var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n            return (_isString(name) ? a.filter(function(t) {\n                return t.vars.preventOverlaps === name;\n            }) : a).filter(function(t) {\n                return self.direction > 0 ? t.end <= start : t.start >= end;\n            });\n        };\n        self.update = function(reset, recordVelocity, forceFake) {\n            if (containerAnimation && !forceFake && !reset) {\n                return;\n            }\n            var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;\n            if (recordVelocity) {\n                scroll2 = scroll1;\n                scroll1 = containerAnimation ? scrollFunc() : scroll;\n                if (snap) {\n                    snap2 = snap1;\n                    snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n                }\n            } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n            if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\n                if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.0001;\n                } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.9999;\n                }\n            }\n            if (clipped !== prevProgress && self.enabled) {\n                isActive = self.isActive = !!clipped && clipped < 1;\n                wasActive = !!prevProgress && prevProgress < 1;\n                toggled = isActive !== wasActive;\n                stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n                self.direction = clipped > prevProgress ? 1 : -1;\n                self.progress = clipped;\n                if (stateChanged && !_refreshing) {\n                    toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n                    if (isToggle) {\n                        action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n                        isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n                    }\n                }\n                preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {\n                    return t.endAnimation();\n                }));\n                if (!isToggle) {\n                    if (scrubTween && !_refreshing && !_startup) {\n                        scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n                        if (scrubTween.resetTo) {\n                            scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n                        } else {\n                            // legacy support (courtesy), before 3.10.0\n                            scrubTween.vars.totalProgress = clipped;\n                            scrubTween.invalidate().restart();\n                        }\n                    } else if (animation) {\n                        animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\n                    }\n                }\n                if (pin) {\n                    reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n                    if (!useFixedPosition) {\n                        pinSetter(_round(pinStart + pinChange * clipped));\n                    } else if (stateChanged) {\n                        isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n                        if (pinReparent) {\n                            if (!reset && (isActive || isAtMax)) {\n                                var bounds = _getBounds(pin, true), _offset = scroll - start;\n                                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px);\n                            } else {\n                                _reparent(pin, spacer);\n                            }\n                        }\n                        _setState(isActive || isAtMax ? pinActiveState : pinState);\n                        pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n                    }\n                }\n                snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n                toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {\n                    return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n                }); // classes could affect positioning, so do it even if reset or refreshing is true.\n                onUpdate && !isToggle && !reset && onUpdate(self);\n                if (stateChanged && !_refreshing) {\n                    if (isToggle) {\n                        if (isTakingAction) {\n                            if (action === \"complete\") {\n                                animation.pause().totalProgress(1);\n                            } else if (action === \"reset\") {\n                                animation.restart(true).pause();\n                            } else if (action === \"restart\") {\n                                animation.restart(true);\n                            } else {\n                                animation[action]();\n                            }\n                        }\n                        onUpdate && onUpdate(self);\n                    }\n                    if (toggled || !_limitCallbacks) {\n                        // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n                        onToggle && toggled && _callback(self, onToggle);\n                        callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n                        if (!toggled) {\n                            // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n                            toggleState = clipped === 1 ? 1 : 3;\n                            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        }\n                    }\n                    if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n                        _endAnimation(self.callbackAnimation);\n                        scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n                    }\n                } else if (isToggle && onUpdate && !_refreshing) {\n                    onUpdate(self);\n                }\n            } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n            if (markerEndSetter) {\n                var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n                markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n                markerEndSetter(n);\n            }\n            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n        };\n        self.enable = function(reset, refresh) {\n            if (!self.enabled) {\n                self.enabled = true;\n                _addListener(scroller, \"resize\", _onResize);\n                isViewport || _addListener(scroller, \"scroll\", _onScroll);\n                onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (reset !== false) {\n                    self.progress = prevProgress = 0;\n                    scroll1 = scroll2 = lastSnap = scrollFunc();\n                }\n                refresh !== false && self.refresh();\n            }\n        };\n        self.getTween = function(snap) {\n            return snap && tweenTo ? tweenTo.tween : scrubTween;\n        };\n        self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {\n            // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n            if (containerAnimation) {\n                // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.\n                var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;\n                newStart = st.start + _change * newStart / duration;\n                newEnd = st.start + _change * newEnd / duration;\n            }\n            self.refresh(false, false, {\n                start: _keepClamp(newStart, keepClamp && !!self._startClamp),\n                end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\n            }, pinOffset);\n            self.update();\n        };\n        self.adjustPinSpacing = function(amount) {\n            if (spacerState && amount) {\n                var i = spacerState.indexOf(direction.d) + 1;\n                spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\n                spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\n                _setState(spacerState);\n            }\n        };\n        self.disable = function(reset, allowAnimation) {\n            reset !== false && self.revert(true, true);\n            if (self.enabled) {\n                self.enabled = self.isActive = false;\n                allowAnimation || scrubTween && scrubTween.pause();\n                prevScroll = 0;\n                pinCache && (pinCache.uncache = 1);\n                onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (snapDelayedCall) {\n                    snapDelayedCall.pause();\n                    tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n                }\n                if (!isViewport) {\n                    var i = _triggers.length;\n                    while(i--){\n                        if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n                            return; //don't remove the listeners if there are still other triggers referencing it.\n                        }\n                    }\n                    _removeListener(scroller, \"resize\", _onResize);\n                    isViewport || _removeListener(scroller, \"scroll\", _onScroll);\n                }\n            }\n        };\n        self.kill = function(revert, allowAnimation) {\n            self.disable(revert, allowAnimation);\n            scrubTween && !allowAnimation && scrubTween.kill();\n            id && delete _ids[id];\n            var i = _triggers.indexOf(self);\n            i >= 0 && _triggers.splice(i, 1);\n            i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n            // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n            i = 0;\n            _triggers.forEach(function(t) {\n                return t.scroller === self.scroller && (i = 1);\n            });\n            i || _refreshingAll || (self.scroll.rec = 0);\n            if (animation) {\n                animation.scrollTrigger = null;\n                revert && animation.revert({\n                    kill: false\n                });\n                allowAnimation || animation.kill();\n            }\n            markerStart && [\n                markerStart,\n                markerEnd,\n                markerStartTrigger,\n                markerEndTrigger\n            ].forEach(function(m) {\n                return m.parentNode && m.parentNode.removeChild(m);\n            });\n            _primary === self && (_primary = 0);\n            if (pin) {\n                pinCache && (pinCache.uncache = 1);\n                i = 0;\n                _triggers.forEach(function(t) {\n                    return t.pin === pin && i++;\n                });\n                i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n            }\n            vars.onKill && vars.onKill(self);\n        };\n        _triggers.push(self);\n        self.enable(false, false);\n        customRevertReturn && customRevertReturn(self);\n        if (animation && animation.add && !change) {\n            // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n            var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().\n            self.update = function() {\n                self.update = updateFunc;\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // otherwise a cached scroll position may get used in the refresh() in a very rare scenario, like if ScrollTriggers are created inside a DOMContentLoaded event and the queued requestAnimationFrame() fires beforehand. See https://gsap.com/community/forums/topic/41267-scrolltrigger-breaks-on-refresh-when-using-domcontentloaded/\n                start || end || self.refresh();\n            };\n            gsap.delayedCall(0.01, self.update);\n            change = 0.01;\n            start = end = 0;\n        } else {\n            self.refresh();\n        }\n        pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()\n    };\n    ScrollTrigger.register = function register(core) {\n        if (!_coreInitted) {\n            gsap = core || _getGSAP();\n            _windowExists() && window.document && ScrollTrigger.enable();\n            _coreInitted = _enabled;\n        }\n        return _coreInitted;\n    };\n    ScrollTrigger.defaults = function defaults(config) {\n        if (config) {\n            for(var p in config){\n                _defaults[p] = config[p];\n            }\n        }\n        return _defaults;\n    };\n    ScrollTrigger.disable = function disable(reset, kill) {\n        _enabled = 0;\n        _triggers.forEach(function(trigger) {\n            return trigger[kill ? \"kill\" : \"disable\"](reset);\n        });\n        _removeListener(_win, \"wheel\", _onScroll);\n        _removeListener(_doc, \"scroll\", _onScroll);\n        clearInterval(_syncInterval);\n        _removeListener(_doc, \"touchcancel\", _passThrough);\n        _removeListener(_body, \"touchstart\", _passThrough);\n        _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n        _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n        _resizeDelay.kill();\n        _iterateAutoRefresh(_removeListener);\n        for(var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n        }\n    };\n    ScrollTrigger.enable = function enable() {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        if (gsap) {\n            _toArray = gsap.utils.toArray;\n            _clamp = gsap.utils.clamp;\n            _context = gsap.core.context || _passThrough;\n            _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n            _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n            _lastScroll = _win.pageYOffset || 0;\n            gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n            if (_body) {\n                _enabled = 1;\n                _div100vh = document.createElement(\"div\"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.\n                _div100vh.style.height = \"100vh\";\n                _div100vh.style.position = \"absolute\";\n                _refresh100vh();\n                _rafBugFix();\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n                ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\n                _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n                _ignoreMobileResize = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch === 1;\n                _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n                _root = [\n                    _win,\n                    _doc,\n                    _docEl,\n                    _body\n                ];\n                if (gsap.matchMedia) {\n                    ScrollTrigger.matchMedia = function(vars) {\n                        var mm = gsap.matchMedia(), p;\n                        for(p in vars){\n                            mm.add(p, vars[p]);\n                        }\n                        return mm;\n                    };\n                    gsap.addEventListener(\"matchMediaInit\", function() {\n                        _recordScrollPositions();\n                        _revertAll();\n                    });\n                    gsap.addEventListener(\"matchMediaRevert\", function() {\n                        return _revertRecorded();\n                    });\n                    gsap.addEventListener(\"matchMedia\", function() {\n                        _refreshAll(0, 1);\n                        _dispatch(\"matchMedia\");\n                    });\n                    gsap.matchMedia().add(\"(orientation: portrait)\", function() {\n                        // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n                        _setBaseDimensions();\n                        return _setBaseDimensions;\n                    });\n                } else {\n                    console.warn(\"Requires GSAP 3.11.0 or later\");\n                }\n                _setBaseDimensions();\n                _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n                var bodyHasStyle = _body.hasAttribute(\"style\"), bodyStyle = _body.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap.core.Animation.prototype, bounds, i;\n                AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n                    value: function value() {\n                        return this.time(-0.01, true);\n                    }\n                }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\n                bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n                bounds = _getBounds(_body);\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\n                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\");\n                if (!bodyHasStyle) {\n                    // SSR frameworks like Next.js complain if this attribute gets added.\n                    _body.setAttribute(\"style\", \"\"); // it's not enough to just removeAttribute() - we must first set it to empty, otherwise Next.js complains.\n                    _body.removeAttribute(\"style\");\n                } // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n                _syncInterval = setInterval(_sync, 250);\n                gsap.delayedCall(0.5, function() {\n                    return _startup = 0;\n                });\n                _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n                _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n                _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n                _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n                _transformProp = gsap.utils.checkPrefix(\"transform\");\n                _stateProps.push(_transformProp);\n                _coreInitted = _getTime();\n                _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n                _autoRefresh = [\n                    _doc,\n                    \"visibilitychange\",\n                    function() {\n                        var w = _win.innerWidth, h = _win.innerHeight;\n                        if (_doc.hidden) {\n                            _prevWidth = w;\n                            _prevHeight = h;\n                        } else if (_prevWidth !== w || _prevHeight !== h) {\n                            _onResize();\n                        }\n                    },\n                    _doc,\n                    \"DOMContentLoaded\",\n                    _refreshAll,\n                    _win,\n                    \"load\",\n                    _refreshAll,\n                    _win,\n                    \"resize\",\n                    _onResize\n                ];\n                _iterateAutoRefresh(_addListener);\n                _triggers.forEach(function(trigger) {\n                    return trigger.enable(0, 1);\n                });\n                for(i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n                }\n            }\n        }\n    };\n    ScrollTrigger.config = function config(vars) {\n        \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n        var ms = vars.syncInterval;\n        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n        \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n        if (\"autoRefreshEvents\" in vars) {\n            _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n            _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n        }\n    };\n    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n        var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target), i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t), isViewport = _isViewport(t);\n        if (~i) {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\n        }\n        if (vars) {\n            isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\n        }\n    };\n    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n        _triggers.forEach(function(t) {\n            return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n        });\n    };\n    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n        var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;\n        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n    };\n    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n        _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\n        var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n        return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n    };\n    ScrollTrigger.killAll = function killAll(allowListeners) {\n        _triggers.slice(0).forEach(function(t) {\n            return t.vars.id !== \"ScrollSmoother\" && t.kill();\n        });\n        if (allowListeners !== true) {\n            var listeners = _listeners.killAll || [];\n            _listeners = {};\n            listeners.forEach(function(f) {\n                return f();\n            });\n        }\n    };\n    return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.14.2\";\nScrollTrigger.saveStyles = function(targets) {\n    return targets ? _toArray(targets).forEach(function(target) {\n        // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n        if (target && target.style) {\n            var i = _savedStyles.indexOf(target);\n            i >= 0 && _savedStyles.splice(i, 5);\n            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n        }\n    }) : _savedStyles;\n};\nScrollTrigger.revert = function(soft, media) {\n    return _revertAll(!soft, media);\n};\nScrollTrigger.create = function(vars, animation) {\n    return new ScrollTrigger(vars, animation);\n};\nScrollTrigger.refresh = function(safe) {\n    return safe ? _onResize(true) : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\nScrollTrigger.update = function(force) {\n    return ++_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _updateAll(force === true ? 2 : 0);\n};\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\nScrollTrigger.maxScroll = function(element, horizontal) {\n    return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getScrollFunc = function(element, horizontal) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getById = function(id) {\n    return _ids[id];\n};\nScrollTrigger.getAll = function() {\n    return _triggers.filter(function(t) {\n        return t.vars.id !== \"ScrollSmoother\";\n    });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\nScrollTrigger.isScrolling = function() {\n    return !!_lastScrollTime;\n};\nScrollTrigger.snapDirectional = _snapDirectional;\nScrollTrigger.addEventListener = function(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = function(type, callback) {\n    var a = _listeners[type], i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = function(targets, vars) {\n    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback(type, callback) {\n        var elements = [], triggers = [], delay = gsap.delayedCall(interval, function() {\n            callback(elements, triggers);\n            elements = [];\n            triggers = [];\n        }).pause();\n        return function(self) {\n            elements.length || delay.restart(true);\n            elements.push(self.trigger);\n            triggers.push(self);\n            batchMax <= elements.length && delay.progress(1);\n        };\n    }, p;\n    for(p in vars){\n        varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n    }\n    if (_isFunction(batchMax)) {\n        batchMax = batchMax();\n        _addListener(ScrollTrigger, \"refresh\", function() {\n            return batchMax = vars.batchMax();\n        });\n    }\n    _toArray(targets).forEach(function(target) {\n        var config = {};\n        for(p in varsCopy){\n            config[p] = varsCopy[p];\n        }\n        config.trigger = target;\n        result.push(ScrollTrigger.create(config));\n    });\n    return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n}, _allowNativePanning = function _allowNativePanning(target, direction) {\n    if (direction === true) {\n        target.style.removeProperty(\"touch-action\");\n    } else {\n        target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n    }\n    target === _docEl && _allowNativePanning(_body, direction);\n}, _overflow = {\n    auto: 1,\n    scroll: 1\n}, _nestedScroll = function _nestedScroll(_ref5) {\n    var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;\n    var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap.core.getCache(node), time = _getTime(), cs;\n    if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n        // cache for 2 seconds to improve performance.\n        while(node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))){\n            node = node.parentNode;\n        }\n        cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n        cache._isScrollT = time;\n    }\n    if (cache._isScroll || axis === \"x\") {\n        event.stopPropagation();\n        event._gsapAllow = true;\n    }\n}, // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n    return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\n        target: target,\n        capture: true,\n        debounce: false,\n        lockAxis: true,\n        type: type,\n        onWheel: nested = nested && _nestedScroll,\n        onPress: nested,\n        onDrag: nested,\n        onScroll: nested,\n        onEnable: function onEnable() {\n            return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\n        },\n        onDisable: function onDisable() {\n            return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\n        }\n    });\n}, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function _captureInputs(e) {\n    var isInput = _inputExp.test(e.target.tagName);\n    if (isInput || _inputIsFocused) {\n        e._gsapAllow = true;\n        _inputIsFocused = isInput;\n    }\n}, _getScrollNormalizer = function _getScrollNormalizer(vars) {\n    _isObject(vars) || (vars = {});\n    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n    vars.type || (vars.type = \"wheel,touch\");\n    vars.debounce = !!vars.debounce;\n    vars.id = vars.id || \"normalizer\";\n    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl, smoother = gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical), scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal), scale = 1, initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction(momentum) ? function() {\n        return momentum(self);\n    } : function() {\n        return momentum || 2.8;\n    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove() {\n        return skipTouchMove = false;\n    }, scrollClampX = _passThrough, scrollClampY = _passThrough, updateClamps = function updateClamps() {\n        maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n        scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n        normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\n        lastRefreshID = _refreshID;\n    }, removeContentOffset = function removeContentOffset() {\n        content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n        scrollFuncY.offset = scrollFuncY.cacheID = 0;\n    }, ignoreDrag = function ignoreDrag() {\n        if (skipTouchMove) {\n            requestAnimationFrame(resumeTouchMove);\n            var offset = _round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);\n            if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n                scrollFuncY.offset = scroll - scrollFuncY.v;\n                var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n                content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n                content._gsap.y = y + \"px\";\n                scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n                _updateAll();\n            }\n            return true;\n        }\n        scrollFuncY.offset && removeContentOffset();\n        skipTouchMove = true;\n    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize() {\n        // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n        updateClamps();\n        if (tween.isActive() && tween.vars.scrollY > maxY) {\n            scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n        }\n    };\n    content && gsap.set(content, {\n        y: \"+=0\"\n    }); // to ensure there's a cache (element._gsap)\n    vars.ignoreCheck = function(e) {\n        return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n    };\n    vars.onPress = function() {\n        skipTouchMove = false;\n        var prevScale = scale;\n        scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n        tween.pause();\n        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n        startScrollX = scrollFuncX();\n        startScrollY = scrollFuncY();\n        updateClamps();\n        lastRefreshID = _refreshID;\n    };\n    vars.onRelease = vars.onGestureStart = function(self, wasDragging) {\n        scrollFuncY.offset && removeContentOffset();\n        if (!wasDragging) {\n            onStopDelayedCall.restart(true);\n        } else {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // make sure we're pulling the non-cached value\n            // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n            var dur = resolveMomentumDuration(), currentScroll, endScroll;\n            if (normalizeScrollX) {\n                currentScroll = scrollFuncX();\n                endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n                dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\n                tween.vars.scrollX = scrollClampX(endScroll);\n            }\n            currentScroll = scrollFuncY();\n            endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\n            tween.vars.scrollY = scrollClampY(endScroll);\n            tween.invalidate().duration(dur).play(0.01);\n            if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n                // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n                gsap.to({}, {\n                    onUpdate: onResize,\n                    duration: dur\n                });\n            }\n        }\n        onRelease && onRelease(self);\n    };\n    vars.onWheel = function() {\n        tween._ts && tween.pause();\n        if (_getTime() - wheelRefresh > 1000) {\n            // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n            lastRefreshID = 0;\n            wheelRefresh = _getTime();\n        }\n    };\n    vars.onChange = function(self, dx, dy, xArray, yArray) {\n        _refreshID !== lastRefreshID && updateClamps();\n        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n        if (dy) {\n            scrollFuncY.offset && removeContentOffset();\n            var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);\n            isTouch && y !== yClamped && (startScrollY += yClamped - y);\n            scrollFuncY(yClamped);\n        }\n        (dy || dx) && _updateAll();\n    };\n    vars.onEnable = function() {\n        _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n        ScrollTrigger.addEventListener(\"refresh\", onResize);\n        _addListener(_win, \"resize\", onResize);\n        if (scrollFuncY.smooth) {\n            scrollFuncY.target.style.scrollBehavior = \"auto\";\n            scrollFuncY.smooth = scrollFuncX.smooth = false;\n        }\n        inputObserver.enable();\n    };\n    vars.onDisable = function() {\n        _allowNativePanning(target, true);\n        _removeListener(_win, \"resize\", onResize);\n        ScrollTrigger.removeEventListener(\"refresh\", onResize);\n        inputObserver.kill();\n    };\n    vars.lockAxis = vars.lockAxis !== false;\n    self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n    _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\n    onStopDelayedCall = self._dc;\n    tween = gsap.to(self, {\n        ease: \"power4\",\n        paused: true,\n        inherit: false,\n        scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n        scrollY: \"+=0.1\",\n        modifiers: {\n            scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {\n                return tween.pause();\n            })\n        },\n        onUpdate: _updateAll,\n        onComplete: onStopDelayedCall.vars.onComplete\n    }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.\n    return self;\n};\nScrollTrigger.sort = function(func) {\n    if (_isFunction(func)) {\n        return _triggers.sort(func);\n    }\n    var scroll = _win.pageYOffset || 0;\n    ScrollTrigger.getAll().forEach(function(t) {\n        return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win.innerHeight;\n    });\n    return _triggers.sort(func || function(a, b) {\n        return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);\n    }); // anything with a containerAnimation should refresh last.\n};\nScrollTrigger.observe = function(vars) {\n    return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n};\nScrollTrigger.normalizeScroll = function(vars) {\n    if (typeof vars === \"undefined\") {\n        return _normalizer;\n    }\n    if (vars === true && _normalizer) {\n        return _normalizer.enable();\n    }\n    if (vars === false) {\n        _normalizer && _normalizer.kill();\n        _normalizer = vars;\n        return;\n    }\n    var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\n    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n    _isViewport(normalizer.target) && (_normalizer = normalizer);\n    return normalizer;\n};\nScrollTrigger.core = {\n    // smaller file size way to leverage in ScrollSmoother and Observer\n    _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\n    _inputObserver: _inputObserver,\n    _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\n    _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\n    bridge: {\n        // when normalizeScroll sets the scroll position (ss = setScroll)\n        ss: function ss() {\n            _lastScrollTime || _dispatch(\"scrollStart\");\n            _lastScrollTime = _getTime();\n        },\n        // a way to get the _refreshing value in Observer\n        ref: function ref() {\n            return _refreshing;\n        }\n    }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTQuMi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0FBT0EsR0FFQSxrQkFBa0IsR0FDa0k7QUFFcEosSUFBSVMsTUFDQUMsY0FDQUMsTUFDQUMsTUFDQUMsUUFDQUMsT0FDQUMsT0FDQUMsY0FDQUMsVUFDQUMsUUFDQUMsUUFDQUMsZUFDQUMsYUFDQUMsZ0JBQ0FDLGdCQUNBQyxJQUNBQyxZQUNBQyxhQUNBQyxjQUNBQyxPQUNBQyxxQkFDQUMsZUFDQUMsYUFDQUMscUJBQ0FDLG1CQUNBQyxrQkFDQUMsWUFDQUMsVUFDQUMsb0JBQ0FDLFdBQ0FDLFFBQ0FDLGFBQ0FDLGNBQ0FDLGlCQUNBLHVRQUF1UTtBQUMzUUMsV0FBVyxHQUNQQyxXQUFXQyxLQUFLQyxHQUFHLEVBQ25CQyxTQUFTSCxZQUNUSSxrQkFBa0IsR0FDbEJDLFdBQVcsR0FDWEMsY0FBYyxTQUFTQSxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUN0RCxJQUFJQyxRQUFRQyxVQUFVSixVQUFXQSxDQUFBQSxNQUFNSyxNQUFNLENBQUMsR0FBRyxPQUFPLFlBQVlMLE1BQU1NLE9BQU8sQ0FBQyxTQUFTLENBQUM7SUFDNUZKLElBQUksQ0FBQyxNQUFNRCxPQUFPLFFBQVEsR0FBR0U7SUFDN0IsT0FBT0EsUUFBUUgsTUFBTUssTUFBTSxDQUFDLEdBQUdMLE1BQU1PLE1BQU0sR0FBRyxLQUFLUDtBQUNyRCxHQUNJUSxhQUFhLFNBQVNBLFdBQVdSLEtBQUssRUFBRUcsS0FBSztJQUMvQyxPQUFPQSxTQUFVLEVBQUNDLFVBQVVKLFVBQVVBLE1BQU1LLE1BQU0sQ0FBQyxHQUFHLE9BQU8sUUFBTyxJQUFLLFdBQVdMLFFBQVEsTUFBTUE7QUFDcEcsR0FDSVMsYUFBYSxTQUFTQTtJQUN4QixPQUFPWCxZQUFZWSxzQkFBc0JEO0FBQzNDLEdB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SUFDeEVyTixlQUFlQSxZQUFZbVIsTUFBTSxLQUFLeWIsV0FBV3piLE1BQU0sSUFBSW5SLFlBQVk2SCxJQUFJO0lBQzNFbkYsWUFBWWtxQixXQUFXemIsTUFBTSxLQUFNblIsQ0FBQUEsY0FBYzRzQixVQUFTO0lBQzFELE9BQU9BO0FBQ1Q7QUFFQTVkLGNBQWNtRixJQUFJLEdBQUc7SUFDbkIsbUVBQW1FO0lBQ25FMVYsa0JBQWtCQSwwREFBZ0JBO0lBQ2xDbXBCLGdCQUFnQkE7SUFDaEJ2cEIsWUFBWUEsb0RBQVVBO0lBQ3RCQyxVQUFVQSxrREFBUUE7SUFDbEJ1dUIsUUFBUTtRQUNOLGlFQUFpRTtRQUNqRUMsSUFBSSxTQUFTQTtZQUNYN3JCLG1CQUFtQm9OLFVBQVU7WUFDN0JwTixrQkFBa0JKO1FBQ3BCO1FBQ0EsaURBQWlEO1FBQ2pEa3NCLEtBQUssU0FBU0E7WUFDWixPQUFPenRCO1FBQ1Q7SUFDRjtBQUNGO0FBQ0FpRCxjQUFjN0QsS0FBSytELGNBQWMsQ0FBQ3VNO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xNC4yL25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFRyaWdnZXIuanM/YzQxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFNjcm9sbFRyaWdnZXIgMy4xNC4yXG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBPYnNlcnZlciwgX2dldFRhcmdldCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX3Njcm9sbGVycywgX3Byb3hpZXMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfZ2V0VmVsb2NpdHlQcm9wIH0gZnJvbSBcIi4vT2JzZXJ2ZXIuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3Jvb3QsXG4gICAgX3Jlc2l6ZURlbGF5LFxuICAgIF90b0FycmF5LFxuICAgIF9jbGFtcCxcbiAgICBfdGltZTIsXG4gICAgX3N5bmNJbnRlcnZhbCxcbiAgICBfcmVmcmVzaGluZyxcbiAgICBfcG9pbnRlcklzRG93bixcbiAgICBfdHJhbnNmb3JtUHJvcCxcbiAgICBfaSxcbiAgICBfcHJldldpZHRoLFxuICAgIF9wcmV2SGVpZ2h0LFxuICAgIF9hdXRvUmVmcmVzaCxcbiAgICBfc29ydCxcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgIF9pZ25vcmVSZXNpemUsXG4gICAgX25vcm1hbGl6ZXIsXG4gICAgX2lnbm9yZU1vYmlsZVJlc2l6ZSxcbiAgICBfYmFzZVNjcmVlbkhlaWdodCxcbiAgICBfYmFzZVNjcmVlbldpZHRoLFxuICAgIF9maXhJT1NCdWcsXG4gICAgX2NvbnRleHQsXG4gICAgX3Njcm9sbFJlc3RvcmF0aW9uLFxuICAgIF9kaXYxMDB2aCxcbiAgICBfMTAwdmgsXG4gICAgX2lzUmV2ZXJ0ZWQsXG4gICAgX2NsYW1waW5nTWF4LFxuICAgIF9saW1pdENhbGxiYWNrcyxcbiAgICAvLyBpZiB0cnVlLCB3ZSdsbCBvbmx5IHRyaWdnZXIgY2FsbGJhY2tzIGlmIHRoZSBhY3RpdmUgc3RhdGUgdG9nZ2xlcywgc28gaWYgeW91IHNjcm9sbCBpbW1lZGlhdGVseSBwYXN0IGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIGEgU2Nyb2xsVHJpZ2dlciAodGh1cyBpbmFjdGl2ZSB0byBpbmFjdGl2ZSksIG5laXRoZXIgaXRzIG9uRW50ZXIgbm9yIG9uTGVhdmUgd2lsbCBiZSBjYWxsZWQuIFRoaXMgaXMgdXNlZnVsIGR1cmluZyBzdGFydHVwLlxuX3N0YXJ0dXAgPSAxLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgX3RpbWUxID0gX2dldFRpbWUoKSxcbiAgICBfbGFzdFNjcm9sbFRpbWUgPSAwLFxuICAgIF9lbmFibGVkID0gMCxcbiAgICBfcGFyc2VDbGFtcCA9IGZ1bmN0aW9uIF9wYXJzZUNsYW1wKHZhbHVlLCB0eXBlLCBzZWxmKSB7XG4gIHZhciBjbGFtcCA9IF9pc1N0cmluZyh2YWx1ZSkgJiYgKHZhbHVlLnN1YnN0cigwLCA2KSA9PT0gXCJjbGFtcChcIiB8fCB2YWx1ZS5pbmRleE9mKFwibWF4XCIpID4gLTEpO1xuICBzZWxmW1wiX1wiICsgdHlwZSArIFwiQ2xhbXBcIl0gPSBjbGFtcDtcbiAgcmV0dXJuIGNsYW1wID8gdmFsdWUuc3Vic3RyKDYsIHZhbHVlLmxlbmd0aCAtIDcpIDogdmFsdWU7XG59LFxuICAgIF9rZWVwQ2xhbXAgPSBmdW5jdGlvbiBfa2VlcENsYW1wKHZhbHVlLCBjbGFtcCkge1xuICByZXR1cm4gY2xhbXAgJiYgKCFfaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlLnN1YnN0cigwLCA2KSAhPT0gXCJjbGFtcChcIikgPyBcImNsYW1wKFwiICsgdmFsdWUgKyBcIilcIiA6IHZhbHVlO1xufSxcbiAgICBfcmFmQnVnRml4ID0gZnVuY3Rpb24gX3JhZkJ1Z0ZpeCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZShfcmFmQnVnRml4KTtcbn0sXG4gICAgLy8gaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSwgc2NyZWVuIHJlcGFpbnRzIHdlcmVuJ3QgY29uc2lzdGVudCB1bmxlc3Mgd2UgaGFkIFNPTUVUSElORyBxdWV1ZWQgdXAgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkhIFNvIHRoaXMganVzdCBjcmVhdGVzIGEgc3VwZXIgc2ltcGxlIGxvb3AgdG8ga2VlcCBpdCBhbGl2ZSBhbmQgc21vb3RoIG91dCByZXBhaW50cy5cbl9wb2ludGVyRG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfcG9pbnRlckRvd25IYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAxO1xufSxcbiAgICBfcG9pbnRlclVwSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyVXBIYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAwO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZSkge1xuICByZXR1cm4gISF+X3Jvb3QuaW5kZXhPZihlKTtcbn0sXG4gICAgX2dldFZpZXdwb3J0RGltZW5zaW9uID0gZnVuY3Rpb24gX2dldFZpZXdwb3J0RGltZW5zaW9uKGRpbWVuc2lvblByb3BlcnR5KSB7XG4gIHJldHVybiAoZGltZW5zaW9uUHJvcGVydHkgPT09IFwiSGVpZ2h0XCIgPyBfMTAwdmggOiBfd2luW1wiaW5uZXJcIiArIGRpbWVuc2lvblByb3BlcnR5XSkgfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGRpbWVuc2lvblByb3BlcnR5XTtcbn0sXG4gICAgX2dldEJvdW5kc0Z1bmMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSB7XG4gIHJldHVybiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IGZ1bmN0aW9uICgpIHtcbiAgICBfd2luT2Zmc2V0cy53aWR0aCA9IF93aW4uaW5uZXJXaWR0aDtcbiAgICBfd2luT2Zmc2V0cy5oZWlnaHQgPSBfMTAwdmg7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICB9KTtcbn0sXG4gICAgX2dldFNpemVGdW5jID0gZnVuY3Rpb24gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBfcmVmKSB7XG4gIHZhciBkID0gX3JlZi5kLFxuICAgICAgZDIgPSBfcmVmLmQyLFxuICAgICAgYSA9IF9yZWYuYTtcbiAgcmV0dXJuIChhID0gX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIikpID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhKClbZF07XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChpc1ZpZXdwb3J0ID8gX2dldFZpZXdwb3J0RGltZW5zaW9uKGQyKSA6IHNjcm9sbGVyW1wiY2xpZW50XCIgKyBkMl0pIHx8IDA7XG4gIH07XG59LFxuICAgIF9nZXRPZmZzZXRzRnVuYyA9IGZ1bmN0aW9uIF9nZXRPZmZzZXRzRnVuYyhlbGVtZW50LCBpc1ZpZXdwb3J0KSB7XG4gIHJldHVybiAhaXNWaWV3cG9ydCB8fCB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSA/IF9nZXRCb3VuZHNGdW5jKGVsZW1lbnQpIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfd2luT2Zmc2V0cztcbiAgfTtcbn0sXG4gICAgX21heFNjcm9sbCA9IGZ1bmN0aW9uIF9tYXhTY3JvbGwoZWxlbWVudCwgX3JlZjIpIHtcbiAgdmFyIHMgPSBfcmVmMi5zLFxuICAgICAgZDIgPSBfcmVmMi5kMixcbiAgICAgIGQgPSBfcmVmMi5kLFxuICAgICAgYSA9IF9yZWYyLmE7XG4gIHJldHVybiBNYXRoLm1heCgwLCAocyA9IFwic2Nyb2xsXCIgKyBkMikgJiYgKGEgPSBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHMpKSA/IGEoKSAtIF9nZXRCb3VuZHNGdW5jKGVsZW1lbnQpKClbZF0gOiBfaXNWaWV3cG9ydChlbGVtZW50KSA/IChfZG9jRWxbc10gfHwgX2JvZHlbc10pIC0gX2dldFZpZXdwb3J0RGltZW5zaW9uKGQyKSA6IGVsZW1lbnRbc10gLSBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0pO1xufSxcbiAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoID0gZnVuY3Rpb24gX2l0ZXJhdGVBdXRvUmVmcmVzaChmdW5jLCBldmVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXV0b1JlZnJlc2gubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2kgKyAxXSkpICYmIGZ1bmMoX2F1dG9SZWZyZXNoW2ldLCBfYXV0b1JlZnJlc2hbaSArIDFdLCBfYXV0b1JlZnJlc2hbaSArIDJdKTtcbiAgfVxufSxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2VuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCByZXZlcnNlZCwgcGF1c2UpIHtcbiAgcmV0dXJuIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocmV2ZXJzZWQgPyAwIDogMSkgJiYgcGF1c2UgJiYgYW5pbWF0aW9uLnBhdXNlKCk7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhzZWxmLCBmdW5jKSB7XG4gIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gc2VsZi5fY3R4ID8gc2VsZi5fY3R4LmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuYyhzZWxmKTtcbiAgICB9KSA6IGZ1bmMoc2VsZik7XG4gICAgcmVzdWx0ICYmIHJlc3VsdC50b3RhbFRpbWUgJiYgKHNlbGYuY2FsbGJhY2tBbmltYXRpb24gPSByZXN1bHQpO1xuICB9XG59LFxuICAgIF9hYnMgPSBNYXRoLmFicyxcbiAgICBfbGVmdCA9IFwibGVmdFwiLFxuICAgIF90b3AgPSBcInRvcFwiLFxuICAgIF9yaWdodCA9IFwicmlnaHRcIixcbiAgICBfYm90dG9tID0gXCJib3R0b21cIixcbiAgICBfd2lkdGggPSBcIndpZHRoXCIsXG4gICAgX2hlaWdodCA9IFwiaGVpZ2h0XCIsXG4gICAgX1JpZ2h0ID0gXCJSaWdodFwiLFxuICAgIF9MZWZ0ID0gXCJMZWZ0XCIsXG4gICAgX1RvcCA9IFwiVG9wXCIsXG4gICAgX0JvdHRvbSA9IFwiQm90dG9tXCIsXG4gICAgX3BhZGRpbmcgPSBcInBhZGRpbmdcIixcbiAgICBfbWFyZ2luID0gXCJtYXJnaW5cIixcbiAgICBfV2lkdGggPSBcIldpZHRoXCIsXG4gICAgX0hlaWdodCA9IFwiSGVpZ2h0XCIsXG4gICAgX3B4ID0gXCJweFwiLFxuICAgIF9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSxcbiAgICBfbWFrZVBvc2l0aW9uYWJsZSA9IGZ1bmN0aW9uIF9tYWtlUG9zaXRpb25hYmxlKGVsZW1lbnQpIHtcbiAgLy8gaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXMgcG9zaXRpb246IGFic29sdXRlIG9yIGZpeGVkLCBsZWF2ZSB0aGF0LCBvdGhlcndpc2UgbWFrZSBpdCBwb3NpdGlvbjogcmVsYXRpdmVcbiAgdmFyIHBvc2l0aW9uID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb247XG5cbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IHBvc2l0aW9uIDogXCJyZWxhdGl2ZVwiO1xufSxcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgcCBpbiBvYmogfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9nZXRCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzKGVsZW1lbnQsIHdpdGhvdXRUcmFuc2Zvcm1zKSB7XG4gIHZhciB0d2VlbiA9IHdpdGhvdXRUcmFuc2Zvcm1zICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW190cmFuc2Zvcm1Qcm9wXSAhPT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIiAmJiBnc2FwLnRvKGVsZW1lbnQsIHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgeFBlcmNlbnQ6IDAsXG4gICAgeVBlcmNlbnQ6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgcm90YXRpb25YOiAwLFxuICAgIHJvdGF0aW9uWTogMCxcbiAgICBzY2FsZTogMSxcbiAgICBza2V3WDogMCxcbiAgICBza2V3WTogMFxuICB9KS5wcm9ncmVzcygxKSxcbiAgICAgIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHR3ZWVuICYmIHR3ZWVuLnByb2dyZXNzKDApLmtpbGwoKTtcbiAgcmV0dXJuIGJvdW5kcztcbn0sXG4gICAgX2dldFNpemUgPSBmdW5jdGlvbiBfZ2V0U2l6ZShlbGVtZW50LCBfcmVmMykge1xuICB2YXIgZDIgPSBfcmVmMy5kMjtcbiAgcmV0dXJuIGVsZW1lbnRbXCJvZmZzZXRcIiArIGQyXSB8fCBlbGVtZW50W1wiY2xpZW50XCIgKyBkMl0gfHwgMDtcbn0sXG4gICAgX2dldExhYmVsUmF0aW9BcnJheSA9IGZ1bmN0aW9uIF9nZXRMYWJlbFJhdGlvQXJyYXkodGltZWxpbmUpIHtcbiAgdmFyIGEgPSBbXSxcbiAgICAgIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgIGR1cmF0aW9uID0gdGltZWxpbmUuZHVyYXRpb24oKSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGEucHVzaChsYWJlbHNbcF0gLyBkdXJhdGlvbik7XG4gIH1cblxuICByZXR1cm4gYTtcbn0sXG4gICAgX2dldENsb3Nlc3RMYWJlbCA9IGZ1bmN0aW9uIF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZ3NhcC51dGlscy5zbmFwKF9nZXRMYWJlbFJhdGlvQXJyYXkoYW5pbWF0aW9uKSwgdmFsdWUpO1xuICB9O1xufSxcbiAgICBfc25hcERpcmVjdGlvbmFsID0gZnVuY3Rpb24gX3NuYXBEaXJlY3Rpb25hbChzbmFwSW5jcmVtZW50T3JBcnJheSkge1xuICB2YXIgc25hcCA9IGdzYXAudXRpbHMuc25hcChzbmFwSW5jcmVtZW50T3JBcnJheSksXG4gICAgICBhID0gQXJyYXkuaXNBcnJheShzbmFwSW5jcmVtZW50T3JBcnJheSkgJiYgc25hcEluY3JlbWVudE9yQXJyYXkuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG4gIHJldHVybiBhID8gZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMWUtMztcbiAgICB9XG5cbiAgICB2YXIgaTtcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc25hcCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIHZhbHVlIC09IHRocmVzaG9sZDsgLy8gdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzLiBJZiB3ZSdyZSB0b28gc3RyaWN0LCBpdCBtaWdodCBzbmFwIGZvcndhcmQsIHRoZW4gaW1tZWRpYXRlbHkgYWdhaW4sIGFuZCBhZ2Fpbi5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gPj0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYVtpIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSBhLmxlbmd0aDtcbiAgICAgIHZhbHVlICs9IHRocmVzaG9sZDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYVtpXSA8PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBhW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFbMF07XG4gIH0gOiBmdW5jdGlvbiAodmFsdWUsIGRpcmVjdGlvbiwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxZS0zO1xuICAgIH1cblxuICAgIHZhciBzbmFwcGVkID0gc25hcCh2YWx1ZSk7XG4gICAgcmV0dXJuICFkaXJlY3Rpb24gfHwgTWF0aC5hYnMoc25hcHBlZCAtIHZhbHVlKSA8IHRocmVzaG9sZCB8fCBzbmFwcGVkIC0gdmFsdWUgPCAwID09PSBkaXJlY3Rpb24gPCAwID8gc25hcHBlZCA6IHNuYXAoZGlyZWN0aW9uIDwgMCA/IHZhbHVlIC0gc25hcEluY3JlbWVudE9yQXJyYXkgOiB2YWx1ZSArIHNuYXBJbmNyZW1lbnRPckFycmF5KTtcbiAgfTtcbn0sXG4gICAgX2dldExhYmVsQXREaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0TGFiZWxBdERpcmVjdGlvbih0aW1lbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xuICAgIHJldHVybiBfc25hcERpcmVjdGlvbmFsKF9nZXRMYWJlbFJhdGlvQXJyYXkodGltZWxpbmUpKSh2YWx1ZSwgc3QuZGlyZWN0aW9uKTtcbiAgfTtcbn0sXG4gICAgX211bHRpTGlzdGVuZXIgPSBmdW5jdGlvbiBfbXVsdGlMaXN0ZW5lcihmdW5jLCBlbGVtZW50LCB0eXBlcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHR5cGVzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmMoZWxlbWVudCwgdHlwZSwgY2FsbGJhY2spO1xuICB9KTtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIG5vblBhc3NpdmUsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7XG4gICAgcGFzc2l2ZTogIW5vblBhc3NpdmUsXG4gICAgY2FwdHVyZTogISFjYXB0dXJlXG4gIH0pO1xufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsICEhY2FwdHVyZSk7XG59LFxuICAgIF93aGVlbExpc3RlbmVyID0gZnVuY3Rpb24gX3doZWVsTGlzdGVuZXIoZnVuYywgZWwsIHNjcm9sbEZ1bmMpIHtcbiAgc2Nyb2xsRnVuYyA9IHNjcm9sbEZ1bmMgJiYgc2Nyb2xsRnVuYy53aGVlbEhhbmRsZXI7XG5cbiAgaWYgKHNjcm9sbEZ1bmMpIHtcbiAgICBmdW5jKGVsLCBcIndoZWVsXCIsIHNjcm9sbEZ1bmMpO1xuICAgIGZ1bmMoZWwsIFwidG91Y2htb3ZlXCIsIHNjcm9sbEZ1bmMpO1xuICB9XG59LFxuICAgIF9tYXJrZXJEZWZhdWx0cyA9IHtcbiAgc3RhcnRDb2xvcjogXCJncmVlblwiLFxuICBlbmRDb2xvcjogXCJyZWRcIixcbiAgaW5kZW50OiAwLFxuICBmb250U2l6ZTogXCIxNnB4XCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICB0b2dnbGVBY3Rpb25zOiBcInBsYXlcIixcbiAgYW50aWNpcGF0ZVBpbjogMFxufSxcbiAgICBfa2V5d29yZHMgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgY2VudGVyOiAwLjUsXG4gIGJvdHRvbTogMSxcbiAgcmlnaHQ6IDFcbn0sXG4gICAgX29mZnNldFRvUHggPSBmdW5jdGlvbiBfb2Zmc2V0VG9QeCh2YWx1ZSwgc2l6ZSkge1xuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBlcUluZGV4ID0gdmFsdWUuaW5kZXhPZihcIj1cIiksXG4gICAgICAgIHJlbGF0aXZlID0gfmVxSW5kZXggPyArKHZhbHVlLmNoYXJBdChlcUluZGV4IC0gMSkgKyAxKSAqIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKGVxSW5kZXggKyAxKSkgOiAwO1xuXG4gICAgaWYgKH5lcUluZGV4KSB7XG4gICAgICB2YWx1ZS5pbmRleE9mKFwiJVwiKSA+IGVxSW5kZXggJiYgKHJlbGF0aXZlICo9IHNpemUgLyAxMDApO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleCAtIDEpO1xuICAgIH1cblxuICAgIHZhbHVlID0gcmVsYXRpdmUgKyAodmFsdWUgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3ZhbHVlXSAqIHNpemUgOiB+dmFsdWUuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHZhbHVlKSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn0sXG4gICAgX2NyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIF9jcmVhdGVNYXJrZXIodHlwZSwgbmFtZSwgY29udGFpbmVyLCBkaXJlY3Rpb24sIF9yZWY0LCBvZmZzZXQsIG1hdGNoV2lkdGhFbCwgY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gIHZhciBzdGFydENvbG9yID0gX3JlZjQuc3RhcnRDb2xvcixcbiAgICAgIGVuZENvbG9yID0gX3JlZjQuZW5kQ29sb3IsXG4gICAgICBmb250U2l6ZSA9IF9yZWY0LmZvbnRTaXplLFxuICAgICAgaW5kZW50ID0gX3JlZjQuaW5kZW50LFxuICAgICAgZm9udFdlaWdodCA9IF9yZWY0LmZvbnRXZWlnaHQ7XG5cbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICB1c2VGaXhlZFBvc2l0aW9uID0gX2lzVmlld3BvcnQoY29udGFpbmVyKSB8fCBfZ2V0UHJveHlQcm9wKGNvbnRhaW5lciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG4gICAgICBpc1Njcm9sbGVyID0gdHlwZS5pbmRleE9mKFwic2Nyb2xsZXJcIikgIT09IC0xLFxuICAgICAgcGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxuICAgICAgaXNTdGFydCA9IHR5cGUuaW5kZXhPZihcInN0YXJ0XCIpICE9PSAtMSxcbiAgICAgIGNvbG9yID0gaXNTdGFydCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcixcbiAgICAgIGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xuXG4gIGNzcyArPSBcInBvc2l0aW9uOlwiICsgKChpc1Njcm9sbGVyIHx8IGNvbnRhaW5lckFuaW1hdGlvbikgJiYgdXNlRml4ZWRQb3NpdGlvbiA/IFwiZml4ZWQ7XCIgOiBcImFic29sdXRlO1wiKTtcbiAgKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uIHx8ICF1c2VGaXhlZFBvc2l0aW9uKSAmJiAoY3NzICs9IChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9yaWdodCA6IF9ib3R0b20pICsgXCI6XCIgKyAob2Zmc2V0ICsgcGFyc2VGbG9hdChpbmRlbnQpKSArIFwicHg7XCIpO1xuICBtYXRjaFdpZHRoRWwgJiYgKGNzcyArPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6XCIgKyBtYXRjaFdpZHRoRWwub2Zmc2V0V2lkdGggKyBcInB4O1wiKTtcbiAgZS5faXNTdGFydCA9IGlzU3RhcnQ7XG4gIGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJnc2FwLW1hcmtlci1cIiArIHR5cGUgKyAobmFtZSA/IFwiIG1hcmtlci1cIiArIG5hbWUgOiBcIlwiKSk7XG4gIGUuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgZS5pbm5lclRleHQgPSBuYW1lIHx8IG5hbWUgPT09IDAgPyB0eXBlICsgXCItXCIgKyBuYW1lIDogdHlwZTtcbiAgcGFyZW50LmNoaWxkcmVuWzBdID8gcGFyZW50Lmluc2VydEJlZm9yZShlLCBwYXJlbnQuY2hpbGRyZW5bMF0pIDogcGFyZW50LmFwcGVuZENoaWxkKGUpO1xuICBlLl9vZmZzZXQgPSBlW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuXG4gIF9wb3NpdGlvbk1hcmtlcihlLCAwLCBkaXJlY3Rpb24sIGlzU3RhcnQpO1xuXG4gIHJldHVybiBlO1xufSxcbiAgICBfcG9zaXRpb25NYXJrZXIgPSBmdW5jdGlvbiBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBzdGFydCwgZGlyZWN0aW9uLCBmbGlwcGVkKSB7XG4gIHZhciB2YXJzID0ge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICB9LFxuICAgICAgc2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJvczJcIiA6IFwicDJcIl0sXG4gICAgICBvcHBvc2l0ZVNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwicDJcIiA6IFwib3MyXCJdO1xuICBtYXJrZXIuX2lzRmxpcHBlZCA9IGZsaXBwZWQ7XG4gIHZhcnNbZGlyZWN0aW9uLmEgKyBcIlBlcmNlbnRcIl0gPSBmbGlwcGVkID8gLTEwMCA6IDA7XG4gIHZhcnNbZGlyZWN0aW9uLmFdID0gZmxpcHBlZCA/IFwiMXB4XCIgOiAwO1xuICB2YXJzW1wiYm9yZGVyXCIgKyBzaWRlICsgX1dpZHRoXSA9IDE7XG4gIHZhcnNbXCJib3JkZXJcIiArIG9wcG9zaXRlU2lkZSArIF9XaWR0aF0gPSAwO1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IHN0YXJ0ICsgXCJweFwiO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICBfdHJpZ2dlcnMgPSBbXSxcbiAgICBfaWRzID0ge30sXG4gICAgX3JhZklELFxuICAgIF9zeW5jID0gZnVuY3Rpb24gX3N5bmMoKSB7XG4gIHJldHVybiBfZ2V0VGltZSgpIC0gX2xhc3RTY3JvbGxUaW1lID4gMzQgJiYgKF9yYWZJRCB8fCAoX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF91cGRhdGVBbGwpKSk7XG59LFxuICAgIF9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgLy8gcHJldmlvdXNseSwgd2UgdHJpZWQgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgYnkgYmF0Y2hpbmcvZGVmZXJyaW5nIHRvIHRoZSBuZXh0IHJlcXVlc3RBbmltYXRpb25GcmFtZSgpLCBidXQgZGlzY292ZXJlZCB0aGF0IFNhZmFyaSBoYXMgYSBmZXcgYnVncyB0aGF0IG1ha2UgdGhpcyB1bndvcmthYmxlIChlc3BlY2lhbGx5IG9uIGlPUykuIFNlZSBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi8xNmM0MzViMTJlZjA5YzM4MTI1MjA0ODE4ZTdiNDVmYz9lZGl0b3JzPTAwMTAgYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0pqT3hZcFEvM2RkNjVjY2VjNWE2MGYxZDg2MmMzNTVkODRkMTQ1NjI/ZWRpdG9ycz0wMDEwIGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9FeGJyUE5hLzA4N2NlZjE5N2RjMzU0NDVhMDk1MWU4OTM1YzQxNTAzP2VkaXRvcnM9MDAxMFxuICBpZiAoIV9ub3JtYWxpemVyIHx8ICFfbm9ybWFsaXplci5pc1ByZXNzZWQgfHwgX25vcm1hbGl6ZXIuc3RhcnRYID4gX2JvZHkuY2xpZW50V2lkdGgpIHtcbiAgICAvLyBpZiB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgc2Nyb2xsYmFyLCBhbGxvdyBpdC5cbiAgICBfc2Nyb2xsZXJzLmNhY2hlKys7XG5cbiAgICBpZiAoX25vcm1hbGl6ZXIpIHtcbiAgICAgIF9yYWZJRCB8fCAoX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF91cGRhdGVBbGwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3VwZGF0ZUFsbCgpOyAvLyBTYWZhcmkgaW4gcGFydGljdWxhciAob24gZGVza3RvcCkgTkVFRFMgdGhlIGltbWVkaWF0ZSB1cGRhdGUgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB3aGVyZWFzIGlPUyBzZWVtcyB0byBiZW5lZml0IGZyb20gd2FpdGluZyBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHRpY2ssIGF0IGxlYXN0IHdoZW4gbm9ybWFsaXppbmcuIFNlZSBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9xQllvenFPP2VkaXRvcnM9MDExMFxuXG4gICAgfVxuXG4gICAgX2xhc3RTY3JvbGxUaW1lIHx8IF9kaXNwYXRjaChcInNjcm9sbFN0YXJ0XCIpO1xuICAgIF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG4gIH1cbn0sXG4gICAgX3NldEJhc2VEaW1lbnNpb25zID0gZnVuY3Rpb24gX3NldEJhc2VEaW1lbnNpb25zKCkge1xuICBfYmFzZVNjcmVlbldpZHRoID0gX3dpbi5pbm5lcldpZHRoO1xuICBfYmFzZVNjcmVlbkhlaWdodCA9IF93aW4uaW5uZXJIZWlnaHQ7XG59LFxuICAgIF9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZShmb3JjZSkge1xuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gIChmb3JjZSA9PT0gdHJ1ZSB8fCAhX3JlZnJlc2hpbmcgJiYgIV9pZ25vcmVSZXNpemUgJiYgIV9kb2MuZnVsbHNjcmVlbkVsZW1lbnQgJiYgIV9kb2Mud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgJiYgKCFfaWdub3JlTW9iaWxlUmVzaXplIHx8IF9iYXNlU2NyZWVuV2lkdGggIT09IF93aW4uaW5uZXJXaWR0aCB8fCBNYXRoLmFicyhfd2luLmlubmVySGVpZ2h0IC0gX2Jhc2VTY3JlZW5IZWlnaHQpID4gX3dpbi5pbm5lckhlaWdodCAqIDAuMjUpKSAmJiBfcmVzaXplRGVsYXkucmVzdGFydCh0cnVlKTtcbn0sXG4gICAgLy8gaWdub3JlIHJlc2l6ZXMgdHJpZ2dlcmVkIGJ5IHJlZnJlc2goKVxuX2xpc3RlbmVycyA9IHt9LFxuICAgIF9lbXB0eUFycmF5ID0gW10sXG4gICAgX3NvZnRSZWZyZXNoID0gZnVuY3Rpb24gX3NvZnRSZWZyZXNoKCkge1xuICByZXR1cm4gX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCkgfHwgX3JlZnJlc2hBbGwodHJ1ZSk7XG59LFxuICAgIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIF9kaXNwYXRjaCh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzW3R5cGVdICYmIF9saXN0ZW5lcnNbdHlwZV0ubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfSkgfHwgX2VtcHR5QXJyYXk7XG59LFxuICAgIF9zYXZlZFN0eWxlcyA9IFtdLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzKCkgaXMgY2FsbGVkLCB0aGUgaW5saW5lIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gdGhpcyBBcnJheSBpbiBhIHNlcXVlbnRpYWwgZm9ybWF0IGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIGdzQ2FjaGUsIG1lZGlhXS4gVGhpcyBrZWVwcyBpdCB2ZXJ5IG1lbW9yeS1lZmZpY2llbnQgYW5kIGZhc3QgdG8gaXRlcmF0ZSB0aHJvdWdoLlxuX3JldmVydFJlY29yZGVkID0gZnVuY3Rpb24gX3JldmVydFJlY29yZGVkKG1lZGlhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSArPSA1KSB7XG4gICAgaWYgKCFtZWRpYSB8fCBfc2F2ZWRTdHlsZXNbaSArIDRdICYmIF9zYXZlZFN0eWxlc1tpICsgNF0ucXVlcnkgPT09IG1lZGlhKSB7XG4gICAgICBfc2F2ZWRTdHlsZXNbaV0uc3R5bGUuY3NzVGV4dCA9IF9zYXZlZFN0eWxlc1tpICsgMV07XG4gICAgICBfc2F2ZWRTdHlsZXNbaV0uZ2V0QkJveCAmJiBfc2F2ZWRTdHlsZXNbaV0uc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIF9zYXZlZFN0eWxlc1tpICsgMl0gfHwgXCJcIik7XG4gICAgICBfc2F2ZWRTdHlsZXNbaSArIDNdLnVuY2FjaGUgPSAxO1xuICAgIH1cbiAgfVxufSxcbiAgICBfcmVjb3JkU2Nyb2xsUG9zaXRpb25zID0gZnVuY3Rpb24gX3JlY29yZFNjcm9sbFBvc2l0aW9ucygpIHtcbiAgcmV0dXJuIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKG9iaikgJiYgKytvYmouY2FjaGVJRCAmJiAob2JqLnJlYyA9IG9iaigpKTtcbiAgfSk7XG59LFxuICAgIC8vIHJlY29yZCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24uIEFsc28gZm9yY2UgdGhlIGNsZWFyaW5nIG9mIHRoZSBjYWNoZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGFrZSBhIGxpdHRsZSB3aGlsZSB0byBkaXNwYXRjaCB0aGUgXCJzY3JvbGxcIiBldmVudCBhbmQgdGhlIHVzZXIgbWF5IGhhdmUgY2hhbmdlZCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGVuIGNhbGxlZCBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSByaWdodCBhd2F5XG5fcmV2ZXJ0QWxsID0gZnVuY3Rpb24gX3JldmVydEFsbChraWxsLCBtZWRpYSkge1xuICB2YXIgdHJpZ2dlcjtcblxuICBmb3IgKF9pID0gMDsgX2kgPCBfdHJpZ2dlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdHJpZ2dlciA9IF90cmlnZ2Vyc1tfaV07XG5cbiAgICBpZiAodHJpZ2dlciAmJiAoIW1lZGlhIHx8IHRyaWdnZXIuX2N0eCA9PT0gbWVkaWEpKSB7XG4gICAgICBpZiAoa2lsbCkge1xuICAgICAgICB0cmlnZ2VyLmtpbGwoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlnZ2VyLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaXNSZXZlcnRlZCA9IHRydWU7XG4gIG1lZGlhICYmIF9yZXZlcnRSZWNvcmRlZChtZWRpYSk7XG4gIG1lZGlhIHx8IF9kaXNwYXRjaChcInJldmVydFwiKTtcbn0sXG4gICAgX2NsZWFyU2Nyb2xsTWVtb3J5ID0gZnVuY3Rpb24gX2NsZWFyU2Nyb2xsTWVtb3J5KHNjcm9sbFJlc3RvcmF0aW9uLCBmb3JjZSkge1xuICAvLyB6ZXJvLW91dCBhbGwgdGhlIHJlY29yZGVkIHNjcm9sbCBwb3NpdGlvbnMuIERvbid0IHVzZSBfdHJpZ2dlcnMgYmVjYXVzZSBpZiwgZm9yIGV4YW1wbGUsIC5tYXRjaE1lZGlhKCkgaXMgdXNlZCB0byBjcmVhdGUgc29tZSBTY3JvbGxUcmlnZ2VycyBhbmQgdGhlbiB0aGUgdXNlciByZXNpemVzIGFuZCBpdCByZW1vdmVzIEFMTCBTY3JvbGxUcmlnZ2VycywgYW5kIHRoZW4gZ28gYmFjayB0byBhIHNpemUgd2hlcmUgdGhlcmUgYXJlIFNjcm9sbFRyaWdnZXJzLCBpdCB3b3VsZCBoYXZlIGtlcHQgdGhlIHBvc2l0aW9uKHMpIHNhdmVkIGZyb20gdGhlIGluaXRpYWwgc3RhdGUuXG4gIF9zY3JvbGxlcnMuY2FjaGUrKztcbiAgKGZvcmNlIHx8ICFfcmVmcmVzaGluZ0FsbCkgJiYgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gX2lzRnVuY3Rpb24ob2JqKSAmJiBvYmouY2FjaGVJRCsrICYmIChvYmoucmVjID0gMCk7XG4gIH0pO1xuICBfaXNTdHJpbmcoc2Nyb2xsUmVzdG9yYXRpb24pICYmIChfd2luLmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBfc2Nyb2xsUmVzdG9yYXRpb24gPSBzY3JvbGxSZXN0b3JhdGlvbik7XG59LFxuICAgIF9yZWZyZXNoaW5nQWxsLFxuICAgIF9yZWZyZXNoSUQgPSAwLFxuICAgIF9xdWV1ZVJlZnJlc2hJRCxcbiAgICBfcXVldWVSZWZyZXNoQWxsID0gZnVuY3Rpb24gX3F1ZXVlUmVmcmVzaEFsbCgpIHtcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWxsIF9yZWZyZXNoQWxsKCkgZXZlcnkgdGltZSB3ZSBjcmVhdGUgYSBuZXcgU2Nyb2xsVHJpZ2dlciAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIC0gaXQncyBiZXR0ZXIgdG8gYmF0Y2ggdGhlbS4gU29tZSBmcmFtZXdvcmtzIGR5bmFtaWNhbGx5IGxvYWQgY29udGVudCBhbmQgd2UgY2FuJ3QgcmVseSBvbiB0aGUgd2luZG93J3MgXCJsb2FkXCIgb3IgXCJET01Db250ZW50TG9hZGVkXCIgZXZlbnRzIHRvIHRyaWdnZXIgaXQuXG4gIGlmIChfcXVldWVSZWZyZXNoSUQgIT09IF9yZWZyZXNoSUQpIHtcbiAgICB2YXIgaWQgPSBfcXVldWVSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWQgPT09IF9yZWZyZXNoSUQgJiYgX3JlZnJlc2hBbGwodHJ1ZSk7XG4gICAgfSk7XG4gIH1cbn0sXG4gICAgX3JlZnJlc2gxMDB2aCA9IGZ1bmN0aW9uIF9yZWZyZXNoMTAwdmgoKSB7XG4gIF9ib2R5LmFwcGVuZENoaWxkKF9kaXYxMDB2aCk7XG5cbiAgXzEwMHZoID0gIV9ub3JtYWxpemVyICYmIF9kaXYxMDB2aC5vZmZzZXRIZWlnaHQgfHwgX3dpbi5pbm5lckhlaWdodDtcblxuICBfYm9keS5yZW1vdmVDaGlsZChfZGl2MTAwdmgpO1xufSxcbiAgICBfaGlkZUFsbE1hcmtlcnMgPSBmdW5jdGlvbiBfaGlkZUFsbE1hcmtlcnMoaGlkZSkge1xuICByZXR1cm4gX3RvQXJyYXkoXCIuZ3NhcC1tYXJrZXItc3RhcnQsIC5nc2FwLW1hcmtlci1lbmQsIC5nc2FwLW1hcmtlci1zY3JvbGxlci1zdGFydCwgLmdzYXAtbWFya2VyLXNjcm9sbGVyLWVuZFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5zdHlsZS5kaXNwbGF5ID0gaGlkZSA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xuICB9KTtcbn0sXG4gICAgX3JlZnJlc2hBbGwgPSBmdW5jdGlvbiBfcmVmcmVzaEFsbChmb3JjZSwgc2tpcFJldmVydCkge1xuICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDsgLy8gc29tZSBmcmFtZXdvcmtzIGxpa2UgQXN0cm8gbWF5IGNhY2hlIHRoZSA8Ym9keT4gYW5kIHJlcGxhY2UgaXQgZHVyaW5nIHJvdXRpbmcsIHNvIHdlJ2xsIGp1c3QgcmUtcmVjb3JkIHRoZSBfZG9jRWwgYW5kIF9ib2R5IGZvciBzYWZldHkgKG90aGVyd2lzZSwgdGhlIG1hcmtlcnMgbWF5IG5vdCBnZXQgYWRkZWQgcHJvcGVybHkpLlxuXG4gIF9ib2R5ID0gX2RvYy5ib2R5O1xuICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcblxuICBpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFmb3JjZSAmJiAhX2lzUmV2ZXJ0ZWQpIHtcbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIF9yZWZyZXNoMTAwdmgoKTtcblxuICBfcmVmcmVzaGluZ0FsbCA9IFNjcm9sbFRyaWdnZXIuaXNSZWZyZXNoaW5nID0gdHJ1ZTtcbiAgX2lzUmV2ZXJ0ZWQgfHwgX3JlY29yZFNjcm9sbFBvc2l0aW9ucygpO1xuXG4gIHZhciByZWZyZXNoSW5pdHMgPSBfZGlzcGF0Y2goXCJyZWZyZXNoSW5pdFwiKTtcblxuICBfc29ydCAmJiBTY3JvbGxUcmlnZ2VyLnNvcnQoKTtcbiAgc2tpcFJldmVydCB8fCBfcmV2ZXJ0QWxsKCk7XG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoX2lzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgb2JqLnNtb290aCAmJiAob2JqLnRhcmdldC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiKTsgLy8gc21vb3RoIHNjcm9sbGluZyBpbnRlcmZlcmVzXG5cbiAgICAgIG9iaigwKTtcbiAgICB9XG4gIH0pO1xuXG4gIF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQucmVmcmVzaCgpO1xuICB9KTsgLy8gZG9uJ3QgbG9vcCB3aXRoIF9pIGJlY2F1c2UgZHVyaW5nIGEgcmVmcmVzaCgpIHNvbWVvbmUgY291bGQgY2FsbCBTY3JvbGxUcmlnZ2VyLnVwZGF0ZSgpIHdoaWNoIHdvdWxkIGl0ZXJhdGUgdGhyb3VnaCBfaSByZXN1bHRpbmcgaW4gYSBza2lwLlxuXG5cbiAgX2lzUmV2ZXJ0ZWQgPSBmYWxzZTtcblxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIC8vIG5lc3RlZCBwaW5zIChwaW5uZWRDb250YWluZXIpIHdpdGggcGluU3BhY2luZyBtYXkgZXhwYW5kIHRoZSBjb250YWluZXIsIHNvIHdlIG11c3QgYWNjb21tb2RhdGUgdGhhdCBoZXJlLlxuICAgIGlmICh0Ll9zdWJQaW5PZmZzZXQgJiYgdC5waW4pIHtcbiAgICAgIHZhciBwcm9wID0gdC52YXJzLmhvcml6b250YWwgPyBcIm9mZnNldFdpZHRoXCIgOiBcIm9mZnNldEhlaWdodFwiLFxuICAgICAgICAgIG9yaWdpbmFsID0gdC5waW5bcHJvcF07XG4gICAgICB0LnJldmVydCh0cnVlLCAxKTtcbiAgICAgIHQuYWRqdXN0UGluU3BhY2luZyh0LnBpbltwcm9wXSAtIG9yaWdpbmFsKTtcbiAgICAgIHQucmVmcmVzaCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgX2NsYW1waW5nTWF4ID0gMTsgLy8gcGluU3BhY2luZyBtaWdodCBiZSBwcm9wcGluZyBhIHBhZ2Ugb3BlbiwgdGh1cyB3aGVuIHdlIC5zZXRQb3NpdGlvbnMoKSB0byBjbGFtcCBhIFNjcm9sbFRyaWdnZXIncyBlbmQgd2Ugc2hvdWxkIGxlYXZlIHRoZSBwaW5TcGFjaW5nIGFsb25lLiBUaGF0J3Mgd2hhdCB0aGlzIGZsYWcgaXMgZm9yLlxuXG4gIF9oaWRlQWxsTWFya2Vycyh0cnVlKTtcblxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIC8vIHRoZSBzY3JvbGxlcidzIG1heCBzY3JvbGwgcG9zaXRpb24gbWF5IGNoYW5nZSBhZnRlciBhbGwgdGhlIFNjcm9sbFRyaWdnZXJzIHJlZnJlc2hlZCAobGlrZSBwaW5uaW5nIGNvdWxkIHB1c2ggaXQgZG93biksIHNvIHdlIG5lZWQgdG8gbG9vcCBiYWNrIGFuZCBjb3JyZWN0IGFueSB3aXRoIGVuZDogXCJtYXhcIi4gU2FtZSBmb3IgYW55dGhpbmcgd2l0aCBhIGNsYW1wZWQgZW5kXG4gICAgdmFyIG1heCA9IF9tYXhTY3JvbGwodC5zY3JvbGxlciwgdC5fZGlyKSxcbiAgICAgICAgZW5kQ2xhbXAgPSB0LnZhcnMuZW5kID09PSBcIm1heFwiIHx8IHQuX2VuZENsYW1wICYmIHQuZW5kID4gbWF4LFxuICAgICAgICBzdGFydENsYW1wID0gdC5fc3RhcnRDbGFtcCAmJiB0LnN0YXJ0ID49IG1heDtcblxuICAgIChlbmRDbGFtcCB8fCBzdGFydENsYW1wKSAmJiB0LnNldFBvc2l0aW9ucyhzdGFydENsYW1wID8gbWF4IC0gMSA6IHQuc3RhcnQsIGVuZENsYW1wID8gTWF0aC5tYXgoc3RhcnRDbGFtcCA/IG1heCA6IHQuc3RhcnQgKyAxLCBtYXgpIDogdC5lbmQsIHRydWUpO1xuICB9KTtcblxuICBfaGlkZUFsbE1hcmtlcnMoZmFsc2UpO1xuXG4gIF9jbGFtcGluZ01heCA9IDA7XG4gIHJlZnJlc2hJbml0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC5yZW5kZXIgJiYgcmVzdWx0LnJlbmRlcigtMSk7XG4gIH0pOyAvLyBpZiB0aGUgb25SZWZyZXNoSW5pdCgpIHJldHVybnMgYW4gYW5pbWF0aW9uICh0eXBpY2FsbHkgYSBnc2FwLnNldCgpKSwgcmV2ZXJ0IGl0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gcHV0IHRoaW5ncyBpbiBhIGNlcnRhaW4gc3BvdCBiZWZvcmUgcmVmcmVzaGluZyBmb3IgbWVhc3VyZW1lbnQgcHVycG9zZXMsIGFuZCB0aGVuIHB1dCB0aGluZ3MgYmFjay5cblxuICBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChfaXNGdW5jdGlvbihvYmopKSB7XG4gICAgICBvYmouc21vb3RoICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYmoudGFyZ2V0LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJzbW9vdGhcIjtcbiAgICAgIH0pO1xuICAgICAgb2JqLnJlYyAmJiBvYmoob2JqLnJlYyk7XG4gICAgfVxuICB9KTtcblxuICBfY2xlYXJTY3JvbGxNZW1vcnkoX3Njcm9sbFJlc3RvcmF0aW9uLCAxKTtcblxuICBfcmVzaXplRGVsYXkucGF1c2UoKTtcblxuICBfcmVmcmVzaElEKys7XG4gIF9yZWZyZXNoaW5nQWxsID0gMjtcblxuICBfdXBkYXRlQWxsKDIpO1xuXG4gIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKHQudmFycy5vblJlZnJlc2gpICYmIHQudmFycy5vblJlZnJlc2godCk7XG4gIH0pO1xuXG4gIF9yZWZyZXNoaW5nQWxsID0gU2Nyb2xsVHJpZ2dlci5pc1JlZnJlc2hpbmcgPSBmYWxzZTtcblxuICBfZGlzcGF0Y2goXCJyZWZyZXNoXCIpO1xufSxcbiAgICBfbGFzdFNjcm9sbCA9IDAsXG4gICAgX2RpcmVjdGlvbiA9IDEsXG4gICAgX3ByaW1hcnksXG4gICAgX3VwZGF0ZUFsbCA9IGZ1bmN0aW9uIF91cGRhdGVBbGwoZm9yY2UpIHtcbiAgaWYgKGZvcmNlID09PSAyIHx8ICFfcmVmcmVzaGluZ0FsbCAmJiAhX2lzUmV2ZXJ0ZWQpIHtcbiAgICAvLyBfaXNSZXZlcnRlZCBjb3VsZCBiZSB0cnVlIGlmLCBmb3IgZXhhbXBsZSwgYSBtYXRjaE1lZGlhKCkgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgZXhlY3V0aW5nLiBXZSBkb24ndCB3YW50IHRvIHVwZGF0ZSBkdXJpbmcgdGhlIHRpbWUgZXZlcnl0aGluZyBpcyByZXZlcnRlZC5cbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgIF9wcmltYXJ5ICYmIF9wcmltYXJ5LnVwZGF0ZSgwKTsgLy8gU2Nyb2xsU21vb3RoZXIgdXNlcyByZWZyZXNoUHJpb3JpdHkgLTk5OTkgdG8gYmVjb21lIHRoZSBwcmltYXJ5IHRoYXQgZ2V0cyB1cGRhdGVkIGJlZm9yZSBhbGwgb3RoZXJzIGJlY2F1c2UgaXQgYWZmZWN0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuXG4gICAgdmFyIGwgPSBfdHJpZ2dlcnMubGVuZ3RoLFxuICAgICAgICB0aW1lID0gX2dldFRpbWUoKSxcbiAgICAgICAgcmVjb3JkVmVsb2NpdHkgPSB0aW1lIC0gX3RpbWUxID49IDUwLFxuICAgICAgICBzY3JvbGwgPSBsICYmIF90cmlnZ2Vyc1swXS5zY3JvbGwoKTtcblxuICAgIF9kaXJlY3Rpb24gPSBfbGFzdFNjcm9sbCA+IHNjcm9sbCA/IC0xIDogMTtcbiAgICBfcmVmcmVzaGluZ0FsbCB8fCAoX2xhc3RTY3JvbGwgPSBzY3JvbGwpO1xuXG4gICAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XG4gICAgICBpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFfcG9pbnRlcklzRG93biAmJiB0aW1lIC0gX2xhc3RTY3JvbGxUaW1lID4gMjAwKSB7XG4gICAgICAgIF9sYXN0U2Nyb2xsVGltZSA9IDA7XG5cbiAgICAgICAgX2Rpc3BhdGNoKFwic2Nyb2xsRW5kXCIpO1xuICAgICAgfVxuXG4gICAgICBfdGltZTIgPSBfdGltZTE7XG4gICAgICBfdGltZTEgPSB0aW1lO1xuICAgIH1cblxuICAgIGlmIChfZGlyZWN0aW9uIDwgMCkge1xuICAgICAgX2kgPSBsO1xuXG4gICAgICB3aGlsZSAoX2ktLSA+IDApIHtcbiAgICAgICAgX3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIF9kaXJlY3Rpb24gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBsOyBfaSsrKSB7XG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFNjcm9sbFRyaWdnZXIuaXNVcGRhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgX3JhZklEID0gMDtcbn0sXG4gICAgX3Byb3BOYW1lc1RvQ29weSA9IFtfbGVmdCwgX3RvcCwgX2JvdHRvbSwgX3JpZ2h0LCBfbWFyZ2luICsgX0JvdHRvbSwgX21hcmdpbiArIF9SaWdodCwgX21hcmdpbiArIF9Ub3AsIF9tYXJnaW4gKyBfTGVmdCwgXCJkaXNwbGF5XCIsIFwiZmxleFNocmlua1wiLCBcImZsb2F0XCIsIFwiekluZGV4XCIsIFwiZ3JpZENvbHVtblN0YXJ0XCIsIFwiZ3JpZENvbHVtbkVuZFwiLCBcImdyaWRSb3dTdGFydFwiLCBcImdyaWRSb3dFbmRcIiwgXCJncmlkQXJlYVwiLCBcImp1c3RpZnlTZWxmXCIsIFwiYWxpZ25TZWxmXCIsIFwicGxhY2VTZWxmXCIsIFwib3JkZXJcIl0sXG4gICAgX3N0YXRlUHJvcHMgPSBfcHJvcE5hbWVzVG9Db3B5LmNvbmNhdChbX3dpZHRoLCBfaGVpZ2h0LCBcImJveFNpemluZ1wiLCBcIm1heFwiICsgX1dpZHRoLCBcIm1heFwiICsgX0hlaWdodCwgXCJwb3NpdGlvblwiLCBfbWFyZ2luLCBfcGFkZGluZywgX3BhZGRpbmcgKyBfVG9wLCBfcGFkZGluZyArIF9SaWdodCwgX3BhZGRpbmcgKyBfQm90dG9tLCBfcGFkZGluZyArIF9MZWZ0XSksXG4gICAgX3N3YXBQaW5PdXQgPSBmdW5jdGlvbiBfc3dhcFBpbk91dChwaW4sIHNwYWNlciwgc3RhdGUpIHtcbiAgX3NldFN0YXRlKHN0YXRlKTtcblxuICB2YXIgY2FjaGUgPSBwaW4uX2dzYXA7XG5cbiAgaWYgKGNhY2hlLnNwYWNlcklzTmF0aXZlKSB7XG4gICAgX3NldFN0YXRlKGNhY2hlLnNwYWNlclN0YXRlKTtcbiAgfSBlbHNlIGlmIChwaW4uX2dzYXAuc3dhcHBlZEluKSB7XG4gICAgdmFyIHBhcmVudCA9IHNwYWNlci5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShwaW4sIHNwYWNlcik7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoc3BhY2VyKTtcbiAgICB9XG4gIH1cblxuICBwaW4uX2dzYXAuc3dhcHBlZEluID0gZmFsc2U7XG59LFxuICAgIF9zd2FwUGluSW4gPSBmdW5jdGlvbiBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBjcywgc3BhY2VyU3RhdGUpIHtcbiAgaWYgKCFwaW4uX2dzYXAuc3dhcHBlZEluKSB7XG4gICAgdmFyIGkgPSBfcHJvcE5hbWVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgc3BhY2VyU3R5bGUgPSBzcGFjZXIuc3R5bGUsXG4gICAgICAgIHBpblN0eWxlID0gcGluLnN0eWxlLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcCA9IF9wcm9wTmFtZXNUb0NvcHlbaV07XG4gICAgICBzcGFjZXJTdHlsZVtwXSA9IGNzW3BdO1xuICAgIH1cblxuICAgIHNwYWNlclN0eWxlLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcbiAgICBjcy5kaXNwbGF5ID09PSBcImlubGluZVwiICYmIChzcGFjZXJTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgcGluU3R5bGVbX2JvdHRvbV0gPSBwaW5TdHlsZVtfcmlnaHRdID0gXCJhdXRvXCI7XG4gICAgc3BhY2VyU3R5bGUuZmxleEJhc2lzID0gY3MuZmxleEJhc2lzIHx8IFwiYXV0b1wiO1xuICAgIHNwYWNlclN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgc3BhY2VyU3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XG4gICAgc3BhY2VyU3R5bGVbX3dpZHRoXSA9IF9nZXRTaXplKHBpbiwgX2hvcml6b250YWwpICsgX3B4O1xuICAgIHNwYWNlclN0eWxlW19oZWlnaHRdID0gX2dldFNpemUocGluLCBfdmVydGljYWwpICsgX3B4O1xuICAgIHNwYWNlclN0eWxlW19wYWRkaW5nXSA9IHBpblN0eWxlW19tYXJnaW5dID0gcGluU3R5bGVbX3RvcF0gPSBwaW5TdHlsZVtfbGVmdF0gPSBcIjBcIjtcblxuICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG5cbiAgICBwaW5TdHlsZVtfd2lkdGhdID0gcGluU3R5bGVbXCJtYXhcIiArIF9XaWR0aF0gPSBjc1tfd2lkdGhdO1xuICAgIHBpblN0eWxlW19oZWlnaHRdID0gcGluU3R5bGVbXCJtYXhcIiArIF9IZWlnaHRdID0gY3NbX2hlaWdodF07XG4gICAgcGluU3R5bGVbX3BhZGRpbmddID0gY3NbX3BhZGRpbmddO1xuXG4gICAgaWYgKHBpbi5wYXJlbnROb2RlICE9PSBzcGFjZXIpIHtcbiAgICAgIHBpbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzcGFjZXIsIHBpbik7XG4gICAgICBzcGFjZXIuYXBwZW5kQ2hpbGQocGluKTtcbiAgICB9XG5cbiAgICBwaW4uX2dzYXAuc3dhcHBlZEluID0gdHJ1ZTtcbiAgfVxufSxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX3NldFN0YXRlID0gZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnQuc3R5bGUsXG4gICAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBwLFxuICAgICAgICB2YWx1ZTtcbiAgICAoc3RhdGUudC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUoc3RhdGUudCkpLnVuY2FjaGUgPSAxOyAvLyBvdGhlcndpc2UgdHJhbnNmb3JtcyBtYXkgYmUgb2ZmXG5cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgdmFsdWUgPSBzdGF0ZVtpICsgMV07XG4gICAgICBwID0gc3RhdGVbaV07XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHlsZVtwXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVtwXSkge1xuICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0U3RhdGUgPSBmdW5jdGlvbiBfZ2V0U3RhdGUoZWxlbWVudCkge1xuICAvLyByZXR1cm5zIGFuIEFycmF5IHdpdGggYWx0ZXJuYXRpbmcgdmFsdWVzIGxpa2UgW3Byb3BlcnR5LCB2YWx1ZSwgcHJvcGVydHksIHZhbHVlXSBhbmQgYSBcInRcIiBwcm9wZXJ0eSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IChlbGVtZW50KS4gTWFrZXMgaXQgZmFzdCBhbmQgY2hlYXAuXG4gIHZhciBsID0gX3N0YXRlUHJvcHMubGVuZ3RoLFxuICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgc3RhdGUgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3RhdGUucHVzaChfc3RhdGVQcm9wc1tpXSwgc3R5bGVbX3N0YXRlUHJvcHNbaV1dKTtcbiAgfVxuXG4gIHN0YXRlLnQgPSBlbGVtZW50O1xuICByZXR1cm4gc3RhdGU7XG59LFxuICAgIF9jb3B5U3RhdGUgPSBmdW5jdGlvbiBfY29weVN0YXRlKHN0YXRlLCBvdmVycmlkZSwgb21pdE9mZnNldHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgbCA9IHN0YXRlLmxlbmd0aCxcbiAgICAgIGkgPSBvbWl0T2Zmc2V0cyA/IDggOiAwLFxuICAgICAgLy8gc2tpcCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gaWYgb21pdE9mZnNldHMgaXMgdHJ1ZVxuICBwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcCA9IHN0YXRlW2ldO1xuICAgIHJlc3VsdC5wdXNoKHAsIHAgaW4gb3ZlcnJpZGUgPyBvdmVycmlkZVtwXSA6IHN0YXRlW2kgKyAxXSk7XG4gIH1cblxuICByZXN1bHQudCA9IHN0YXRlLnQ7XG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF93aW5PZmZzZXRzID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDBcbn0sXG4gICAgLy8gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlICg/KSBBbGxvdyB1c2VycyB0byBjYWxjdWxhdGUgd2hlcmUgYSB0cmlnZ2VyIGhpdHMgKHNjcm9sbCBwb3NpdGlvbikgbGlrZSBnZXRTY3JvbGxQb3NpdGlvbihcIiNpZFwiLCBcInRvcCBib3R0b21cIilcbi8vIF9nZXRTY3JvbGxQb3NpdGlvbiA9ICh0cmlnZ2VyLCBwb3NpdGlvbiwge3Njcm9sbGVyLCBjb250YWluZXJBbmltYXRpb24sIGhvcml6b250YWx9KSA9PiB7XG4vLyBcdHNjcm9sbGVyID0gX2dldFRhcmdldChzY3JvbGxlciB8fCBfd2luKTtcbi8vIFx0bGV0IGRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbi8vIFx0XHRpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpO1xuLy8gXHRfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbik7XG4vLyBcdHJldHVybiBfcGFyc2VQb3NpdGlvbihwb3NpdGlvbiwgX2dldFRhcmdldCh0cmlnZ2VyKSwgX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pKCksIGRpcmVjdGlvbiwgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbikoKSwgMCwgMCwgMCwgX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSgpLCBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLCAwLCBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSA6IF9tYXhTY3JvbGwoc2Nyb2xsZXIpLCBjb250YWluZXJBbmltYXRpb24pO1xuLy8gfSxcbl9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb24odmFsdWUsIHRyaWdnZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGwsIG1hcmtlciwgbWFya2VyU2Nyb2xsZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgc2Nyb2xsZXJNYXgsIGNvbnRhaW5lckFuaW1hdGlvbiwgY2xhbXBaZXJvUHJvcCkge1xuICBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUoc2VsZikpO1xuXG4gIGlmIChfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN1YnN0cigwLCAzKSA9PT0gXCJtYXhcIikge1xuICAgIHZhbHVlID0gc2Nyb2xsZXJNYXggKyAodmFsdWUuY2hhckF0KDQpID09PSBcIj1cIiA/IF9vZmZzZXRUb1B4KFwiMFwiICsgdmFsdWUuc3Vic3RyKDMpLCBzY3JvbGxlclNpemUpIDogMCk7XG4gIH1cblxuICB2YXIgdGltZSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi50aW1lKCkgOiAwLFxuICAgICAgcDEsXG4gICAgICBwMixcbiAgICAgIGVsZW1lbnQ7XG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2VlaygwKTtcbiAgaXNOYU4odmFsdWUpIHx8ICh2YWx1ZSA9ICt2YWx1ZSk7IC8vIGNvbnZlcnQgYSBzdHJpbmcgbnVtYmVyIGxpa2UgXCI0NVwiIHRvIGFuIGFjdHVhbCBudW1iZXJcblxuICBpZiAoIV9pc051bWJlcih2YWx1ZSkpIHtcbiAgICBfaXNGdW5jdGlvbih0cmlnZ2VyKSAmJiAodHJpZ2dlciA9IHRyaWdnZXIoc2VsZikpO1xuICAgIHZhciBvZmZzZXRzID0gKHZhbHVlIHx8IFwiMFwiKS5zcGxpdChcIiBcIiksXG4gICAgICAgIGJvdW5kcyxcbiAgICAgICAgbG9jYWxPZmZzZXQsXG4gICAgICAgIGdsb2JhbE9mZnNldCxcbiAgICAgICAgZGlzcGxheTtcbiAgICBlbGVtZW50ID0gX2dldFRhcmdldCh0cmlnZ2VyLCBzZWxmKSB8fCBfYm9keTtcbiAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpIHx8IHt9O1xuXG4gICAgaWYgKCghYm91bmRzIHx8ICFib3VuZHMubGVmdCAmJiAhYm91bmRzLnRvcCkgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIC8vIGlmIGRpc3BsYXkgaXMgXCJub25lXCIsIGl0IHdvbid0IHJlcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBwcm9wZXJseVxuICAgICAgZGlzcGxheSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgICBkaXNwbGF5ID8gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheSA6IGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgIH1cblxuICAgIGxvY2FsT2Zmc2V0ID0gX29mZnNldFRvUHgob2Zmc2V0c1swXSwgYm91bmRzW2RpcmVjdGlvbi5kXSk7XG4gICAgZ2xvYmFsT2Zmc2V0ID0gX29mZnNldFRvUHgob2Zmc2V0c1sxXSB8fCBcIjBcIiwgc2Nyb2xsZXJTaXplKTtcbiAgICB2YWx1ZSA9IGJvdW5kc1tkaXJlY3Rpb24ucF0gLSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ucF0gLSBib3JkZXJXaWR0aCArIGxvY2FsT2Zmc2V0ICsgc2Nyb2xsIC0gZ2xvYmFsT2Zmc2V0O1xuICAgIG1hcmtlclNjcm9sbGVyICYmIF9wb3NpdGlvbk1hcmtlcihtYXJrZXJTY3JvbGxlciwgZ2xvYmFsT2Zmc2V0LCBkaXJlY3Rpb24sIHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldCA8IDIwIHx8IG1hcmtlclNjcm9sbGVyLl9pc1N0YXJ0ICYmIGdsb2JhbE9mZnNldCA+IDIwKTtcbiAgICBzY3JvbGxlclNpemUgLT0gc2Nyb2xsZXJTaXplIC0gZ2xvYmFsT2Zmc2V0OyAvLyBhZGp1c3QgZm9yIHRoZSBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXJBbmltYXRpb24gJiYgKHZhbHVlID0gZ3NhcC51dGlscy5tYXBSYW5nZShjb250YWluZXJBbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5zdGFydCwgY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuZW5kLCAwLCBzY3JvbGxlck1heCwgdmFsdWUpKTtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChjbGFtcFplcm9Qcm9wKSB7XG4gICAgc2VsZltjbGFtcFplcm9Qcm9wXSA9IHZhbHVlIHx8IC0wLjAwMTtcbiAgICB2YWx1ZSA8IDAgJiYgKHZhbHVlID0gMCk7XG4gIH1cblxuICBpZiAobWFya2VyKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdmFsdWUgKyBzY3JvbGxlclNpemUsXG4gICAgICAgIGlzU3RhcnQgPSBtYXJrZXIuX2lzU3RhcnQ7XG4gICAgcDEgPSBcInNjcm9sbFwiICsgZGlyZWN0aW9uLmQyO1xuXG4gICAgX3Bvc2l0aW9uTWFya2VyKG1hcmtlciwgcG9zaXRpb24sIGRpcmVjdGlvbiwgaXNTdGFydCAmJiBwb3NpdGlvbiA+IDIwIHx8ICFpc1N0YXJ0ICYmICh1c2VGaXhlZFBvc2l0aW9uID8gTWF0aC5tYXgoX2JvZHlbcDFdLCBfZG9jRWxbcDFdKSA6IG1hcmtlci5wYXJlbnROb2RlW3AxXSkgPD0gcG9zaXRpb24gKyAxKTtcblxuICAgIGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICBzY3JvbGxlckJvdW5kcyA9IF9nZXRCb3VuZHMobWFya2VyU2Nyb2xsZXIpO1xuICAgICAgdXNlRml4ZWRQb3NpdGlvbiAmJiAobWFya2VyLnN0eWxlW2RpcmVjdGlvbi5vcC5wXSA9IHNjcm9sbGVyQm91bmRzW2RpcmVjdGlvbi5vcC5wXSAtIGRpcmVjdGlvbi5vcC5tIC0gbWFya2VyLl9vZmZzZXQgKyBfcHgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250YWluZXJBbmltYXRpb24gJiYgZWxlbWVudCkge1xuICAgIHAxID0gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgICBjb250YWluZXJBbmltYXRpb24uc2VlayhzY3JvbGxlck1heCk7XG4gICAgcDIgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ID0gcDFbZGlyZWN0aW9uLnBdIC0gcDJbZGlyZWN0aW9uLnBdO1xuICAgIHZhbHVlID0gdmFsdWUgLyBjb250YWluZXJBbmltYXRpb24uX2NhU2Nyb2xsRGlzdCAqIHNjcm9sbGVyTWF4O1xuICB9XG5cbiAgY29udGFpbmVyQW5pbWF0aW9uICYmIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKHRpbWUpO1xuICByZXR1cm4gY29udGFpbmVyQW5pbWF0aW9uID8gdmFsdWUgOiBNYXRoLnJvdW5kKHZhbHVlKTtcbn0sXG4gICAgX3ByZWZpeEV4cCA9IC8od2Via2l0fG1venxsZW5ndGh8Y3NzVGV4dHxpbnNldCkvaSxcbiAgICBfcmVwYXJlbnQgPSBmdW5jdGlvbiBfcmVwYXJlbnQoZWxlbWVudCwgcGFyZW50LCB0b3AsIGxlZnQpIHtcbiAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XG4gICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgICAgcCxcbiAgICAgICAgY3M7XG5cbiAgICBpZiAocGFyZW50ID09PSBfYm9keSkge1xuICAgICAgZWxlbWVudC5fc3RPcmlnID0gc3R5bGUuY3NzVGV4dDsgLy8gcmVjb3JkIG9yaWdpbmFsIGlubGluZSBzdHlsZXMgc28gd2UgY2FuIHJldmVydCB0aGVtIGxhdGVyXG5cbiAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICAgIGZvciAocCBpbiBjcykge1xuICAgICAgICAvLyBtdXN0IGNvcHkgYWxsIHJlbGV2YW50IHN0eWxlcyB0byBlbnN1cmUgdGhhdCBub3RoaW5nIGNoYW5nZXMgdmlzdWFsbHkgd2hlbiB3ZSByZXBhcmVudCB0byB0aGUgPGJvZHk+LiBTa2lwIHRoZSB2ZW5kb3IgcHJlZml4ZWQgb25lcy5cbiAgICAgICAgaWYgKCErcCAmJiAhX3ByZWZpeEV4cC50ZXN0KHApICYmIGNzW3BdICYmIHR5cGVvZiBzdHlsZVtwXSA9PT0gXCJzdHJpbmdcIiAmJiBwICE9PSBcIjBcIikge1xuICAgICAgICAgIHN0eWxlW3BdID0gY3NbcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3R5bGUudG9wID0gdG9wO1xuICAgICAgc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmNzc1RleHQgPSBlbGVtZW50Ll9zdE9yaWc7XG4gICAgfVxuXG4gICAgZ3NhcC5jb3JlLmdldENhY2hlKGVsZW1lbnQpLnVuY2FjaGUgPSAxO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxufSxcbiAgICBfaW50ZXJydXB0aW9uVHJhY2tlciA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHRpb25UcmFja2VyKGdldFZhbHVlRnVuYywgaW5pdGlhbFZhbHVlLCBvbkludGVycnVwdCkge1xuICB2YXIgbGFzdDEgPSBpbml0aWFsVmFsdWUsXG4gICAgICBsYXN0MiA9IGxhc3QxO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBNYXRoLnJvdW5kKGdldFZhbHVlRnVuYygpKTsgLy8gcm91bmQgYmVjYXVzZSBpbiBzb21lIFt2ZXJ5IHVuY29tbW9uXSBXaW5kb3dzIGVudmlyb25tZW50cywgc2Nyb2xsIGNhbiBnZXQgcmVwb3J0ZWQgd2l0aCBkZWNpbWFscyBldmVuIHRob3VnaCBpdCB3YXMgc2V0IHdpdGhvdXQuXG5cbiAgICBpZiAoY3VycmVudCAhPT0gbGFzdDEgJiYgY3VycmVudCAhPT0gbGFzdDIgJiYgTWF0aC5hYnMoY3VycmVudCAtIGxhc3QxKSA+IDMgJiYgTWF0aC5hYnMoY3VycmVudCAtIGxhc3QyKSA+IDMpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIHNjcm9sbHMsIGtpbGwgdGhlIHR3ZWVuLiBpT1MgU2FmYXJpIGludGVybWl0dGVudGx5IG1pc3JlcG9ydHMgdGhlIHNjcm9sbCBwb3NpdGlvbiwgaXQgbWF5IGJlIHRoZSBtb3N0IHJlY2VudGx5LXNldCBvbmUgb3IgdGhlIG9uZSBiZWZvcmUgdGhhdCEgV2hlbiBTYWZhcmkgaXMgem9vbWVkIChDTUQtKyksIGl0IG9mdGVuIG1pc3JlcG9ydHMgYXMgMSBwaXhlbCBvZmYgdG9vISBTbyBpZiB3ZSBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byAxMjUsIGZvciBleGFtcGxlLCBpdCdsbCBhY3R1YWxseSByZXBvcnQgaXQgYXMgMTI0LlxuICAgICAgdmFsdWUgPSBjdXJyZW50O1xuICAgICAgb25JbnRlcnJ1cHQgJiYgb25JbnRlcnJ1cHQoKTtcbiAgICB9XG5cbiAgICBsYXN0MiA9IGxhc3QxO1xuICAgIGxhc3QxID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxhc3QxO1xuICB9O1xufSxcbiAgICBfc2hpZnRNYXJrZXIgPSBmdW5jdGlvbiBfc2hpZnRNYXJrZXIobWFya2VyLCBkaXJlY3Rpb24sIHZhbHVlKSB7XG4gIHZhciB2YXJzID0ge307XG4gIHZhcnNbZGlyZWN0aW9uLnBdID0gXCIrPVwiICsgdmFsdWU7XG4gIGdzYXAuc2V0KG1hcmtlciwgdmFycyk7XG59LFxuICAgIC8vIF9tZXJnZUFuaW1hdGlvbnMgPSBhbmltYXRpb25zID0+IHtcbi8vIFx0bGV0IHRsID0gZ3NhcC50aW1lbGluZSh7c21vb3RoQ2hpbGRUaW1pbmc6IHRydWV9KS5zdGFydFRpbWUoTWF0aC5taW4oLi4uYW5pbWF0aW9ucy5tYXAoYSA9PiBhLmdsb2JhbFRpbWUoMCkpKSk7XG4vLyBcdGFuaW1hdGlvbnMuZm9yRWFjaChhID0+IHtsZXQgdGltZSA9IGEudG90YWxUaW1lKCk7IHRsLmFkZChhKTsgYS50b3RhbFRpbWUodGltZSk7IH0pO1xuLy8gXHR0bC5zbW9vdGhDaGlsZFRpbWluZyA9IGZhbHNlO1xuLy8gXHRyZXR1cm4gdGw7XG4vLyB9LFxuLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHByb3ZpZGVkLCBhbmQgd2hlbiBkb2luZyBzbyBpdCdsbCBhZGQgYSAudHdlZW4gcHJvcGVydHkgdG8gdGhlIEZVTkNUSU9OIGl0c2VsZiwgYW5kIHJlbW92ZSBpdCB3aGVuIHRoZSB0d2VlbiBjb21wbGV0ZXMgb3IgZ2V0cyBraWxsZWQuIFRoaXMgZ2l2ZXMgdXMgYSB3YXkgdG8gaGF2ZSBtdWx0aXBsZSBTY3JvbGxUcmlnZ2VycyB1c2UgYSBjZW50cmFsIGZ1bmN0aW9uIGZvciBhbnkgZ2l2ZW4gc2Nyb2xsZXIgYW5kIHNlZSBpZiB0aGVyZSdzIGEgc2Nyb2xsIHR3ZWVuIHJ1bm5pbmcgKHdoaWNoIHdvdWxkIGFmZmVjdCBpZi9ob3cgdGhpbmdzIGdldCB1cGRhdGVkKVxuX2dldFR3ZWVuQ3JlYXRvciA9IGZ1bmN0aW9uIF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIGRpcmVjdGlvbikge1xuICB2YXIgZ2V0U2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICBwcm9wID0gXCJfc2Nyb2xsXCIgKyBkaXJlY3Rpb24ucDIsXG4gICAgICAvLyBhZGQgYSB0d2VlbmFibGUgcHJvcGVydHkgdG8gdGhlIHNjcm9sbGVyIHRoYXQncyBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24sIGxpa2UgX3Njcm9sbFRvcCBvciBfc2Nyb2xsTGVmdC4gVGhpcyB3YXksIGlmIHNvbWVvbmUgZG9lcyBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxlcikgaXQnbGwga2lsbCB0aGUgc2Nyb2xsIHR3ZWVuLlxuICBnZXRUd2VlbiA9IGZ1bmN0aW9uIGdldFR3ZWVuKHNjcm9sbFRvLCB2YXJzLCBpbml0aWFsVmFsdWUsIGNoYW5nZTEsIGNoYW5nZTIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXRUd2Vlbi50d2VlbixcbiAgICAgICAgb25Db21wbGV0ZSA9IHZhcnMub25Db21wbGV0ZSxcbiAgICAgICAgbW9kaWZpZXJzID0ge307XG4gICAgaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlIHx8IGdldFNjcm9sbCgpO1xuXG4gICAgdmFyIGNoZWNrRm9ySW50ZXJydXB0aW9uID0gX2ludGVycnVwdGlvblRyYWNrZXIoZ2V0U2Nyb2xsLCBpbml0aWFsVmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHR3ZWVuLmtpbGwoKTtcbiAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICB9KTtcblxuICAgIGNoYW5nZTIgPSBjaGFuZ2UxICYmIGNoYW5nZTIgfHwgMDsgLy8gaWYgY2hhbmdlMSBpcyAwLCB3ZSBzZXQgdGhhdCB0byB0aGUgZGlmZmVyZW5jZSBhbmQgaWdub3JlIGNoYW5nZTIuIE90aGVyd2lzZSwgdGhlcmUgd291bGQgYmUgYSBjb21wb3VuZCBlZmZlY3QuXG5cbiAgICBjaGFuZ2UxID0gY2hhbmdlMSB8fCBzY3JvbGxUbyAtIGluaXRpYWxWYWx1ZTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5raWxsKCk7XG4gICAgdmFyc1twcm9wXSA9IHNjcm9sbFRvO1xuICAgIHZhcnMuaW5oZXJpdCA9IGZhbHNlO1xuICAgIHZhcnMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG4gICAgbW9kaWZpZXJzW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNoZWNrRm9ySW50ZXJydXB0aW9uKGluaXRpYWxWYWx1ZSArIGNoYW5nZTEgKiB0d2Vlbi5yYXRpbyArIGNoYW5nZTIgKiB0d2Vlbi5yYXRpbyAqIHR3ZWVuLnJhdGlvKTtcbiAgICB9O1xuXG4gICAgdmFycy5vblVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKztcbiAgICAgIGdldFR3ZWVuLnR3ZWVuICYmIF91cGRhdGVBbGwoKTsgLy8gaWYgaXQgd2FzIGludGVycnVwdGVkL2tpbGxlZCwgbGlrZSBpbiBhIGNvbnRleHQucmV2ZXJ0KCksIGRvbid0IGZvcmNlIGFuIHVwZGF0ZUFsbCgpXG4gICAgfTtcblxuICAgIHZhcnMub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZS5jYWxsKHR3ZWVuKTtcbiAgICB9O1xuXG4gICAgdHdlZW4gPSBnZXRUd2Vlbi50d2VlbiA9IGdzYXAudG8oc2Nyb2xsZXIsIHZhcnMpO1xuICAgIHJldHVybiB0d2VlbjtcbiAgfTtcblxuICBzY3JvbGxlcltwcm9wXSA9IGdldFNjcm9sbDtcblxuICBnZXRTY3JvbGwud2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRUd2Vlbi50d2VlbiAmJiBnZXRUd2Vlbi50d2Vlbi5raWxsKCkgJiYgKGdldFR3ZWVuLnR3ZWVuID0gMCk7XG4gIH07XG5cbiAgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcIndoZWVsXCIsIGdldFNjcm9sbC53aGVlbEhhbmRsZXIpOyAvLyBXaW5kb3dzIG1hY2hpbmVzIGhhbmRsZSBtb3VzZXdoZWVsIHNjcm9sbGluZyBpbiBjaHVua3MgKGxpa2UgXCIzIGxpbmVzIHBlciBzY3JvbGxcIikgbWVhbmluZyB0aGUgdHlwaWNhbCBzdHJhdGVneSBmb3IgY2FuY2VsbGluZyB0aGUgc2Nyb2xsIGlzbid0IGFzIHNlbnNpdGl2ZS4gSXQncyBtdWNoIG1vcmUgbGlrZWx5IHRvIG1hdGNoIG9uZSBvZiB0aGUgcHJldmlvdXMgMiBzY3JvbGwgZXZlbnQgcG9zaXRpb25zLiBTbyB3ZSBraWxsIGFueSBzbmFwcGluZyBhcyBzb29uIGFzIHRoZXJlJ3MgYSB3aGVlbCBldmVudC5cblxuXG4gIFNjcm9sbFRyaWdnZXIuaXNUb3VjaCAmJiBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwidG91Y2htb3ZlXCIsIGdldFNjcm9sbC53aGVlbEhhbmRsZXIpO1xuICByZXR1cm4gZ2V0VHdlZW47XG59O1xuXG5leHBvcnQgdmFyIFNjcm9sbFRyaWdnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbikge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpXCIpO1xuXG4gICAgX2NvbnRleHQodGhpcyk7XG5cbiAgICB0aGlzLmluaXQodmFycywgYW5pbWF0aW9uKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTY3JvbGxUcmlnZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQodmFycywgYW5pbWF0aW9uKSB7XG4gICAgdGhpcy5wcm9ncmVzcyA9IHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMudmFycyAmJiB0aGlzLmtpbGwodHJ1ZSwgdHJ1ZSk7IC8vIGluIGNhc2UgaXQncyBiZWluZyBpbml0dGVkIGFnYWluXG5cbiAgICBpZiAoIV9lbmFibGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMucmVmcmVzaCA9IHRoaXMua2lsbCA9IF9wYXNzVGhyb3VnaDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXJzID0gX3NldERlZmF1bHRzKF9pc1N0cmluZyh2YXJzKSB8fCBfaXNOdW1iZXIodmFycykgfHwgdmFycy5ub2RlVHlwZSA/IHtcbiAgICAgIHRyaWdnZXI6IHZhcnNcbiAgICB9IDogdmFycywgX2RlZmF1bHRzKTtcblxuICAgIHZhciBfdmFycyA9IHZhcnMsXG4gICAgICAgIG9uVXBkYXRlID0gX3ZhcnMub25VcGRhdGUsXG4gICAgICAgIHRvZ2dsZUNsYXNzID0gX3ZhcnMudG9nZ2xlQ2xhc3MsXG4gICAgICAgIGlkID0gX3ZhcnMuaWQsXG4gICAgICAgIG9uVG9nZ2xlID0gX3ZhcnMub25Ub2dnbGUsXG4gICAgICAgIG9uUmVmcmVzaCA9IF92YXJzLm9uUmVmcmVzaCxcbiAgICAgICAgc2NydWIgPSBfdmFycy5zY3J1YixcbiAgICAgICAgdHJpZ2dlciA9IF92YXJzLnRyaWdnZXIsXG4gICAgICAgIHBpbiA9IF92YXJzLnBpbixcbiAgICAgICAgcGluU3BhY2luZyA9IF92YXJzLnBpblNwYWNpbmcsXG4gICAgICAgIGludmFsaWRhdGVPblJlZnJlc2ggPSBfdmFycy5pbnZhbGlkYXRlT25SZWZyZXNoLFxuICAgICAgICBhbnRpY2lwYXRlUGluID0gX3ZhcnMuYW50aWNpcGF0ZVBpbixcbiAgICAgICAgb25TY3J1YkNvbXBsZXRlID0gX3ZhcnMub25TY3J1YkNvbXBsZXRlLFxuICAgICAgICBvblNuYXBDb21wbGV0ZSA9IF92YXJzLm9uU25hcENvbXBsZXRlLFxuICAgICAgICBvbmNlID0gX3ZhcnMub25jZSxcbiAgICAgICAgc25hcCA9IF92YXJzLnNuYXAsXG4gICAgICAgIHBpblJlcGFyZW50ID0gX3ZhcnMucGluUmVwYXJlbnQsXG4gICAgICAgIHBpblNwYWNlciA9IF92YXJzLnBpblNwYWNlcixcbiAgICAgICAgY29udGFpbmVyQW5pbWF0aW9uID0gX3ZhcnMuY29udGFpbmVyQW5pbWF0aW9uLFxuICAgICAgICBmYXN0U2Nyb2xsRW5kID0gX3ZhcnMuZmFzdFNjcm9sbEVuZCxcbiAgICAgICAgcHJldmVudE92ZXJsYXBzID0gX3ZhcnMucHJldmVudE92ZXJsYXBzLFxuICAgICAgICBkaXJlY3Rpb24gPSB2YXJzLmhvcml6b250YWwgfHwgdmFycy5jb250YWluZXJBbmltYXRpb24gJiYgdmFycy5ob3Jpem9udGFsICE9PSBmYWxzZSA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsLFxuICAgICAgICBpc1RvZ2dsZSA9ICFzY3J1YiAmJiBzY3J1YiAhPT0gMCxcbiAgICAgICAgc2Nyb2xsZXIgPSBfZ2V0VGFyZ2V0KHZhcnMuc2Nyb2xsZXIgfHwgX3dpbiksXG4gICAgICAgIHNjcm9sbGVyQ2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUoc2Nyb2xsZXIpLFxuICAgICAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpLFxuICAgICAgICB1c2VGaXhlZFBvc2l0aW9uID0gKFwicGluVHlwZVwiIGluIHZhcnMgPyB2YXJzLnBpblR5cGUgOiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcInBpblR5cGVcIikgfHwgaXNWaWV3cG9ydCAmJiBcImZpeGVkXCIpID09PSBcImZpeGVkXCIsXG4gICAgICAgIGNhbGxiYWNrcyA9IFt2YXJzLm9uRW50ZXIsIHZhcnMub25MZWF2ZSwgdmFycy5vbkVudGVyQmFjaywgdmFycy5vbkxlYXZlQmFja10sXG4gICAgICAgIHRvZ2dsZUFjdGlvbnMgPSBpc1RvZ2dsZSAmJiB2YXJzLnRvZ2dsZUFjdGlvbnMuc3BsaXQoXCIgXCIpLFxuICAgICAgICBtYXJrZXJzID0gXCJtYXJrZXJzXCIgaW4gdmFycyA/IHZhcnMubWFya2VycyA6IF9kZWZhdWx0cy5tYXJrZXJzLFxuICAgICAgICBib3JkZXJXaWR0aCA9IGlzVmlld3BvcnQgPyAwIDogcGFyc2VGbG9hdChfZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxlcilbXCJib3JkZXJcIiArIGRpcmVjdGlvbi5wMiArIF9XaWR0aF0pIHx8IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBvblJlZnJlc2hJbml0ID0gdmFycy5vblJlZnJlc2hJbml0ICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YXJzLm9uUmVmcmVzaEluaXQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJTaXplID0gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pLFxuICAgICAgICBnZXRTY3JvbGxlck9mZnNldHMgPSBfZ2V0T2Zmc2V0c0Z1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQpLFxuICAgICAgICBsYXN0U25hcCA9IDAsXG4gICAgICAgIGxhc3RSZWZyZXNoID0gMCxcbiAgICAgICAgcHJldlByb2dyZXNzID0gMCxcbiAgICAgICAgc2Nyb2xsRnVuYyA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgICB0d2VlblRvLFxuICAgICAgICBwaW5DYWNoZSxcbiAgICAgICAgc25hcEZ1bmMsXG4gICAgICAgIHNjcm9sbDEsXG4gICAgICAgIHNjcm9sbDIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIG1hcmtlclN0YXJ0LFxuICAgICAgICBtYXJrZXJFbmQsXG4gICAgICAgIG1hcmtlclN0YXJ0VHJpZ2dlcixcbiAgICAgICAgbWFya2VyRW5kVHJpZ2dlcixcbiAgICAgICAgbWFya2VyVmFycyxcbiAgICAgICAgZXhlY3V0aW5nT25SZWZyZXNoLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUsXG4gICAgICAgIHBpbkFjdGl2ZVN0YXRlLFxuICAgICAgICBwaW5TdGF0ZSxcbiAgICAgICAgc3BhY2VyLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHBpbkdldHRlcixcbiAgICAgICAgcGluU2V0dGVyLFxuICAgICAgICBwaW5TdGFydCxcbiAgICAgICAgcGluQ2hhbmdlLFxuICAgICAgICBzcGFjaW5nU3RhcnQsXG4gICAgICAgIHNwYWNlclN0YXRlLFxuICAgICAgICBtYXJrZXJTdGFydFNldHRlcixcbiAgICAgICAgcGluTW92ZXMsXG4gICAgICAgIG1hcmtlckVuZFNldHRlcixcbiAgICAgICAgY3MsXG4gICAgICAgIHNuYXAxLFxuICAgICAgICBzbmFwMixcbiAgICAgICAgc2NydWJUd2VlbixcbiAgICAgICAgc2NydWJTbW9vdGgsXG4gICAgICAgIHNuYXBEdXJDbGFtcCxcbiAgICAgICAgc25hcERlbGF5ZWRDYWxsLFxuICAgICAgICBwcmV2U2Nyb2xsLFxuICAgICAgICBwcmV2QW5pbVByb2dyZXNzLFxuICAgICAgICBjYU1hcmtlclNldHRlcixcbiAgICAgICAgY3VzdG9tUmV2ZXJ0UmV0dXJuOyAvLyBmb3IgdGhlIHNha2Ugb2YgZWZmaWNpZW5jeSwgX3N0YXJ0Q2xhbXAvX2VuZENsYW1wIHNlcnZlIGxpa2UgYSB0cnV0aHkgdmFsdWUgaW5kaWNhdGluZyB0aGF0IGNsYW1waW5nIHdhcyBlbmFibGVkIG9uIHRoZSBzdGFydC9lbmQsIGFuZCBBTFNPIHN0b3JlIHRoZSBhY3R1YWwgcHJlLWNsYW1wZWQgbnVtZXJpYyB2YWx1ZS4gV2UgdGFwIGludG8gdGhhdCBpbiBTY3JvbGxTbW9vdGhlciBmb3Igc3BlZWQgZWZmZWN0cy4gU28gZm9yIGV4YW1wbGUsIGlmIHN0YXJ0PVwiY2xhbXAodG9wIGJvdHRvbSlcIiByZXN1bHRzIGluIGEgc3RhcnQgb2YgLTEwMCBuYXR1cmFsbHksIGl0IHdvdWxkIGdldCBjbGFtcGVkIHRvIDAgYnV0IC0xMDAgd291bGQgYmUgc3RvcmVkIGluIF9zdGFydENsYW1wLlxuXG5cbiAgICBzZWxmLl9zdGFydENsYW1wID0gc2VsZi5fZW5kQ2xhbXAgPSBmYWxzZTtcbiAgICBzZWxmLl9kaXIgPSBkaXJlY3Rpb247XG4gICAgYW50aWNpcGF0ZVBpbiAqPSA0NTtcbiAgICBzZWxmLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG4gICAgc2VsZi5zY3JvbGwgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZS5iaW5kKGNvbnRhaW5lckFuaW1hdGlvbikgOiBzY3JvbGxGdW5jO1xuICAgIHNjcm9sbDEgPSBzY3JvbGxGdW5jKCk7XG4gICAgc2VsZi52YXJzID0gdmFycztcbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24gfHwgdmFycy5hbmltYXRpb247XG5cbiAgICBpZiAoXCJyZWZyZXNoUHJpb3JpdHlcIiBpbiB2YXJzKSB7XG4gICAgICBfc29ydCA9IDE7XG4gICAgICB2YXJzLnJlZnJlc2hQcmlvcml0eSA9PT0gLTk5OTkgJiYgKF9wcmltYXJ5ID0gc2VsZik7IC8vIHVzZWQgYnkgU2Nyb2xsU21vb3RoZXJcbiAgICB9XG5cbiAgICBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCB8fCB7XG4gICAgICB0b3A6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF92ZXJ0aWNhbCksXG4gICAgICBsZWZ0OiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfaG9yaXpvbnRhbClcbiAgICB9O1xuICAgIHNlbGYudHdlZW5UbyA9IHR3ZWVuVG8gPSBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsW2RpcmVjdGlvbi5wXTtcblxuICAgIHNlbGYuc2NydWJEdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc2NydWJTbW9vdGggPSBfaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlO1xuXG4gICAgICBpZiAoIXNjcnViU21vb3RoKSB7XG4gICAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wcm9ncmVzcygxKS5raWxsKCk7XG4gICAgICAgIHNjcnViVHdlZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4uZHVyYXRpb24odmFsdWUpIDogc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7XG4gICAgICAgICAgZWFzZTogXCJleHBvXCIsXG4gICAgICAgICAgdG90YWxQcm9ncmVzczogXCIrPTBcIixcbiAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICBkdXJhdGlvbjogc2NydWJTbW9vdGgsXG4gICAgICAgICAgcGF1c2VkOiB0cnVlLFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gb25TY3J1YkNvbXBsZXRlICYmIG9uU2NydWJDb21wbGV0ZShzZWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICBhbmltYXRpb24udmFycy5sYXp5ID0gZmFsc2U7XG4gICAgICBhbmltYXRpb24uX2luaXR0ZWQgJiYgIXNlbGYuaXNSZXZlcnRlZCB8fCBhbmltYXRpb24udmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiBhbmltYXRpb24uZHVyYXRpb24oKSAmJiBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpOyAvLyBzcGVjaWFsIGNhc2U6IGlmIHRoaXMgU2Nyb2xsVHJpZ2dlciBnZXRzIHJlLWluaXR0ZWQsIGEgZnJvbSgpIHR3ZWVuIHdpdGggYSBzdGFnZ2VyIGNvdWxkIGdldCBpbml0dGVkIGluaXRpYWxseSBhbmQgdGhlbiByZXZlcnRlZCBvbiB0aGUgcmUtaW5pdCB3aGljaCBtZWFucyBpdCdsbCBuZWVkIHRvIGdldCByZW5kZXJlZCBhZ2FpbiBoZXJlIHRvIHByb3Blcmx5IGRpc3BsYXkgdGhpbmdzLiBPdGhlcndpc2UsIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8zNjc3Ny1zY3JvbGxzbW9vdGhlci1zcGxpdHRleHQtbmV4dGpzLyBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vZVlQeVBwZD9lZGl0b3JzPTAwMTBcblxuICAgICAgc2VsZi5hbmltYXRpb24gPSBhbmltYXRpb24ucGF1c2UoKTtcbiAgICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyID0gc2VsZjtcbiAgICAgIHNlbGYuc2NydWJEdXJhdGlvbihzY3J1Yik7XG4gICAgICBzbmFwMSA9IDA7XG4gICAgICBpZCB8fCAoaWQgPSBhbmltYXRpb24udmFycy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKHNuYXApIHtcbiAgICAgIC8vIFRPRE86IHBvdGVudGlhbCBpZGVhOiB1c2UgbGVnaXRpbWF0ZSBDU1Mgc2Nyb2xsIHNuYXBwaW5nIGJ5IHB1c2hpbmcgaW52aXNpYmxlIGVsZW1lbnRzIGludG8gdGhlIERPTSB0aGF0IHNlcnZlIGFzIHNuYXAgcG9zaXRpb25zLCBhbmQgdG9nZ2xlIHRoZSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnN0eWxlLnNjcm9sbFNuYXBUeXBlIG9uVG9nZ2xlLiBTZWUgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vSmpMcmdXTSBmb3IgYSBxdWljayBwcm9vZiBvZiBjb25jZXB0LlxuICAgICAgaWYgKCFfaXNPYmplY3Qoc25hcCkgfHwgc25hcC5wdXNoKSB7XG4gICAgICAgIHNuYXAgPSB7XG4gICAgICAgICAgc25hcFRvOiBzbmFwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBfYm9keS5zdHlsZSAmJiBnc2FwLnNldChpc1ZpZXdwb3J0ID8gW19ib2R5LCBfZG9jRWxdIDogc2Nyb2xsZXIsIHtcbiAgICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgICB9KTsgLy8gc21vb3RoIHNjcm9sbGluZyBkb2Vzbid0IHdvcmsgd2l0aCBzbmFwLlxuXG4gICAgICBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIF9pc0Z1bmN0aW9uKG8pICYmIG8udGFyZ2V0ID09PSAoaXNWaWV3cG9ydCA/IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwgOiBzY3JvbGxlcikgJiYgKG8uc21vb3RoID0gZmFsc2UpO1xuICAgICAgfSk7IC8vIG5vdGU6IHNldCBzbW9vdGggdG8gZmFsc2Ugb24gYm90aCB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgc2Nyb2xsIGdldHRlcnMvc2V0dGVyc1xuXG5cbiAgICAgIHNuYXBGdW5jID0gX2lzRnVuY3Rpb24oc25hcC5zbmFwVG8pID8gc25hcC5zbmFwVG8gOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNcIiA/IF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSA6IHNuYXAuc25hcFRvID09PSBcImxhYmVsc0RpcmVjdGlvbmFsXCIgPyBfZ2V0TGFiZWxBdERpcmVjdGlvbihhbmltYXRpb24pIDogc25hcC5kaXJlY3Rpb25hbCAhPT0gZmFsc2UgPyBmdW5jdGlvbiAodmFsdWUsIHN0KSB7XG4gICAgICAgIHJldHVybiBfc25hcERpcmVjdGlvbmFsKHNuYXAuc25hcFRvKSh2YWx1ZSwgX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwID8gMCA6IHN0LmRpcmVjdGlvbik7XG4gICAgICB9IDogZ3NhcC51dGlscy5zbmFwKHNuYXAuc25hcFRvKTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IHNuYXAuZHVyYXRpb24gfHwge1xuICAgICAgICBtaW46IDAuMSxcbiAgICAgICAgbWF4OiAyXG4gICAgICB9O1xuICAgICAgc25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xuICAgICAgc25hcERlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbChzbmFwLmRlbGF5IHx8IHNjcnViU21vb3RoIC8gMiB8fCAwLjEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbCA9IHNjcm9sbEZ1bmMoKSxcbiAgICAgICAgICAgIHJlZnJlc2hlZFJlY2VudGx5ID0gX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwLFxuICAgICAgICAgICAgdHdlZW4gPSB0d2VlblRvLnR3ZWVuO1xuXG4gICAgICAgIGlmICgocmVmcmVzaGVkUmVjZW50bHkgfHwgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA8IDEwKSAmJiAhdHdlZW4gJiYgIV9wb2ludGVySXNEb3duICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAoc2Nyb2xsIC0gc3RhcnQpIC8gY2hhbmdlLFxuICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBwcm9ncmVzcyxcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSByZWZyZXNoZWRSZWNlbnRseSA/IDAgOiAodG90YWxQcm9ncmVzcyAtIHNuYXAyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMCxcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGdzYXAudXRpbHMuY2xhbXAoLXByb2dyZXNzLCAxIC0gcHJvZ3Jlc3MsIF9hYnModmVsb2NpdHkgLyAyKSAqIHZlbG9jaXR5IC8gMC4xODUpLFxuICAgICAgICAgICAgICBuYXR1cmFsRW5kID0gcHJvZ3Jlc3MgKyAoc25hcC5pbmVydGlhID09PSBmYWxzZSA/IDAgOiBjaGFuZ2UxKSxcbiAgICAgICAgICAgICAgZW5kVmFsdWUsXG4gICAgICAgICAgICAgIGVuZFNjcm9sbCxcbiAgICAgICAgICAgICAgX3NuYXAgPSBzbmFwLFxuICAgICAgICAgICAgICBvblN0YXJ0ID0gX3NuYXAub25TdGFydCxcbiAgICAgICAgICAgICAgX29uSW50ZXJydXB0ID0gX3NuYXAub25JbnRlcnJ1cHQsXG4gICAgICAgICAgICAgIF9vbkNvbXBsZXRlID0gX3NuYXAub25Db21wbGV0ZTtcbiAgICAgICAgICBlbmRWYWx1ZSA9IHNuYXBGdW5jKG5hdHVyYWxFbmQsIHNlbGYpO1xuICAgICAgICAgIF9pc051bWJlcihlbmRWYWx1ZSkgfHwgKGVuZFZhbHVlID0gbmF0dXJhbEVuZCk7IC8vIGluIGNhc2UgdGhlIGZ1bmN0aW9uIGRpZG4ndCByZXR1cm4gYSBudW1iZXIsIGZhbGwgYmFjayB0byB1c2luZyB0aGUgbmF0dXJhbEVuZFxuXG4gICAgICAgICAgZW5kU2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChzdGFydCArIGVuZFZhbHVlICogY2hhbmdlKSk7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsIDw9IGVuZCAmJiBzY3JvbGwgPj0gc3RhcnQgJiYgZW5kU2Nyb2xsICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICAgIGlmICh0d2VlbiAmJiAhdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uZGF0YSA8PSBfYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCkpIHtcbiAgICAgICAgICAgICAgLy8gdGhlcmUncyBhbiBvdmVybGFwcGluZyBzbmFwISBTbyB3ZSBtdXN0IGZpZ3VyZSBvdXQgd2hpY2ggb25lIGlzIGNsb3NlciBhbmQgbGV0IHRoYXQgdHdlZW4gbGl2ZS5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5pbmVydGlhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBjaGFuZ2UxID0gZW5kVmFsdWUgLSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHdlZW5UbyhlbmRTY3JvbGwsIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKE1hdGgubWF4KF9hYnMobmF0dXJhbEVuZCAtIHRvdGFsUHJvZ3Jlc3MpLCBfYWJzKGVuZFZhbHVlIC0gdG90YWxQcm9ncmVzcykpICogMC4xODUgLyB2ZWxvY2l0eSAvIDAuMDUgfHwgMCkpLFxuICAgICAgICAgICAgICBlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcbiAgICAgICAgICAgICAgZGF0YTogX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpLFxuICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGRpc3RhbmNlIHNvIHRoYXQgaWYgYW5vdGhlciBzbmFwIHR3ZWVuIG9jY3VycyAoY29uZmxpY3QpIHdlIGNhbiBwcmlvcml0aXplIHRoZSBjbG9zZXN0IHNuYXAuXG4gICAgICAgICAgICAgIG9uSW50ZXJydXB0OiBmdW5jdGlvbiBvbkludGVycnVwdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgX29uSW50ZXJydXB0ICYmIF9vbkludGVycnVwdChzZWxmKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBzY3JvbGxiYXIgaXMgbGltaXRlZCwgc28gd2Ugc2hvdWxkIGNvcnJlY3QgdGhlIHNjcnViYmVkIGFuaW1hdGlvbidzIHBsYXloZWFkIGF0IHRoZSBlbmQgdG8gbWF0Y2ggRVhBQ1RMWSB3aGVyZSBpdCB3YXMgc3VwcG9zZWQgdG8gc25hcFxuICAgICAgICAgICAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgZW5kVmFsdWUsIGFuaW1hdGlvbi5fdFRpbWUgLyBhbmltYXRpb24uX3REdXIpIDogYW5pbWF0aW9uLnByb2dyZXNzKGVuZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzbmFwMSA9IHNuYXAyID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIG9uU25hcENvbXBsZXRlICYmIG9uU25hcENvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICAgIF9vbkNvbXBsZXRlICYmIF9vbkNvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzY3JvbGwsIGNoYW5nZTEgKiBjaGFuZ2UsIGVuZFNjcm9sbCAtIHNjcm9sbCAtIGNoYW5nZTEgKiBjaGFuZ2UpO1xuICAgICAgICAgICAgb25TdGFydCAmJiBvblN0YXJ0KHNlbGYsIHR3ZWVuVG8udHdlZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmlzQWN0aXZlICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSkucGF1c2UoKTtcbiAgICB9XG5cbiAgICBpZCAmJiAoX2lkc1tpZF0gPSBzZWxmKTtcbiAgICB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyID0gX2dldFRhcmdldCh0cmlnZ2VyIHx8IHBpbiAhPT0gdHJ1ZSAmJiBwaW4pOyAvLyBpZiBhIHRyaWdnZXIgaGFzIHNvbWUga2luZCBvZiBzY3JvbGwtcmVsYXRlZCBlZmZlY3QgYXBwbGllZCB0aGF0IGNvdWxkIGNvbnRhbWluYXRlIHRoZSBcInlcIiBvciBcInhcIiBwb3NpdGlvbiAobGlrZSBhIFNjcm9sbFNtb290aGVyIGVmZmVjdCksIHdlIG5lZWRlZCBhIHdheSB0byB0ZW1wb3JhcmlseSByZXZlcnQgaXQsIHNvIHdlIHVzZSB0aGUgc3RSZXZlcnQgcHJvcGVydHkgb2YgdGhlIGdzQ2FjaGUuIEl0IGNhbiByZXR1cm4gYW5vdGhlciBmdW5jdGlvbiB0aGF0IHdlJ2xsIGNhbGwgYXQgdGhlIGVuZCBzbyBpdCBjYW4gcmV0dXJuIHRvIGl0cyBub3JtYWwgc3RhdGUuXG5cbiAgICBjdXN0b21SZXZlcnRSZXR1cm4gPSB0cmlnZ2VyICYmIHRyaWdnZXIuX2dzYXAgJiYgdHJpZ2dlci5fZ3NhcC5zdFJldmVydDtcbiAgICBjdXN0b21SZXZlcnRSZXR1cm4gJiYgKGN1c3RvbVJldmVydFJldHVybiA9IGN1c3RvbVJldmVydFJldHVybihzZWxmKSk7XG4gICAgcGluID0gcGluID09PSB0cnVlID8gdHJpZ2dlciA6IF9nZXRUYXJnZXQocGluKTtcbiAgICBfaXNTdHJpbmcodG9nZ2xlQ2xhc3MpICYmICh0b2dnbGVDbGFzcyA9IHtcbiAgICAgIHRhcmdldHM6IHRyaWdnZXIsXG4gICAgICBjbGFzc05hbWU6IHRvZ2dsZUNsYXNzXG4gICAgfSk7XG5cbiAgICBpZiAocGluKSB7XG4gICAgICBwaW5TcGFjaW5nID09PSBmYWxzZSB8fCBwaW5TcGFjaW5nID09PSBfbWFyZ2luIHx8IChwaW5TcGFjaW5nID0gIXBpblNwYWNpbmcgJiYgcGluLnBhcmVudE5vZGUgJiYgcGluLnBhcmVudE5vZGUuc3R5bGUgJiYgX2dldENvbXB1dGVkU3R5bGUocGluLnBhcmVudE5vZGUpLmRpc3BsYXkgPT09IFwiZmxleFwiID8gZmFsc2UgOiBfcGFkZGluZyk7IC8vIGlmIHRoZSBwYXJlbnQgaXMgZGlzcGxheTogZmxleCwgZG9uJ3QgYXBwbHkgcGluU3BhY2luZyBieSBkZWZhdWx0LiBXZSBzaG91bGQgY2hlY2sgdGhhdCBwaW4ucGFyZW50Tm9kZSBpcyBhbiBlbGVtZW50IChub3Qgc2hhZG93IGRvbSB3aW5kb3cpXG5cbiAgICAgIHNlbGYucGluID0gcGluO1xuICAgICAgcGluQ2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUocGluKTtcblxuICAgICAgaWYgKCFwaW5DYWNoZS5zcGFjZXIpIHtcbiAgICAgICAgLy8gcmVjb3JkIHRoZSBzcGFjZXIgYW5kIHBpbk9yaWdpbmFsU3RhdGUgb24gdGhlIGNhY2hlIGluIGNhc2Ugc29tZW9uZSB0cmllcyBwaW5uaW5nIHRoZSBzYW1lIGVsZW1lbnQgd2l0aCBNVUxUSVBMRSBTY3JvbGxUcmlnZ2VycyAtIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSBtdWx0aXBsZSBzcGFjZXJzIG9yIHJlY29yZCB0aGUgXCJvcmlnaW5hbFwiIHBpbiBzdGF0ZSBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFmZmVjdGVkIGJ5IGFub3RoZXIgU2Nyb2xsVHJpZ2dlci5cbiAgICAgICAgaWYgKHBpblNwYWNlcikge1xuICAgICAgICAgIHBpblNwYWNlciA9IF9nZXRUYXJnZXQocGluU3BhY2VyKTtcbiAgICAgICAgICBwaW5TcGFjZXIgJiYgIXBpblNwYWNlci5ub2RlVHlwZSAmJiAocGluU3BhY2VyID0gcGluU3BhY2VyLmN1cnJlbnQgfHwgcGluU3BhY2VyLm5hdGl2ZUVsZW1lbnQpOyAvLyBmb3IgUmVhY3QgJiBBbmd1bGFyXG5cbiAgICAgICAgICBwaW5DYWNoZS5zcGFjZXJJc05hdGl2ZSA9ICEhcGluU3BhY2VyO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAocGluQ2FjaGUuc3BhY2VyU3RhdGUgPSBfZ2V0U3RhdGUocGluU3BhY2VyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwaW5DYWNoZS5zcGFjZXIgPSBzcGFjZXIgPSBwaW5TcGFjZXIgfHwgX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzcGFjZXIuY2xhc3NMaXN0LmFkZChcInBpbi1zcGFjZXJcIik7XG4gICAgICAgIGlkICYmIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlci1cIiArIGlkKTtcbiAgICAgICAgcGluQ2FjaGUucGluU3RhdGUgPSBwaW5PcmlnaW5hbFN0YXRlID0gX2dldFN0YXRlKHBpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlID0gcGluQ2FjaGUucGluU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhcnMuZm9yY2UzRCAhPT0gZmFsc2UgJiYgZ3NhcC5zZXQocGluLCB7XG4gICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc2VsZi5zcGFjZXIgPSBzcGFjZXIgPSBwaW5DYWNoZS5zcGFjZXI7XG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG4gICAgICBzcGFjaW5nU3RhcnQgPSBjc1twaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl07XG4gICAgICBwaW5HZXR0ZXIgPSBnc2FwLmdldFByb3BlcnR5KHBpbik7XG4gICAgICBwaW5TZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKHBpbiwgZGlyZWN0aW9uLmEsIF9weCk7IC8vIHBpbi5maXJzdENoaWxkICYmICFfbWF4U2Nyb2xsKHBpbiwgZGlyZWN0aW9uKSAmJiAocGluLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7IC8vIHByb3RlY3RzIGZyb20gY29sbGFwc2luZyBtYXJnaW5zLCBidXQgY2FuIGhhdmUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzFlNDJjN2E3M2JmYTQwOWQyY2YxZTE4NGU3YTQyNDhkIHNvIGl0IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIGp1c3QgdGVsbGluZyBwZW9wbGUgdG8gc2V0IHVwIHRoZWlyIENTUyB0byBhdm9pZCB0aGUgY29sbGFwc2luZyBtYXJnaW5zIChvdmVyZmxvdzogaGlkZGVuIHwgYXV0byBpcyBqdXN0IG9uZSBvcHRpb24uIEFub3RoZXIgaXMgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHRyYW5zcGFyZW50KS5cblxuICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICBtYXJrZXJWYXJzID0gX2lzT2JqZWN0KG1hcmtlcnMpID8gX3NldERlZmF1bHRzKG1hcmtlcnMsIF9tYXJrZXJEZWZhdWx0cykgOiBfbWFya2VyRGVmYXVsdHM7XG4gICAgICBtYXJrZXJTdGFydFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItc3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDApO1xuICAgICAgbWFya2VyRW5kVHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1lbmRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDAsIG1hcmtlclN0YXJ0VHJpZ2dlcik7XG4gICAgICBvZmZzZXQgPSBtYXJrZXJTdGFydFRyaWdnZXJbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgICAgIHZhciBjb250ZW50ID0gX2dldFRhcmdldChfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImNvbnRlbnRcIikgfHwgc2Nyb2xsZXIpO1xuXG4gICAgICBtYXJrZXJTdGFydCA9IHRoaXMubWFya2VyU3RhcnQgPSBfY3JlYXRlTWFya2VyKFwic3RhcnRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xuICAgICAgbWFya2VyRW5kID0gdGhpcy5tYXJrZXJFbmQgPSBfY3JlYXRlTWFya2VyKFwiZW5kXCIsIGlkLCBjb250ZW50LCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCwgMCwgY29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiAmJiAoY2FNYXJrZXJTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgZGlyZWN0aW9uLmEsIF9weCkpO1xuXG4gICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24gJiYgIShfcHJveGllcy5sZW5ndGggJiYgX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJmaXhlZE1hcmtlcnNcIikgPT09IHRydWUpKSB7XG4gICAgICAgIF9tYWtlUG9zaXRpb25hYmxlKGlzVmlld3BvcnQgPyBfYm9keSA6IHNjcm9sbGVyKTtcblxuICAgICAgICBnc2FwLnNldChbbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXSwge1xuICAgICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtlclN0YXJ0U2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgIHZhciBvbGRPblVwZGF0ZSA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlLFxuICAgICAgICAgIG9sZFBhcmFtcyA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlUGFyYW1zO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvblVwZGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKDAsIDAsIDEpO1xuICAgICAgICBvbGRPblVwZGF0ZSAmJiBvbGRPblVwZGF0ZS5hcHBseShjb250YWluZXJBbmltYXRpb24sIG9sZFBhcmFtcyB8fCBbXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxmLnByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSAtIDFdO1xuICAgIH07XG5cbiAgICBzZWxmLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RyaWdnZXJzW190cmlnZ2Vycy5pbmRleE9mKHNlbGYpICsgMV07XG4gICAgfTtcblxuICAgIHNlbGYucmV2ZXJ0ID0gZnVuY3Rpb24gKHJldmVydCwgdGVtcCkge1xuICAgICAgaWYgKCF0ZW1wKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmtpbGwodHJ1ZSk7XG4gICAgICB9IC8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZ3NhcC5jb250ZXh0KCkgYW5kIGdzYXAubWF0Y2hNZWRpYSgpIHdoaWNoIGNhbGwgcmV2ZXJ0KClcblxuXG4gICAgICB2YXIgciA9IHJldmVydCAhPT0gZmFsc2UgfHwgIXNlbGYuZW5hYmxlZCxcbiAgICAgICAgICBwcmV2UmVmcmVzaGluZyA9IF9yZWZyZXNoaW5nO1xuXG4gICAgICBpZiAociAhPT0gc2VsZi5pc1JldmVydGVkKSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgcHJldlNjcm9sbCA9IE1hdGgubWF4KHNjcm9sbEZ1bmMoKSwgc2VsZi5zY3JvbGwucmVjIHx8IDApOyAvLyByZWNvcmQgdGhlIHNjcm9sbCBzbyB3ZSBjYW4gcmV2ZXJ0IGxhdGVyIChyZXBvc2l0aW9uaW5nL3Bpbm5pbmcgdGhpbmdzIGNhbiBhZmZlY3Qgc2Nyb2xsIHBvc2l0aW9uKS4gSW4gdGhlIHN0YXRpYyByZWZyZXNoKCkgbWV0aG9kLCB3ZSBmaXJzdCByZWNvcmQgYWxsIHRoZSBzY3JvbGwgcG9zaXRpb25zIGFzIGEgcmVmZXJlbmNlLlxuXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcztcbiAgICAgICAgICBwcmV2QW5pbVByb2dyZXNzID0gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyU3RhcnQgJiYgW21hcmtlclN0YXJ0LCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgbWFya2VyRW5kVHJpZ2dlcl0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLnN0eWxlLmRpc3BsYXkgPSByID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgX3JlZnJlc2hpbmcgPSBzZWxmO1xuICAgICAgICAgIHNlbGYudXBkYXRlKHIpOyAvLyBtYWtlIHN1cmUgdGhlIHBpbiBpcyBiYWNrIGluIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiBzbyB0aGF0IGFsbCB0aGUgbWVhc3VyZW1lbnRzIGFyZSBjb3JyZWN0LiBkbyB0aGlzIEJFRk9SRSBzd2FwcGluZyB0aGUgcGluIG91dFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpbiAmJiAoIXBpblJlcGFyZW50IHx8ICFzZWxmLmlzQWN0aXZlKSkge1xuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICBfc3dhcFBpbk91dChwaW4sIHNwYWNlciwgcGluT3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIF9nZXRDb21wdXRlZFN0eWxlKHBpbiksIHNwYWNlclN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByIHx8IHNlbGYudXBkYXRlKHIpOyAvLyB3aGVuIHdlJ3JlIHJlc3RvcmluZywgdGhlIHVwZGF0ZSBzaG91bGQgcnVuIEFGVEVSIHN3YXBwaW5nIHRoZSBwaW4gaW50byBpdHMgcGluLXNwYWNlci5cblxuICAgICAgICBfcmVmcmVzaGluZyA9IHByZXZSZWZyZXNoaW5nOyAvLyByZXN0b3JlLiBXZSBzZXQgaXQgdG8gdHJ1ZSBkdXJpbmcgdGhlIHVwZGF0ZSgpIHNvIHRoYXQgdGhpbmdzIGZpcmUgcHJvcGVybHkgaW4gdGhlcmUuXG5cbiAgICAgICAgc2VsZi5pc1JldmVydGVkID0gcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24gKHNvZnQsIGZvcmNlLCBwb3NpdGlvbiwgcGluT2Zmc2V0KSB7XG4gICAgICAvLyBwb3NpdGlvbiBpcyB0eXBpY2FsbHkgb25seSBkZWZpbmVkIGlmIGl0J3MgY29taW5nIGZyb20gc2V0UG9zaXRpb25zKCkgLSBpdCdzIGEgd2F5IHRvIHNraXAgdGhlIG5vcm1hbCBwYXJzaW5nLiBwaW5PZmZzZXQgaXMgYWxzbyBvbmx5IGZyb20gc2V0UG9zaXRpb25zKCkgYW5kIGlzIG1vc3RseSByZWxhdGVkIHRvIGZhbmN5IHN0dWZmIHdlIG5lZWQgdG8gZG8gaW4gU2Nyb2xsU21vb3RoZXIgd2l0aCBlZmZlY3RzXG4gICAgICBpZiAoKF9yZWZyZXNoaW5nIHx8ICFzZWxmLmVuYWJsZWQpICYmICFmb3JjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW4gJiYgc29mdCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAhX3JlZnJlc2hpbmdBbGwgJiYgb25SZWZyZXNoSW5pdCAmJiBvblJlZnJlc2hJbml0KHNlbGYpO1xuICAgICAgX3JlZnJlc2hpbmcgPSBzZWxmO1xuXG4gICAgICBpZiAodHdlZW5Uby50d2VlbiAmJiAhcG9zaXRpb24pIHtcbiAgICAgICAgLy8gd2Ugc2tpcCB0aGlzIGlmIGEgcG9zaXRpb24gaXMgcGFzc2VkIGluIGJlY2F1c2UgdHlwaWNhbGx5IHRoYXQncyBmcm9tIC5zZXRQb3NpdGlvbnMoKSBhbmQgaXQncyBiZXN0IHRvIGFsbG93IGluLXByb2dyZXNzIHNuYXBwaW5nIHRvIGNvbnRpbnVlLlxuICAgICAgICB0d2VlblRvLnR3ZWVuLmtpbGwoKTtcbiAgICAgICAgdHdlZW5Uby50d2VlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpO1xuXG4gICAgICBpZiAoaW52YWxpZGF0ZU9uUmVmcmVzaCAmJiBhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnJldmVydCh7XG4gICAgICAgICAga2lsbDogZmFsc2VcbiAgICAgICAgfSkuaW52YWxpZGF0ZSgpO1xuICAgICAgICBhbmltYXRpb24uZ2V0Q2hpbGRyZW4gPyBhbmltYXRpb24uZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC52YXJzLmltbWVkaWF0ZVJlbmRlciAmJiB0LnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSkgOiBhbmltYXRpb24udmFycy5pbW1lZGlhdGVSZW5kZXIgJiYgYW5pbWF0aW9uLnJlbmRlcigwLCB0cnVlLCB0cnVlKTsgLy8gYW55IGZyb20oKSBvciBmcm9tVG8oKSB0d2VlbnMgc2hvdWxkIHJlbmRlciBpbW1lZGlhdGVseSAod2VsbCwgdW5sZXNzIHRoZXkgaGF2ZSBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlKVxuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUmV2ZXJ0ZWQgfHwgc2VsZi5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICBzZWxmLl9zdWJQaW5PZmZzZXQgPSBmYWxzZTsgLy8gd2UnbGwgc2V0IHRoaXMgdG8gdHJ1ZSBpbiB0aGUgc3ViLXBpbnMgaWYgd2UgZmluZCBhbnlcblxuICAgICAgdmFyIHNpemUgPSBnZXRTY3JvbGxlclNpemUoKSxcbiAgICAgICAgICBzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuICAgICAgICAgIG1heCA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpIDogX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgICBpc0ZpcnN0UmVmcmVzaCA9IGNoYW5nZSA8PSAwLjAxIHx8ICFjaGFuZ2UsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBvdGhlclBpbk9mZnNldCA9IHBpbk9mZnNldCB8fCAwLFxuICAgICAgICAgIHBhcnNlZEVuZCA9IF9pc09iamVjdChwb3NpdGlvbikgPyBwb3NpdGlvbi5lbmQgOiB2YXJzLmVuZCxcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG4gICAgICAgICAgcGFyc2VkU3RhcnQgPSBfaXNPYmplY3QocG9zaXRpb24pID8gcG9zaXRpb24uc3RhcnQgOiB2YXJzLnN0YXJ0IHx8ICh2YXJzLnN0YXJ0ID09PSAwIHx8ICF0cmlnZ2VyID8gMCA6IHBpbiA/IFwiMCAwXCIgOiBcIjAgMTAwJVwiKSxcbiAgICAgICAgICBwaW5uZWRDb250YWluZXIgPSBzZWxmLnBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIsIHNlbGYpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnMsXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3csXG4gICAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQsXG4gICAgICAgICAgbWFya2VyRW5kT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VycyAmJiBfaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIC8vIGlmIHdlIGFsdGVyIHRoZSBzdGFydC9lbmQgcG9zaXRpb25zIHdpdGggLnNldFBvc2l0aW9ucygpLCBpdCBnZW5lcmFsbHkgZmVlZHMgaW4gYWJzb2x1dGUgTlVNQkVSUyB3aGljaCBkb24ndCBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgd2hlcmUgdG8gbGluZSB1cCB0aGUgbWFya2Vycywgc28gdG8ga2VlcCBpdCBpbnR1aXRpdmUsIHdlIHJlY29yZCBob3cgZmFyIHRoZSB0cmlnZ2VyIHBvc2l0aW9ucyBzaGlmdCBhZnRlciBhcHBseWluZyB0aGUgbmV3IG51bWJlcnMgYW5kIHRoZW4gb2Zmc2V0IGJ5IHRoYXQgbXVjaCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLiBXZSBkbyB0aGUgc2FtZSB0byB0aGUgYXNzb2NpYXRlZCB0cmlnZ2VyIG1hcmtlcnMgdG9vIG9mIGNvdXJzZS5cbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuICAgICAgICBtYXJrZXJFbmRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSBzZWxmKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblxuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcblxuICAgICAgICBpZiAoY3VyUGluICYmIChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW4gfHwgY3VyUGluID09PSBwaW5uZWRDb250YWluZXIpICYmICFjdXJUcmlnZ2VyLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgICByZXZlcnRlZFBpbnMgfHwgKHJldmVydGVkUGlucyA9IFtdKTtcbiAgICAgICAgICByZXZlcnRlZFBpbnMudW5zaGlmdChjdXJUcmlnZ2VyKTsgLy8gd2UnbGwgcmV2ZXJ0IGZyb20gZmlyc3QgdG8gbGFzdCB0byBtYWtlIHN1cmUgdGhpbmdzIHJlYWNoIHRoZWlyIGVuZCBzdGF0ZSBwcm9wZXJseVxuXG4gICAgICAgICAgY3VyVHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VyVHJpZ2dlciAhPT0gX3RyaWdnZXJzW2ldKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBpdCBnb3QgcmVtb3ZlZC5cbiAgICAgICAgICB0cmlnZ2VySW5kZXgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2lzRnVuY3Rpb24ocGFyc2VkU3RhcnQpICYmIChwYXJzZWRTdGFydCA9IHBhcnNlZFN0YXJ0KHNlbGYpKTtcbiAgICAgIHBhcnNlZFN0YXJ0ID0gX3BhcnNlQ2xhbXAocGFyc2VkU3RhcnQsIFwic3RhcnRcIiwgc2VsZik7XG4gICAgICBzdGFydCA9IF9wYXJzZVBvc2l0aW9uKHBhcnNlZFN0YXJ0LCB0cmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNjcm9sbEZ1bmMoKSwgbWFya2VyU3RhcnQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbiwgc2VsZi5fc3RhcnRDbGFtcCAmJiBcIl9zdGFydENsYW1wXCIpIHx8IChwaW4gPyAtMC4wMDEgOiAwKTtcbiAgICAgIF9pc0Z1bmN0aW9uKHBhcnNlZEVuZCkgJiYgKHBhcnNlZEVuZCA9IHBhcnNlZEVuZChzZWxmKSk7XG5cbiAgICAgIGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuICAgICAgICBpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuICAgICAgICAgIHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG4gICAgICAgICAgcGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogKGNvbnRhaW5lckFuaW1hdGlvbiA/IGdzYXAudXRpbHMubWFwUmFuZ2UoMCwgY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCksIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLnN0YXJ0LCBjb250YWluZXJBbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5lbmQsIHN0YXJ0KSA6IHN0YXJ0KSArIG9mZnNldDsgLy8gX3BhcnNlUG9zaXRpb24gd29uJ3QgZmFjdG9yIGluIHRoZSBvZmZzZXQgaWYgdGhlIHN0YXJ0IGlzIGEgbnVtYmVyLCBzbyBkbyBpdCBoZXJlLlxuXG4gICAgICAgICAgcGFyc2VkRW5kVHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyc2VkRW5kID0gX3BhcnNlQ2xhbXAocGFyc2VkRW5kLCBcImVuZFwiLCBzZWxmKTtcbiAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBfcGFyc2VQb3NpdGlvbihwYXJzZWRFbmQgfHwgKHBhcnNlZEVuZFRyaWdnZXIgPyBcIjEwMCUgMFwiIDogbWF4KSwgcGFyc2VkRW5kVHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbiwgc2VsZi5fZW5kQ2xhbXAgJiYgXCJfZW5kQ2xhbXBcIikpIHx8IC0wLjAwMTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpID0gdHJpZ2dlckluZGV4O1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV0gfHwge307XG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPD0gc3RhcnQgJiYgIWNvbnRhaW5lckFuaW1hdGlvbiAmJiBjdXJUcmlnZ2VyLmVuZCA+IDApIHtcbiAgICAgICAgICBjcyA9IGN1clRyaWdnZXIuZW5kIC0gKHNlbGYuX3N0YXJ0Q2xhbXAgPyBNYXRoLm1heCgwLCBjdXJUcmlnZ2VyLnN0YXJ0KSA6IGN1clRyaWdnZXIuc3RhcnQpO1xuXG4gICAgICAgICAgaWYgKChjdXJQaW4gPT09IHRyaWdnZXIgJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPCBzdGFydCB8fCBjdXJQaW4gPT09IHBpbm5lZENvbnRhaW5lcikgJiYgaXNOYU4ocGFyc2VkU3RhcnQpKSB7XG4gICAgICAgICAgICAvLyBudW1lcmljIHN0YXJ0IHZhbHVlcyBzaG91bGRuJ3QgYmUgb2Zmc2V0IGF0IGFsbCAtIHRyZWF0IHRoZW0gYXMgYWJzb2x1dGVcbiAgICAgICAgICAgIG9mZnNldCArPSBjcyAqICgxIC0gY3VyVHJpZ2dlci5wcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyUGluID09PSBwaW4gJiYgKG90aGVyUGluT2Zmc2V0ICs9IGNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgICAgc2VsZi5fc3RhcnRDbGFtcCAmJiAoc2VsZi5fc3RhcnRDbGFtcCArPSBvZmZzZXQpO1xuXG4gICAgICBpZiAoc2VsZi5fZW5kQ2xhbXAgJiYgIV9yZWZyZXNoaW5nQWxsKSB7XG4gICAgICAgIHNlbGYuX2VuZENsYW1wID0gZW5kIHx8IC0wLjAwMTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pKTtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlID0gZW5kIC0gc3RhcnQgfHwgKHN0YXJ0IC09IDAuMDEpICYmIDAuMDAxO1xuXG4gICAgICBpZiAoaXNGaXJzdFJlZnJlc2gpIHtcbiAgICAgICAgLy8gb24gdGhlIHZlcnkgZmlyc3QgcmVmcmVzaCgpLCB0aGUgcHJldlByb2dyZXNzIGNvdWxkbid0IGhhdmUgYmVlbiBhY2N1cmF0ZSB5ZXQgYmVjYXVzZSB0aGUgc3RhcnQvZW5kIHdlcmUgbmV2ZXIgY2FsY3VsYXRlZCwgc28gd2Ugc2V0IGl0IGhlcmUuIEJlZm9yZSAzLjExLjUsIGl0IGNvdWxkIGxlYWQgdG8gYW4gaW5hY2N1cmF0ZSBzY3JvbGwgcG9zaXRpb24gcmVzdG9yYXRpb24gd2l0aCBzbmFwcGluZy5cbiAgICAgICAgcHJldlByb2dyZXNzID0gZ3NhcC51dGlscy5jbGFtcCgwLCAxLCBnc2FwLnV0aWxzLm5vcm1hbGl6ZShzdGFydCwgZW5kLCBwcmV2U2Nyb2xsKSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3BpblB1c2ggPSBvdGhlclBpbk9mZnNldDtcblxuICAgICAgaWYgKG1hcmtlclN0YXJ0ICYmIG9mZnNldCkge1xuICAgICAgICAvLyBvZmZzZXQgdGhlIG1hcmtlcnMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGNzID0ge307XG4gICAgICAgIGNzW2RpcmVjdGlvbi5hXSA9IFwiKz1cIiArIG9mZnNldDtcbiAgICAgICAgcGlubmVkQ29udGFpbmVyICYmIChjc1tkaXJlY3Rpb24ucF0gPSBcIi09XCIgKyBzY3JvbGxGdW5jKCkpO1xuICAgICAgICBnc2FwLnNldChbbWFya2VyU3RhcnQsIG1hcmtlckVuZF0sIGNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbiAmJiAhKF9jbGFtcGluZ01heCAmJiBzZWxmLmVuZCA+PSBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pKSkge1xuICAgICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG4gICAgICAgIGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbDtcbiAgICAgICAgc2Nyb2xsID0gc2Nyb2xsRnVuYygpOyAvLyByZWNhbGN1bGF0ZSBiZWNhdXNlIHRoZSB0cmlnZ2VycyBjYW4gYWZmZWN0IHRoZSBzY3JvbGxcblxuICAgICAgICBwaW5TdGFydCA9IHBhcnNlRmxvYXQocGluR2V0dGVyKGRpcmVjdGlvbi5hKSkgKyBvdGhlclBpbk9mZnNldDtcblxuICAgICAgICBpZiAoIW1heCAmJiBlbmQgPiAxKSB7XG4gICAgICAgICAgLy8gbWFrZXMgc3VyZSB0aGUgc2Nyb2xsZXIgaGFzIGEgc2Nyb2xsYmFyLCBvdGhlcndpc2UgaWYgc29tZXRoaW5nIGhhcyB3aWR0aDogMTAwJSwgZm9yIGV4YW1wbGUsIGl0IHdvdWxkIGJlIHRvbyBiaWcgKGV4Y2x1ZGUgdGhlIHNjcm9sbGJhcikuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yNTE4Mi1zY3JvbGx0cmlnZ2VyLXdpZHRoLW9mLXBhZ2UtaW5jcmVhc2Utd2hlcmUtbWFya2Vycy1hcmUtc2V0LXRvLWZhbHNlL1xuICAgICAgICAgIGZvcmNlZE92ZXJmbG93ID0gKGlzVmlld3BvcnQgPyBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsIDogc2Nyb2xsZXIpLnN0eWxlO1xuICAgICAgICAgIGZvcmNlZE92ZXJmbG93ID0ge1xuICAgICAgICAgICAgc3R5bGU6IGZvcmNlZE92ZXJmbG93LFxuICAgICAgICAgICAgdmFsdWU6IGZvcmNlZE92ZXJmbG93W1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChpc1ZpZXdwb3J0ICYmIF9nZXRDb21wdXRlZFN0eWxlKF9ib2R5KVtcIm92ZXJmbG93XCIgKyBkaXJlY3Rpb24uYS50b1VwcGVyQ2FzZSgpXSAhPT0gXCJzY3JvbGxcIikge1xuICAgICAgICAgICAgLy8gYXZvaWQgYW4gZXh0cmEgc2Nyb2xsYmFyIGlmIEJPVEggPGh0bWw+IGFuZCA8Ym9keT4gaGF2ZSBvdmVyZmxvdyBzZXQgdG8gXCJzY3JvbGxcIlxuICAgICAgICAgICAgZm9yY2VkT3ZlcmZsb3cuc3R5bGVbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV0gPSBcInNjcm9sbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblxuICAgICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pOyAvLyB0cmFuc2Zvcm1zIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBwbGFjZW1lbnQsIHNvIHJlbW92ZSB0aGVtIHRlbXBvcmFyaWx5LiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmYWN0b3JzIGluIHRyYW5zZm9ybXMuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpO1xuICAgICAgICBvcHBvc2l0ZVNjcm9sbCA9IHVzZUZpeGVkUG9zaXRpb24gJiYgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGlzVmVydGljYWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCkoKTtcblxuICAgICAgICBpZiAocGluU3BhY2luZykge1xuICAgICAgICAgIHNwYWNlclN0YXRlID0gW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyLCBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldCArIF9weF07XG4gICAgICAgICAgc3BhY2VyU3RhdGUudCA9IHNwYWNlcjtcbiAgICAgICAgICBpID0gcGluU3BhY2luZyA9PT0gX3BhZGRpbmcgPyBfZ2V0U2l6ZShwaW4sIGRpcmVjdGlvbikgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldCA6IDA7XG5cbiAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgc3BhY2VyU3RhdGUucHVzaChkaXJlY3Rpb24uZCwgaSArIF9weCk7IC8vIGZvciBib3gtc2l6aW5nOiBib3JkZXItYm94IChtdXN0IGluY2x1ZGUgcGFkZGluZykuXG5cbiAgICAgICAgICAgIHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgIT09IFwiYXV0b1wiICYmIChzcGFjZXIuc3R5bGUuZmxleEJhc2lzID0gaSArIF9weCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblxuICAgICAgICAgIGlmIChwaW5uZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vIGluIFNjcm9sbFRyaWdnZXIucmVmcmVzaCgpLCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIHRoZSBwaW5Db250YWluZXIncyBzaXplIGJlY2F1c2UgdGhpcyBwaW5TcGFjaW5nIG1heSBzdHJldGNoIGl0IG91dCwgYnV0IHdlIGNhbid0IGp1c3QgYWRkIHRoZSBleGFjdCBkaXN0YW5jZSBiZWNhdXNlIGRlcGVuZGluZyBvbiBsYXlvdXQsIGl0IG1heSBub3QgcHVzaCB0aGluZ3MgZG93biBvciBpdCBtYXkgb25seSBkbyBzbyBwYXJ0aWFsbHkuXG4gICAgICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBpZiAodC5waW4gPT09IHBpbm5lZENvbnRhaW5lciAmJiB0LnZhcnMucGluU3BhY2luZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0Ll9zdWJQaW5PZmZzZXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IF9nZXRTaXplKHBpbiwgZGlyZWN0aW9uKTtcbiAgICAgICAgICBpICYmIHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgIT09IFwiYXV0b1wiICYmIChzcGFjZXIuc3R5bGUuZmxleEJhc2lzID0gaSArIF9weCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgICAgIG92ZXJyaWRlID0ge1xuICAgICAgICAgICAgdG9wOiBib3VuZHMudG9wICsgKGlzVmVydGljYWwgPyBzY3JvbGwgLSBzdGFydCA6IG9wcG9zaXRlU2Nyb2xsKSArIF9weCxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgKGlzVmVydGljYWwgPyBvcHBvc2l0ZVNjcm9sbCA6IHNjcm9sbCAtIHN0YXJ0KSArIF9weCxcbiAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvdmVycmlkZVtfd2lkdGhdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9XaWR0aF0gPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoKSArIF9weDtcbiAgICAgICAgICBvdmVycmlkZVtfaGVpZ2h0XSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KSArIF9weDtcbiAgICAgICAgICBvdmVycmlkZVtfbWFyZ2luXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfVG9wXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfUmlnaHRdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Cb3R0b21dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9MZWZ0XSA9IFwiMFwiO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Ub3BdID0gY3NbX3BhZGRpbmcgKyBfVG9wXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9SaWdodF0gPSBjc1tfcGFkZGluZyArIF9SaWdodF07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfQm90dG9tXSA9IGNzW19wYWRkaW5nICsgX0JvdHRvbV07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfTGVmdF0gPSBjc1tfcGFkZGluZyArIF9MZWZ0XTtcbiAgICAgICAgICBwaW5BY3RpdmVTdGF0ZSA9IF9jb3B5U3RhdGUocGluT3JpZ2luYWxTdGF0ZSwgb3ZlcnJpZGUsIHBpblJlcGFyZW50KTtcbiAgICAgICAgICBfcmVmcmVzaGluZ0FsbCAmJiBzY3JvbGxGdW5jKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gbWlnaHQgYmUgYWZmZWN0aW5nIHRoZSB0cmFuc2Zvcm0sIHNvIHdlIG11c3QganVtcCB0byB0aGUgZW5kLCBjaGVjayB0aGUgdmFsdWUsIGFuZCBjb21wZW5zYXRlIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIHdoZW4gaXQgYmVjb21lcyB1bnBpbm5lZCwgdGhlIHBpblNldHRlcigpIHdpbGwgZ2V0IHNldCB0byBhIHZhbHVlIHRoYXQgZG9lc24ndCBpbmNsdWRlIHdoYXRldmVyIHRoZSBhbmltYXRpb24gZGlkLlxuICAgICAgICAgIGluaXR0ZWQgPSBhbmltYXRpb24uX2luaXR0ZWQ7IC8vIGlmIG5vdCwgd2UgbXVzdCBpbnZhbGlkYXRlKCkgYWZ0ZXIgdGhpcyBzdGVwLCBvdGhlcndpc2UgaXQgY291bGQgbG9jayBpbiBzdGFydGluZyB2YWx1ZXMgcHJlbWF0dXJlbHkuXG5cbiAgICAgICAgICBfc3VwcHJlc3NPdmVyd3JpdGVzKDEpO1xuXG4gICAgICAgICAgYW5pbWF0aW9uLnJlbmRlcihhbmltYXRpb24uZHVyYXRpb24oKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgcGluQ2hhbmdlID0gcGluR2V0dGVyKGRpcmVjdGlvbi5hKSAtIHBpblN0YXJ0ICsgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQ7XG4gICAgICAgICAgcGluTW92ZXMgPSBNYXRoLmFicyhjaGFuZ2UgLSBwaW5DaGFuZ2UpID4gMTtcbiAgICAgICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIHBpbk1vdmVzICYmIHBpbkFjdGl2ZVN0YXRlLnNwbGljZShwaW5BY3RpdmVTdGF0ZS5sZW5ndGggLSAyLCAyKTsgLy8gdHJhbnNmb3JtIGlzIHRoZSBsYXN0IHByb3BlcnR5L3ZhbHVlIHNldCBpbiB0aGUgc3RhdGUgQXJyYXkuIFNpbmNlIHRoZSBhbmltYXRpb24gaXMgY29udHJvbGxpbmcgdGhhdCwgd2Ugc2hvdWxkIG9taXQgaXQuXG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGluaXR0ZWQgfHwgYW5pbWF0aW9uLmludmFsaWRhdGUodHJ1ZSk7XG4gICAgICAgICAgYW5pbWF0aW9uLnBhcmVudCB8fCBhbmltYXRpb24udG90YWxUaW1lKGFuaW1hdGlvbi50b3RhbFRpbWUoKSk7IC8vIGlmLCBmb3IgZXhhbXBsZSwgYSB0b2dnbGVBY3Rpb24gY2FsbGVkIHBsYXkoKSBhbmQgdGhlbiByZWZyZXNoKCkgaGFwcGVucyBhbmQgd2hlbiB3ZSByZW5kZXIoMSkgYWJvdmUsIGl0IHdvdWxkIGNhdXNlIHRoZSBhbmltYXRpb24gdG8gY29tcGxldGUgYW5kIGdldCByZW1vdmVkIGZyb20gaXRzIHBhcmVudCwgc28gdGhpcyBtYWtlcyBzdXJlIGl0IGdldHMgcHV0IGJhY2sgaW4uXG5cbiAgICAgICAgICBfc3VwcHJlc3NPdmVyd3JpdGVzKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBpbkNoYW5nZSA9IGNoYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmNlZE92ZXJmbG93ICYmIChmb3JjZWRPdmVyZmxvdy52YWx1ZSA/IGZvcmNlZE92ZXJmbG93LnN0eWxlW1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldID0gZm9yY2VkT3ZlcmZsb3cudmFsdWUgOiBmb3JjZWRPdmVyZmxvdy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIm92ZXJmbG93LVwiICsgZGlyZWN0aW9uLmEpKTtcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAmJiBzY3JvbGxGdW5jKCkgJiYgIWNvbnRhaW5lckFuaW1hdGlvbikge1xuICAgICAgICAvLyBpdCBtYXkgYmUgSU5TSURFIGEgcGlubmVkIGVsZW1lbnQsIHNvIHdhbGsgdXAgdGhlIHRyZWUgYW5kIGxvb2sgZm9yIGFueSBlbGVtZW50cyB3aXRoIF9waW5PZmZzZXQgdG8gY29tcGVuc2F0ZSBiZWNhdXNlIGFueXRoaW5nIHdpdGggcGluU3BhY2luZyB0aGF0J3MgYWxyZWFkeSBzY3JvbGxlZCB3b3VsZCB0aHJvdyBvZmYgdGhlIG1lYXN1cmVtZW50cyBpbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBib3VuZHMgPSB0cmlnZ2VyLnBhcmVudE5vZGU7XG5cbiAgICAgICAgd2hpbGUgKGJvdW5kcyAmJiBib3VuZHMgIT09IF9ib2R5KSB7XG4gICAgICAgICAgaWYgKGJvdW5kcy5fcGluT2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcbiAgICAgICAgICAgIGVuZCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZHMgPSBib3VuZHMucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXZlcnRlZFBpbnMgJiYgcmV2ZXJ0ZWRQaW5zLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQucmV2ZXJ0KGZhbHNlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgc2VsZi5lbmQgPSBlbmQ7XG4gICAgICBzY3JvbGwxID0gc2Nyb2xsMiA9IF9yZWZyZXNoaW5nQWxsID8gcHJldlNjcm9sbCA6IHNjcm9sbEZ1bmMoKTsgLy8gcmVzZXQgdmVsb2NpdHlcblxuICAgICAgaWYgKCFjb250YWluZXJBbmltYXRpb24gJiYgIV9yZWZyZXNoaW5nQWxsKSB7XG4gICAgICAgIHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XG4gICAgICAgIHNlbGYuc2Nyb2xsLnJlYyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmV2ZXJ0KGZhbHNlLCB0cnVlKTtcbiAgICAgIGxhc3RSZWZyZXNoID0gX2dldFRpbWUoKTtcblxuICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICBsYXN0U25hcCA9IC0xOyAvLyBqdXN0IHNvIHNuYXBwaW5nIGdldHMgcmUtZW5hYmxlZCwgY2xlYXIgb3V0IGFueSByZWNvcmRlZCBsYXN0IHZhbHVlXG4gICAgICAgIC8vIHNlbGYuaXNBY3RpdmUgJiYgc2Nyb2xsRnVuYyhzdGFydCArIGNoYW5nZSAqIHByZXZQcm9ncmVzcyk7IC8vIHByZXZpb3VzbHkgdGhpcyBsaW5lIHdhcyBoZXJlIHRvIGVuc3VyZSB0aGF0IHdoZW4gc25hcHBpbmcga2lja3MgaW4sIGl0J3MgZnJvbSB0aGUgcHJldmlvdXMgcHJvZ3Jlc3MgYnV0IGluIHNvbWUgY2FzZXMgdGhhdCdzIG5vdCBkZXNpcmFibGUsIGxpa2UgYW4gYWxsLXBhZ2UgU2Nyb2xsVHJpZ2dlciB3aGVuIG5ldyBjb250ZW50IGdldHMgYWRkZWQgdG8gdGhlIHBhZ2UsIHRoYXQnZCB0b3RhbGx5IGNoYW5nZSB0aGUgcHJvZ3Jlc3MuXG5cbiAgICAgICAgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIF9yZWZyZXNoaW5nID0gMDtcbiAgICAgIGFuaW1hdGlvbiAmJiBpc1RvZ2dsZSAmJiAoYW5pbWF0aW9uLl9pbml0dGVkIHx8IHByZXZBbmltUHJvZ3Jlc3MpICYmIGFuaW1hdGlvbi5wcm9ncmVzcygpICE9PSBwcmV2QW5pbVByb2dyZXNzICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhwcmV2QW5pbVByb2dyZXNzIHx8IDAsIHRydWUpLnJlbmRlcihhbmltYXRpb24udGltZSgpLCB0cnVlLCB0cnVlKTsgLy8gbXVzdCBmb3JjZSBhIHJlLXJlbmRlciBiZWNhdXNlIGlmIHNhdmVTdHlsZXMoKSB3YXMgdXNlZCBvbiB0aGUgdGFyZ2V0KHMpLCB0aGUgc3R5bGVzIGNvdWxkIGhhdmUgYmVlbiB3aXBlZCBvdXQgZHVyaW5nIHRoZSByZWZyZXNoKCkuXG5cbiAgICAgIGlmIChpc0ZpcnN0UmVmcmVzaCB8fCBwcmV2UHJvZ3Jlc3MgIT09IHNlbGYucHJvZ3Jlc3MgfHwgY29udGFpbmVyQW5pbWF0aW9uIHx8IGludmFsaWRhdGVPblJlZnJlc2ggfHwgYW5pbWF0aW9uICYmICFhbmltYXRpb24uX2luaXR0ZWQpIHtcbiAgICAgICAgLy8gZW5zdXJlcyB0aGF0IHRoZSBkaXJlY3Rpb24gaXMgc2V0IHByb3Blcmx5ICh3aGVuIHJlZnJlc2hpbmcsIHByb2dyZXNzIGlzIHNldCBiYWNrIHRvIDAgaW5pdGlhbGx5LCB0aGVuIGJhY2sgYWdhaW4gdG8gd2hlcmV2ZXIgaXQgbmVlZHMgdG8gYmUpIGFuZCB0aGF0IGNhbGxiYWNrcyBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICBhbmltYXRpb24gJiYgIWlzVG9nZ2xlICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgcHJldlByb2dyZXNzIHx8IGFuaW1hdGlvbi52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpICYmIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKGNvbnRhaW5lckFuaW1hdGlvbiAmJiBzdGFydCA8IC0wLjAwMSAmJiAhcHJldlByb2dyZXNzID8gZ3NhcC51dGlscy5ub3JtYWxpemUoc3RhcnQsIGVuZCwgMCkgOiBwcmV2UHJvZ3Jlc3MsIHRydWUpOyAvLyB0byBhdm9pZCBpc3N1ZXMgd2hlcmUgYW5pbWF0aW9uIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQgYXJlbid0IHRyaWdnZXJlZC5cblxuICAgICAgICBzZWxmLnByb2dyZXNzID0gaXNGaXJzdFJlZnJlc2ggfHwgKHNjcm9sbDEgLSBzdGFydCkgLyBjaGFuZ2UgPT09IHByZXZQcm9ncmVzcyA/IDAgOiBwcmV2UHJvZ3Jlc3M7XG4gICAgICB9XG5cbiAgICAgIHBpbiAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuX3Bpbk9mZnNldCA9IE1hdGgucm91bmQoc2VsZi5wcm9ncmVzcyAqIHBpbkNoYW5nZSkpO1xuICAgICAgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLmludmFsaWRhdGUoKTtcblxuICAgICAgaWYgKCFpc05hTihtYXJrZXJTdGFydE9mZnNldCkpIHtcbiAgICAgICAgLy8gbnVtYmVycyB3ZXJlIHBhc3NlZCBpbiBmb3IgdGhlIHBvc2l0aW9uIHdoaWNoIGFyZSBhYnNvbHV0ZSwgc28gaW5zdGVhZCBvZiBqdXN0IHB1dHRpbmcgdGhlIG1hcmtlcnMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSB2aWV3cG9ydCwgd2UgZmlndXJlIG91dCBob3cgZmFyIHRoZXkgc2hpZnRlZCBkb3duIChpdCdzIHNhZmUgdG8gYXNzdW1lIHRoZXkgd2VyZSBvcmlnaW5hbGx5IHBvc2l0aW9uZWQgaW4gY2xvc2VyIHJlbGF0aW9uIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnQgd2l0aCB2YWx1ZXMgbGlrZSBcInRvcFwiLCBcImNlbnRlclwiLCBhIHBlcmNlbnRhZ2Ugb3Igd2hhdGV2ZXIsIHNvIHdlIG9mZnNldCB0aGF0IG11Y2ggaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0byBiYXNpY2FsbHkgcmV2ZXJ0IHRoZW0gdG8gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRoeSB3ZXJlIGF0IHByZXZpb3VzbHkuXG4gICAgICAgIG1hcmtlclN0YXJ0T2Zmc2V0IC09IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyU3RhcnRUcmlnZ2VyLCBkaXJlY3Rpb24ucCk7XG4gICAgICAgIG1hcmtlckVuZE9mZnNldCAtPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcblxuICAgICAgICBfc2hpZnRNYXJrZXIobWFya2VyU3RhcnRUcmlnZ2VyLCBkaXJlY3Rpb24sIG1hcmtlclN0YXJ0T2Zmc2V0KTtcblxuICAgICAgICBfc2hpZnRNYXJrZXIobWFya2VyU3RhcnQsIGRpcmVjdGlvbiwgbWFya2VyU3RhcnRPZmZzZXQgLSAocGluT2Zmc2V0IHx8IDApKTtcblxuICAgICAgICBfc2hpZnRNYXJrZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLCBtYXJrZXJFbmRPZmZzZXQpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJFbmQsIGRpcmVjdGlvbiwgbWFya2VyRW5kT2Zmc2V0IC0gKHBpbk9mZnNldCB8fCAwKSk7XG4gICAgICB9XG5cbiAgICAgIGlzRmlyc3RSZWZyZXNoICYmICFfcmVmcmVzaGluZ0FsbCAmJiBzZWxmLnVwZGF0ZSgpOyAvLyBlZGdlIGNhc2UgLSB3aGVuIHlvdSByZWxvYWQgYSBwYWdlIHdoZW4gaXQncyBhbHJlYWR5IHNjcm9sbGVkIGRvd24sIHNvbWUgYnJvd3NlcnMgZmlyZSBhIFwic2Nyb2xsXCIgZXZlbnQgYmVmb3JlIERPTUNvbnRlbnRMb2FkZWQsIHRyaWdnZXJpbmcgYW4gdXBkYXRlQWxsKCkuIElmIHdlIGRvbid0IHVwZGF0ZSB0aGUgc2VsZi5wcm9ncmVzcyBhcyBwYXJ0IG9mIHJlZnJlc2goKSwgdGhlbiB3aGVuIGl0IGhhcHBlbnMgbmV4dCwgaXQgbWF5IHJlY29yZCBwcmV2UHJvZ3Jlc3MgYXMgMCB3aGVuIGl0IHJlYWxseSBzaG91bGRuJ3QsIHBvdGVudGlhbGx5IGNhdXNpbmcgYSBjYWxsYmFjayBpbiBhbiBhbmltYXRpb24gdG8gZmlyZSBhZ2Fpbi5cblxuICAgICAgaWYgKG9uUmVmcmVzaCAmJiAhX3JlZnJlc2hpbmdBbGwgJiYgIWV4ZWN1dGluZ09uUmVmcmVzaCkge1xuICAgICAgICAvLyB3aGVuIHJlZnJlc2hpbmcgYWxsLCB3ZSBkbyBleHRyYSB3b3JrIHRvIGNvcnJlY3QgcGlubmVkQ29udGFpbmVyIHNpemVzIGFuZCBlbnN1cmUgdGhpbmdzIGRvbid0IGV4Y2VlZCB0aGUgbWF4U2Nyb2xsLCBzbyB3ZSBzaG91bGQgZG8gYWxsIHRoZSByZWZyZXNoZXMgYXQgdGhlIGVuZCBhZnRlciBhbGwgdGhhdCB3b3JrIHNvIHRoYXQgdGhlIHN0YXJ0L2VuZCB2YWx1ZXMgYXJlIGNvcnJlY3RlZC5cbiAgICAgICAgZXhlY3V0aW5nT25SZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgb25SZWZyZXNoKHNlbGYpO1xuICAgICAgICBleGVjdXRpbmdPblJlZnJlc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoc2Nyb2xsRnVuYygpIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwIHx8IDA7XG4gICAgfTtcblxuICAgIHNlbGYuZW5kQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgX2VuZEFuaW1hdGlvbihzZWxmLmNhbGxiYWNrQW5pbWF0aW9uKTtcblxuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBzY3J1YlR3ZWVuID8gc2NydWJUd2Vlbi5wcm9ncmVzcygxKSA6ICFhbmltYXRpb24ucGF1c2VkKCkgPyBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLnJldmVyc2VkKCkpIDogaXNUb2dnbGUgfHwgX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIHNlbGYuZGlyZWN0aW9uIDwgMCwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYubGFiZWxUb1Njcm9sbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ubGFiZWxzICYmIChzdGFydCB8fCBzZWxmLnJlZnJlc2goKSB8fCBzdGFydCkgKyBhbmltYXRpb24ubGFiZWxzW2xhYmVsXSAvIGFuaW1hdGlvbi5kdXJhdGlvbigpICogY2hhbmdlIHx8IDA7XG4gICAgfTtcblxuICAgIHNlbGYuZ2V0VHJhaWxpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSxcbiAgICAgICAgICBhID0gc2VsZi5kaXJlY3Rpb24gPiAwID8gX3RyaWdnZXJzLnNsaWNlKDAsIGkpLnJldmVyc2UoKSA6IF90cmlnZ2Vycy5zbGljZShpICsgMSk7XG5cbiAgICAgIHJldHVybiAoX2lzU3RyaW5nKG5hbWUpID8gYS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQudmFycy5wcmV2ZW50T3ZlcmxhcHMgPT09IG5hbWU7XG4gICAgICB9KSA6IGEpLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gc2VsZi5kaXJlY3Rpb24gPiAwID8gdC5lbmQgPD0gc3RhcnQgOiB0LnN0YXJ0ID49IGVuZDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVjb3JkVmVsb2NpdHksIGZvcmNlRmFrZSkge1xuICAgICAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiAhZm9yY2VGYWtlICYmICFyZXNldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGwgPSBfcmVmcmVzaGluZ0FsbCA9PT0gdHJ1ZSA/IHByZXZTY3JvbGwgOiBzZWxmLnNjcm9sbCgpLFxuICAgICAgICAgIHAgPSByZXNldCA/IDAgOiAoc2Nyb2xsIC0gc3RhcnQpIC8gY2hhbmdlLFxuICAgICAgICAgIGNsaXBwZWQgPSBwIDwgMCA/IDAgOiBwID4gMSA/IDEgOiBwIHx8IDAsXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcyxcbiAgICAgICAgICBpc0FjdGl2ZSxcbiAgICAgICAgICB3YXNBY3RpdmUsXG4gICAgICAgICAgdG9nZ2xlU3RhdGUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIHN0YXRlQ2hhbmdlZCxcbiAgICAgICAgICB0b2dnbGVkLFxuICAgICAgICAgIGlzQXRNYXgsXG4gICAgICAgICAgaXNUYWtpbmdBY3Rpb247XG5cbiAgICAgIGlmIChyZWNvcmRWZWxvY2l0eSkge1xuICAgICAgICBzY3JvbGwyID0gc2Nyb2xsMTtcbiAgICAgICAgc2Nyb2xsMSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbEZ1bmMoKSA6IHNjcm9sbDtcblxuICAgICAgICBpZiAoc25hcCkge1xuICAgICAgICAgIHNuYXAyID0gc25hcDE7XG4gICAgICAgICAgc25hcDEgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IGNsaXBwZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYW50aWNpcGF0ZSB0aGUgcGlubmluZyBhIGZldyB0aWNrcyBhaGVhZCBvZiB0aW1lIGJhc2VkIG9uIHZlbG9jaXR5IHRvIGF2b2lkIGEgdmlzdWFsIGdsaXRjaCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBtb3N0IGJyb3dzZXJzIGRvIHNjcm9sbGluZyBvbiBhIHNlcGFyYXRlIHRocmVhZCAobm90IHN5bmNlZCB3aXRoIHJlcXVlc3RBbmltYXRpb25GcmFtZSkuXG5cblxuICAgICAgaWYgKGFudGljaXBhdGVQaW4gJiYgcGluICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgX2xhc3RTY3JvbGxUaW1lKSB7XG4gICAgICAgIGlmICghY2xpcHBlZCAmJiBzdGFydCA8IHNjcm9sbCArIChzY3JvbGwgLSBzY3JvbGwyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIGFudGljaXBhdGVQaW4pIHtcbiAgICAgICAgICBjbGlwcGVkID0gMC4wMDAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNsaXBwZWQgPT09IDEgJiYgZW5kID4gc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbikge1xuICAgICAgICAgIGNsaXBwZWQgPSAwLjk5OTk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNsaXBwZWQgIT09IHByZXZQcm9ncmVzcyAmJiBzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgaXNBY3RpdmUgPSBzZWxmLmlzQWN0aXZlID0gISFjbGlwcGVkICYmIGNsaXBwZWQgPCAxO1xuICAgICAgICB3YXNBY3RpdmUgPSAhIXByZXZQcm9ncmVzcyAmJiBwcmV2UHJvZ3Jlc3MgPCAxO1xuICAgICAgICB0b2dnbGVkID0gaXNBY3RpdmUgIT09IHdhc0FjdGl2ZTtcbiAgICAgICAgc3RhdGVDaGFuZ2VkID0gdG9nZ2xlZCB8fCAhIWNsaXBwZWQgIT09ICEhcHJldlByb2dyZXNzOyAvLyBjb3VsZCBnbyBmcm9tIHN0YXJ0IGFsbCB0aGUgd2F5IHRvIGVuZCwgdGh1cyBpdCBkaWRuJ3QgdG9nZ2xlIGJ1dCBpdCBkaWQgY2hhbmdlIHN0YXRlIGluIGEgc2Vuc2UgKG1heSBuZWVkIHRvIGZpcmUgYSBjYWxsYmFjaylcblxuICAgICAgICBzZWxmLmRpcmVjdGlvbiA9IGNsaXBwZWQgPiBwcmV2UHJvZ3Jlc3MgPyAxIDogLTE7XG4gICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBjbGlwcGVkO1xuXG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZWQgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgdG9nZ2xlU3RhdGUgPSBjbGlwcGVkICYmICFwcmV2UHJvZ3Jlc3MgPyAwIDogY2xpcHBlZCA9PT0gMSA/IDEgOiBwcmV2UHJvZ3Jlc3MgPT09IDEgPyAyIDogMzsgLy8gMCA9IGVudGVyLCAxID0gbGVhdmUsIDIgPSBlbnRlckJhY2ssIDMgPSBsZWF2ZUJhY2sgKHdlIHByaW9yaXRpemUgdGhlIEZJUlNUIGVuY291bnRlciwgdGh1cyBpZiB5b3Ugc2Nyb2xsIHJlYWxseSBmYXN0IHBhc3QgdGhlIG9uRW50ZXIgYW5kIG9uTGVhdmUgaW4gb25lIHRpY2ssIGl0J2QgcHJpb3JpdGl6ZSBvbkVudGVyLlxuXG4gICAgICAgICAgaWYgKGlzVG9nZ2xlKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSAhdG9nZ2xlZCAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gIT09IFwibm9uZVwiICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSB8fCB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlXTsgLy8gaWYgaXQgZGlkbid0IHRvZ2dsZSwgdGhhdCBtZWFucyBpdCBzaG90IHJpZ2h0IHBhc3QgYW5kIHNpbmNlIHdlIHByaW9yaXRpemUgdGhlIFwiZW50ZXJcIiBhY3Rpb24sIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIFwibGVhdmVcIiBpbiB0aGlzIGNhc2UgKGJ1dCBvbmx5IGlmIG9uZSBpcyBkZWZpbmVkKVxuXG4gICAgICAgICAgICBpc1Rha2luZ0FjdGlvbiA9IGFuaW1hdGlvbiAmJiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIgfHwgYWN0aW9uID09PSBcInJlc2V0XCIgfHwgYWN0aW9uIGluIGFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldmVudE92ZXJsYXBzICYmICh0b2dnbGVkIHx8IGlzVGFraW5nQWN0aW9uKSAmJiAoaXNUYWtpbmdBY3Rpb24gfHwgc2NydWIgfHwgIWFuaW1hdGlvbikgJiYgKF9pc0Z1bmN0aW9uKHByZXZlbnRPdmVybGFwcykgPyBwcmV2ZW50T3ZlcmxhcHMoc2VsZikgOiBzZWxmLmdldFRyYWlsaW5nKHByZXZlbnRPdmVybGFwcykuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LmVuZEFuaW1hdGlvbigpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKCFpc1RvZ2dsZSkge1xuICAgICAgICAgIGlmIChzY3J1YlR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXApIHtcbiAgICAgICAgICAgIHNjcnViVHdlZW4uX2RwLl90aW1lIC0gc2NydWJUd2Vlbi5fc3RhcnQgIT09IHNjcnViVHdlZW4uX3RpbWUgJiYgc2NydWJUd2Vlbi5yZW5kZXIoc2NydWJUd2Vlbi5fZHAuX3RpbWUgLSBzY3J1YlR3ZWVuLl9zdGFydCk7IC8vIGlmIHRoZXJlJ3MgYSBzY3J1YiBvbiBib3RoIHRoZSBjb250YWluZXIgYW5pbWF0aW9uIGFuZCB0aGlzIG9uZSAob3IgYSBTY3JvbGxTbW9vdGhlciksIHRoZSB1cGRhdGUgb3JkZXIgd291bGQgY2F1c2UgdGhpcyBvbmUgbm90IHRvIGhhdmUgcmVuZGVyZWQgeWV0LCBzbyBpdCB3b3VsZG4ndCBtYWtlIGFueSBwcm9ncmVzcyBiZWZvcmUgd2UgLnJlc3RhcnQoKSBpdCBoZWFkaW5nIHRvd2FyZCB0aGUgbmV3IHByb2dyZXNzIHNvIGl0J2QgYXBwZWFyIHN0dWNrIHRodXMgd2UgZm9yY2UgYSByZW5kZXIgaGVyZS5cblxuICAgICAgICAgICAgaWYgKHNjcnViVHdlZW4ucmVzZXRUbykge1xuICAgICAgICAgICAgICBzY3J1YlR3ZWVuLnJlc2V0VG8oXCJ0b3RhbFByb2dyZXNzXCIsIGNsaXBwZWQsIGFuaW1hdGlvbi5fdFRpbWUgLyBhbmltYXRpb24uX3REdXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbGVnYWN5IHN1cHBvcnQgKGNvdXJ0ZXN5KSwgYmVmb3JlIDMuMTAuMFxuICAgICAgICAgICAgICBzY3J1YlR3ZWVuLnZhcnMudG90YWxQcm9ncmVzcyA9IGNsaXBwZWQ7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4uaW52YWxpZGF0ZSgpLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoY2xpcHBlZCwgISEoX3JlZnJlc2hpbmcgJiYgKGxhc3RSZWZyZXNoIHx8IHJlc2V0KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgICByZXNldCAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuc3R5bGVbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdID0gc3BhY2luZ1N0YXJ0KTtcblxuICAgICAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgICAgICAgcGluU2V0dGVyKF9yb3VuZChwaW5TdGFydCArIHBpbkNoYW5nZSAqIGNsaXBwZWQpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaXNBdE1heCA9ICFyZXNldCAmJiBjbGlwcGVkID4gcHJldlByb2dyZXNzICYmIGVuZCArIDEgPiBzY3JvbGwgJiYgc2Nyb2xsICsgMSA+PSBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pOyAvLyBpZiBpdCdzIGF0IHRoZSBWRVJZIGVuZCBvZiB0aGUgcGFnZSwgZG9uJ3Qgc3dpdGNoIGF3YXkgZnJvbSBwb3NpdGlvbjogZml4ZWQgYmVjYXVzZSBpdCdzIHBvaW50bGVzcyBhbmQgaXQgY291bGQgY2F1c2UgYSBicmllZiBmbGFzaCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgYmFjayB1cCAod2hlbiBpdCBnZXRzIHBpbm5lZCBhZ2FpbilcblxuICAgICAgICAgICAgaWYgKHBpblJlcGFyZW50KSB7XG4gICAgICAgICAgICAgIGlmICghcmVzZXQgJiYgKGlzQWN0aXZlIHx8IGlzQXRNYXgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgX29mZnNldCA9IHNjcm9sbCAtIHN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgX3JlcGFyZW50KHBpbiwgX2JvZHksIGJvdW5kcy50b3AgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBfb2Zmc2V0IDogMCkgKyBfcHgsIGJvdW5kcy5sZWZ0ICsgKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gMCA6IF9vZmZzZXQpICsgX3B4KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcmVwYXJlbnQocGluLCBzcGFjZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zZXRTdGF0ZShpc0FjdGl2ZSB8fCBpc0F0TWF4ID8gcGluQWN0aXZlU3RhdGUgOiBwaW5TdGF0ZSk7XG5cbiAgICAgICAgICAgIHBpbk1vdmVzICYmIGNsaXBwZWQgPCAxICYmIGlzQWN0aXZlIHx8IHBpblNldHRlcihwaW5TdGFydCArIChjbGlwcGVkID09PSAxICYmICFpc0F0TWF4ID8gcGluQ2hhbmdlIDogMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNuYXAgJiYgIXR3ZWVuVG8udHdlZW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCAmJiBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MgJiYgKHRvZ2dsZWQgfHwgb25jZSAmJiBjbGlwcGVkICYmIChjbGlwcGVkIDwgMSB8fCAhX2xpbWl0Q2FsbGJhY2tzKSkgJiYgX3RvQXJyYXkodG9nZ2xlQ2xhc3MudGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0W2lzQWN0aXZlIHx8IG9uY2UgPyBcImFkZFwiIDogXCJyZW1vdmVcIl0odG9nZ2xlQ2xhc3MuY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7IC8vIGNsYXNzZXMgY291bGQgYWZmZWN0IHBvc2l0aW9uaW5nLCBzbyBkbyBpdCBldmVuIGlmIHJlc2V0IG9yIHJlZnJlc2hpbmcgaXMgdHJ1ZS5cblxuICAgICAgICBvblVwZGF0ZSAmJiAhaXNUb2dnbGUgJiYgIXJlc2V0ICYmIG9uVXBkYXRlKHNlbGYpO1xuXG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZWQgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgaWYgKGlzVG9nZ2xlKSB7XG4gICAgICAgICAgICBpZiAoaXNUYWtpbmdBY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnBhdXNlKCkudG90YWxQcm9ncmVzcygxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmVzZXRcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5yZXN0YXJ0KHRydWUpLnBhdXNlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc3RhcnRcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5yZXN0YXJ0KHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvblthY3Rpb25dKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25VcGRhdGUgJiYgb25VcGRhdGUoc2VsZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRvZ2dsZWQgfHwgIV9saW1pdENhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gb24gc3RhcnR1cCwgdGhlIHBhZ2UgY291bGQgYmUgc2Nyb2xsZWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBjYWxsYmFja3MgdGhhdCBkaWRuJ3QgdG9nZ2xlLiBGb3IgZXhhbXBsZSBvbkVudGVyIHNob3VsZG4ndCBmaXJlIGlmIHRoZSBTY3JvbGxUcmlnZ2VyIGlzbid0IGFjdHVhbGx5IGVudGVyZWQuXG4gICAgICAgICAgICBvblRvZ2dsZSAmJiB0b2dnbGVkICYmIF9jYWxsYmFjayhzZWxmLCBvblRvZ2dsZSk7XG4gICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIF9jYWxsYmFjayhzZWxmLCBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdKTtcbiAgICAgICAgICAgIG9uY2UgJiYgKGNsaXBwZWQgPT09IDEgPyBzZWxmLmtpbGwoZmFsc2UsIDEpIDogY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSA9IDApOyAvLyBhIGNhbGxiYWNrIHNob3VsZG4ndCBiZSBjYWxsZWQgYWdhaW4gaWYgb25jZSBpcyB0cnVlLlxuXG4gICAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBnbyBjb21wbGV0ZWx5IHBhc3QsIGxpa2UgZnJvbSBiZWZvcmUgdGhlIHN0YXJ0IHRvIGFmdGVyIHRoZSBlbmQgKG9yIHZpY2UtdmVyc2EpIGluIHdoaWNoIGNhc2UgQk9USCBjYWxsYmFja3Mgc2hvdWxkIGJlIGZpcmVkIGluIHRoYXQgb3JkZXJcbiAgICAgICAgICAgICAgdG9nZ2xlU3RhdGUgPSBjbGlwcGVkID09PSAxID8gMSA6IDM7XG4gICAgICAgICAgICAgIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gJiYgX2NhbGxiYWNrKHNlbGYsIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmYXN0U2Nyb2xsRW5kICYmICFpc0FjdGl2ZSAmJiBNYXRoLmFicyhzZWxmLmdldFZlbG9jaXR5KCkpID4gKF9pc051bWJlcihmYXN0U2Nyb2xsRW5kKSA/IGZhc3RTY3JvbGxFbmQgOiAyNTAwKSkge1xuICAgICAgICAgICAgX2VuZEFuaW1hdGlvbihzZWxmLmNhbGxiYWNrQW5pbWF0aW9uKTtcblxuICAgICAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkgOiBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgYWN0aW9uID09PSBcInJldmVyc2VcIiA/IDEgOiAhY2xpcHBlZCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzVG9nZ2xlICYmIG9uVXBkYXRlICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIG9uVXBkYXRlKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHVwZGF0ZSBhYnNvbHV0ZWx5LXBvc2l0aW9uZWQgbWFya2VycyAob25seSBpZiB0aGUgc2Nyb2xsZXIgaXNuJ3QgdGhlIHZpZXdwb3J0KVxuXG5cbiAgICAgIGlmIChtYXJrZXJFbmRTZXR0ZXIpIHtcbiAgICAgICAgdmFyIG4gPSBjb250YWluZXJBbmltYXRpb24gPyBzY3JvbGwgLyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSAqIChjb250YWluZXJBbmltYXRpb24uX2NhU2Nyb2xsRGlzdCB8fCAwKSA6IHNjcm9sbDtcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIobiArIChtYXJrZXJTdGFydFRyaWdnZXIuX2lzRmxpcHBlZCA/IDEgOiAwKSk7XG4gICAgICAgIG1hcmtlckVuZFNldHRlcihuKTtcbiAgICAgIH1cblxuICAgICAgY2FNYXJrZXJTZXR0ZXIgJiYgY2FNYXJrZXJTZXR0ZXIoLXNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApKTtcbiAgICB9O1xuXG4gICAgc2VsZi5lbmFibGUgPSBmdW5jdGlvbiAocmVzZXQsIHJlZnJlc2gpIHtcbiAgICAgIGlmICghc2VsZi5lbmFibGVkKSB7XG4gICAgICAgIHNlbGYuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInJlc2l6ZVwiLCBfb25SZXNpemUpO1xuXG4gICAgICAgIGlzVmlld3BvcnQgfHwgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuICAgICAgICBvblJlZnJlc2hJbml0ICYmIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hJbml0XCIsIG9uUmVmcmVzaEluaXQpO1xuXG4gICAgICAgIGlmIChyZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZWxmLnByb2dyZXNzID0gcHJldlByb2dyZXNzID0gMDtcbiAgICAgICAgICBzY3JvbGwxID0gc2Nyb2xsMiA9IGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmcmVzaCAhPT0gZmFsc2UgJiYgc2VsZi5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuZ2V0VHdlZW4gPSBmdW5jdGlvbiAoc25hcCkge1xuICAgICAgcmV0dXJuIHNuYXAgJiYgdHdlZW5UbyA/IHR3ZWVuVG8udHdlZW4gOiBzY3J1YlR3ZWVuO1xuICAgIH07XG5cbiAgICBzZWxmLnNldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChuZXdTdGFydCwgbmV3RW5kLCBrZWVwQ2xhbXAsIHBpbk9mZnNldCkge1xuICAgICAgLy8gZG9lc24ndCBwZXJzaXN0IGFmdGVyIHJlZnJlc2goKSEgSW50ZW5kZWQgdG8gYmUgYSB3YXkgdG8gb3ZlcnJpZGUgdmFsdWVzIHRoYXQgd2VyZSBzZXQgZHVyaW5nIHJlZnJlc2goKSwgbGlrZSB5b3UgY291bGQgc2V0IGl0IGluIG9uUmVmcmVzaCgpXG4gICAgICBpZiAoY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcmF0aW9zIGludG8gc2Nyb2xsIHBvc2l0aW9ucy4gUmVtZW1iZXIsIHN0YXJ0L2VuZCB2YWx1ZXMgb24gU2Nyb2xsVHJpZ2dlcnMgdGhhdCBoYXZlIGEgY29udGFpbmVyQW5pbWF0aW9uIHJlZmVyIHRvIHRoZSB0aW1lIChpbiBzZWNvbmRzKSwgTk9UIHNjcm9sbCBwb3NpdGlvbnMuXG4gICAgICAgIHZhciBzdCA9IGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSxcbiAgICAgICAgICAgIF9jaGFuZ2UgPSBzdC5lbmQgLSBzdC5zdGFydDtcblxuICAgICAgICBuZXdTdGFydCA9IHN0LnN0YXJ0ICsgX2NoYW5nZSAqIG5ld1N0YXJ0IC8gZHVyYXRpb247XG4gICAgICAgIG5ld0VuZCA9IHN0LnN0YXJ0ICsgX2NoYW5nZSAqIG5ld0VuZCAvIGR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJlZnJlc2goZmFsc2UsIGZhbHNlLCB7XG4gICAgICAgIHN0YXJ0OiBfa2VlcENsYW1wKG5ld1N0YXJ0LCBrZWVwQ2xhbXAgJiYgISFzZWxmLl9zdGFydENsYW1wKSxcbiAgICAgICAgZW5kOiBfa2VlcENsYW1wKG5ld0VuZCwga2VlcENsYW1wICYmICEhc2VsZi5fZW5kQ2xhbXApXG4gICAgICB9LCBwaW5PZmZzZXQpO1xuICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgc2VsZi5hZGp1c3RQaW5TcGFjaW5nID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgaWYgKHNwYWNlclN0YXRlICYmIGFtb3VudCkge1xuICAgICAgICB2YXIgaSA9IHNwYWNlclN0YXRlLmluZGV4T2YoZGlyZWN0aW9uLmQpICsgMTtcbiAgICAgICAgc3BhY2VyU3RhdGVbaV0gPSBwYXJzZUZsb2F0KHNwYWNlclN0YXRlW2ldKSArIGFtb3VudCArIF9weDtcbiAgICAgICAgc3BhY2VyU3RhdGVbMV0gPSBwYXJzZUZsb2F0KHNwYWNlclN0YXRlWzFdKSArIGFtb3VudCArIF9weDtcblxuICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmRpc2FibGUgPSBmdW5jdGlvbiAocmVzZXQsIGFsbG93QW5pbWF0aW9uKSB7XG4gICAgICByZXNldCAhPT0gZmFsc2UgJiYgc2VsZi5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gc2VsZi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgICAgcHJldlNjcm9sbCA9IDA7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgICAgIHR3ZWVuVG8udHdlZW4gJiYgdHdlZW5Uby50d2Vlbi5raWxsKCkgJiYgKHR3ZWVuVG8udHdlZW4gPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWaWV3cG9ydCkge1xuICAgICAgICAgIHZhciBpID0gX3RyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChfdHJpZ2dlcnNbaV0uc2Nyb2xsZXIgPT09IHNjcm9sbGVyICYmIF90cmlnZ2Vyc1tpXSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICByZXR1cm47IC8vZG9uJ3QgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgaWYgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHRyaWdnZXJzIHJlZmVyZW5jaW5nIGl0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcblxuICAgICAgICAgIGlzVmlld3BvcnQgfHwgX3JlbW92ZUxpc3RlbmVyKHNjcm9sbGVyLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYua2lsbCA9IGZ1bmN0aW9uIChyZXZlcnQsIGFsbG93QW5pbWF0aW9uKSB7XG4gICAgICBzZWxmLmRpc2FibGUocmV2ZXJ0LCBhbGxvd0FuaW1hdGlvbik7XG4gICAgICBzY3J1YlR3ZWVuICYmICFhbGxvd0FuaW1hdGlvbiAmJiBzY3J1YlR3ZWVuLmtpbGwoKTtcbiAgICAgIGlkICYmIGRlbGV0ZSBfaWRzW2lkXTtcblxuICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKTtcblxuICAgICAgaSA+PSAwICYmIF90cmlnZ2Vycy5zcGxpY2UoaSwgMSk7XG4gICAgICBpID09PSBfaSAmJiBfZGlyZWN0aW9uID4gMCAmJiBfaS0tOyAvLyBpZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVmcmVzaCgpIG9yIHVwZGF0ZSgpLCBzcGxpY2luZyB3b3VsZCBjYXVzZSBza2lwcyBpbiB0aGUgaW5kZXgsIHNvIGFkanVzdC4uLlxuICAgICAgLy8gaWYgbm8gb3RoZXIgU2Nyb2xsVHJpZ2dlciBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgc2Nyb2xsZXIgYXJlIGZvdW5kLCB3aXBlIG91dCBhbnkgcmVjb3JkZWQgc2Nyb2xsIHBvc2l0aW9uLiBPdGhlcndpc2UsIGluIGEgc2luZ2xlIHBhZ2UgYXBwbGljYXRpb24sIGZvciBleGFtcGxlLCBpdCBjb3VsZCBtYWludGFpbiBzY3JvbGwgcG9zaXRpb24gd2hlbiBpdCByZWFsbHkgc2hvdWxkbid0LlxuXG4gICAgICBpID0gMDtcblxuICAgICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuc2Nyb2xsZXIgPT09IHNlbGYuc2Nyb2xsZXIgJiYgKGkgPSAxKTtcbiAgICAgIH0pO1xuXG4gICAgICBpIHx8IF9yZWZyZXNoaW5nQWxsIHx8IChzZWxmLnNjcm9sbC5yZWMgPSAwKTtcblxuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IG51bGw7XG4gICAgICAgIHJldmVydCAmJiBhbmltYXRpb24ucmV2ZXJ0KHtcbiAgICAgICAgICBraWxsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgYWxsb3dBbmltYXRpb24gfHwgYW5pbWF0aW9uLmtpbGwoKTtcbiAgICAgIH1cblxuICAgICAgbWFya2VyU3RhcnQgJiYgW21hcmtlclN0YXJ0LCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgbWFya2VyRW5kVHJpZ2dlcl0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gbS5wYXJlbnROb2RlICYmIG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtKTtcbiAgICAgIH0pO1xuICAgICAgX3ByaW1hcnkgPT09IHNlbGYgJiYgKF9wcmltYXJ5ID0gMCk7XG5cbiAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgcGluQ2FjaGUgJiYgKHBpbkNhY2hlLnVuY2FjaGUgPSAxKTtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5waW4gPT09IHBpbiAmJiBpKys7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGkgfHwgKHBpbkNhY2hlLnNwYWNlciA9IDApOyAvLyBpZiB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgU2Nyb2xsVHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJlbW92ZSB0aGUgc3BhY2VyLCBvdGhlcndpc2UgaXQgY291bGQgYmUgY29udGFtaW5hdGVkIHdpdGggb2xkL3N0YWxlIHZhbHVlcyBpZiB0aGUgdXNlciByZS1jcmVhdGVzIGEgU2Nyb2xsVHJpZ2dlciBmb3IgdGhlIHNhbWUgZWxlbWVudC5cbiAgICAgIH1cblxuICAgICAgdmFycy5vbktpbGwgJiYgdmFycy5vbktpbGwoc2VsZik7XG4gICAgfTtcblxuICAgIF90cmlnZ2Vycy5wdXNoKHNlbGYpO1xuXG4gICAgc2VsZi5lbmFibGUoZmFsc2UsIGZhbHNlKTtcbiAgICBjdXN0b21SZXZlcnRSZXR1cm4gJiYgY3VzdG9tUmV2ZXJ0UmV0dXJuKHNlbGYpO1xuXG4gICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uYWRkICYmICFjaGFuZ2UpIHtcbiAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaXMgYSB0aW1lbGluZSwgaXQgbWF5IG5vdCBoYXZlIGJlZW4gcG9wdWxhdGVkIHlldCwgc28gaXQgd291bGRuJ3QgcmVuZGVyIGF0IHRoZSBwcm9wZXIgcGxhY2Ugb24gdGhlIGZpcnN0IHJlZnJlc2goKSwgdGh1cyB3ZSBzaG91bGQgc2NoZWR1bGUgb25lIGZvciB0aGUgbmV4dCB0aWNrLiBJZiBcImNoYW5nZVwiIGlzIGRlZmluZWQsIHdlIGtub3cgaXQgbXVzdCBiZSByZS1lbmFibGluZywgdGh1cyB3ZSBjYW4gcmVmcmVzaCgpIHJpZ2h0IGF3YXkuXG4gICAgICB2YXIgdXBkYXRlRnVuYyA9IHNlbGYudXBkYXRlOyAvLyBzb21lIGJyb3dzZXJzIG1heSBmaXJlIGEgc2Nyb2xsIGV2ZW50IEJFRk9SRSBhIHRpY2sgZWxhcHNlcyBhbmQvb3IgdGhlIERPTUNvbnRlbnRMb2FkZWQgZmlyZXMuIFNvIHRoZXJlJ3MgYSBjaGFuY2UgdXBkYXRlKCkgd2lsbCBiZSBjYWxsZWQgQkVGT1JFIGEgcmVmcmVzaCgpIGhhcyBoYXBwZW5lZCBvbiBhIFRpbWVsaW5lLWF0dGFjaGVkIFNjcm9sbFRyaWdnZXIgd2hpY2ggbWVhbnMgdGhlIHN0YXJ0L2VuZCB3b24ndCBiZSBjYWxjdWxhdGVkIHlldC4gV2UgZG9uJ3Qgd2FudCB0byBhZGQgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIHRoZSB1cGRhdGUoKSBtZXRob2QgKGxpa2UgY2hlY2sgdG8gc2VlIGlmIGVuZCBpcyBkZWZpbmVkIGFuZCBpZiBub3QsIGZvcmNlIGEgcmVmcmVzaCgpKSBiZWNhdXNlIHRoYXQncyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBoaXQgYSBMT1QgKHBlcmZvcm1hbmNlKS4gU28gd2Ugc3dhcCBvdXQgdGhlIHJlYWwgdXBkYXRlKCkgbWV0aG9kIGZvciB0aGlzIG9uZSB0aGF0J2xsIHJlLWF0dGFjaCBpdCB0aGUgZmlyc3QgdGltZSBpdCBnZXRzIGNhbGxlZCBhbmQgb2YgY291cnNlIGZvcmNlcyBhIHJlZnJlc2goKS5cblxuICAgICAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudXBkYXRlID0gdXBkYXRlRnVuYztcbiAgICAgICAgX3Njcm9sbGVycy5jYWNoZSsrOyAvLyBvdGhlcndpc2UgYSBjYWNoZWQgc2Nyb2xsIHBvc2l0aW9uIG1heSBnZXQgdXNlZCBpbiB0aGUgcmVmcmVzaCgpIGluIGEgdmVyeSByYXJlIHNjZW5hcmlvLCBsaWtlIGlmIFNjcm9sbFRyaWdnZXJzIGFyZSBjcmVhdGVkIGluc2lkZSBhIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYW5kIHRoZSBxdWV1ZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgZmlyZXMgYmVmb3JlaGFuZC4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vY29tbXVuaXR5L2ZvcnVtcy90b3BpYy80MTI2Ny1zY3JvbGx0cmlnZ2VyLWJyZWFrcy1vbi1yZWZyZXNoLXdoZW4tdXNpbmctZG9tY29udGVudGxvYWRlZC9cblxuICAgICAgICBzdGFydCB8fCBlbmQgfHwgc2VsZi5yZWZyZXNoKCk7XG4gICAgICB9O1xuXG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsIHNlbGYudXBkYXRlKTtcbiAgICAgIGNoYW5nZSA9IDAuMDE7XG4gICAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIHBpbiAmJiBfcXVldWVSZWZyZXNoQWxsKCk7IC8vIHBpbm5pbmcgY291bGQgYWZmZWN0IHRoZSBwb3NpdGlvbnMgb2Ygb3RoZXIgdGhpbmdzLCBzbyBtYWtlIHN1cmUgd2UgcXVldWUgYSBmdWxsIHJlZnJlc2goKVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG4gICAgICBfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50ICYmIFNjcm9sbFRyaWdnZXIuZW5hYmxlKCk7XG4gICAgICBfY29yZUluaXR0ZWQgPSBfZW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvcmVJbml0dGVkO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyhjb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGNvbmZpZykge1xuICAgICAgICBfZGVmYXVsdHNbcF0gPSBjb25maWdbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKHJlc2V0LCBraWxsKSB7XG4gICAgX2VuYWJsZWQgPSAwO1xuXG4gICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyW2tpbGwgPyBcImtpbGxcIiA6IFwiZGlzYWJsZVwiXShyZXNldCk7XG4gICAgfSk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBjbGVhckludGVydmFsKF9zeW5jSW50ZXJ2YWwpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIF9wYXNzVGhyb3VnaCk7XG5cbiAgICBfbXVsdGlMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgX3BvaW50ZXJEb3duSGFuZGxlcik7XG5cbiAgICBfbXVsdGlMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgX3BvaW50ZXJVcEhhbmRsZXIpO1xuXG4gICAgX3Jlc2l6ZURlbGF5LmtpbGwoKTtcblxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX3JlbW92ZUxpc3RlbmVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Njcm9sbGVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAxXSk7XG5cbiAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMl0pO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcblxuICAgIGlmIChnc2FwKSB7XG4gICAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG4gICAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSBnc2FwLmNvcmUuc3VwcHJlc3NPdmVyd3JpdGVzIHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIF9zY3JvbGxSZXN0b3JhdGlvbiA9IF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiB8fCBcImF1dG9cIjtcbiAgICAgIF9sYXN0U2Nyb2xsID0gX3dpbi5wYWdlWU9mZnNldCB8fCAwO1xuICAgICAgZ3NhcC5jb3JlLmdsb2JhbHMoXCJTY3JvbGxUcmlnZ2VyXCIsIFNjcm9sbFRyaWdnZXIpOyAvLyBtdXN0IHJlZ2lzdGVyIHRoZSBnbG9iYWwgbWFudWFsbHkgYmVjYXVzZSBpbiBJbnRlcm5ldCBFeHBsb3JlciwgZnVuY3Rpb25zIChjbGFzc2VzKSBkb24ndCBoYXZlIGEgXCJuYW1lXCIgcHJvcGVydHkuXG5cbiAgICAgIGlmIChfYm9keSkge1xuICAgICAgICBfZW5hYmxlZCA9IDE7XG4gICAgICAgIF9kaXYxMDB2aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IC8vIHRvIHNvbHZlIG1vYmlsZSBicm93c2VyIGFkZHJlc3MgYmFyIHNob3cvaGlkZSByZXNpemluZywgd2Ugc2hvdWxkbid0IHJlbHkgb24gd2luZG93LmlubmVySGVpZ2h0LiBJbnN0ZWFkLCB1c2UgYSA8ZGl2PiB3aXRoIGl0cyBoZWlnaHQgc2V0IHRvIDEwMHZoIGFuZCBtZWFzdXJlIHRoYXQgc2luY2UgdGhhdCdzIHdoYXQgdGhlIHNjcm9sbGluZyBpcyBiYXNlZCBvbiBhbnl3YXkgYW5kIGl0J3Mgbm90IGFmZmVjdGVkIGJ5IGFkZHJlc3MgYmFyIHNob3dpbmcvaGlkaW5nLlxuXG4gICAgICAgIF9kaXYxMDB2aC5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XG4gICAgICAgIF9kaXYxMDB2aC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblxuICAgICAgICBfcmVmcmVzaDEwMHZoKCk7XG5cbiAgICAgICAgX3JhZkJ1Z0ZpeCgpO1xuXG4gICAgICAgIE9ic2VydmVyLnJlZ2lzdGVyKGdzYXApOyAvLyBpc1RvdWNoIGlzIDAgaWYgbm8gdG91Y2gsIDEgaWYgT05MWSB0b3VjaCwgYW5kIDIgaWYgaXQgY2FuIGFjY29tbW9kYXRlIHRvdWNoIGJ1dCBhbHNvIG90aGVyIHR5cGVzIGxpa2UgbW91c2UvcG9pbnRlci5cblxuICAgICAgICBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPSBPYnNlcnZlci5pc1RvdWNoO1xuICAgICAgICBfZml4SU9TQnVnID0gT2JzZXJ2ZXIuaXNUb3VjaCAmJiAvKGlQYWR8aVBob25lfGlQb2R8TWFjKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIHNpbmNlIDIwMTcsIGlPUyBoYXMgaGFkIGEgYnVnIHRoYXQgY2F1c2VzIGV2ZW50LmNsaWVudFgvWSB0byBiZSBpbmFjY3VyYXRlIHdoZW4gYSBzY3JvbGwgb2NjdXJzLCB0aHVzIHdlIG11c3QgYWx0ZXJuYXRlIGlnbm9yaW5nIGV2ZXJ5IG90aGVyIHRvdWNobW92ZSBldmVudCB0byB3b3JrIGFyb3VuZCBpdC4gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODE5NTQgYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0V4YnJQTmEvMDg3Y2VmMTk3ZGMzNTQ0NWEwOTUxZTg5MzVjNDE1MDNcblxuICAgICAgICBfaWdub3JlTW9iaWxlUmVzaXplID0gT2JzZXJ2ZXIuaXNUb3VjaCA9PT0gMTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpOyAvLyBtb3N0bHkgZm9yIDNyZCBwYXJ0eSBzbW9vdGggc2Nyb2xsaW5nIGxpYnJhcmllcy5cblxuXG4gICAgICAgIF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuXG4gICAgICAgIGlmIChnc2FwLm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICBTY3JvbGxUcmlnZ2VyLm1hdGNoTWVkaWEgPSBmdW5jdGlvbiAodmFycykge1xuICAgICAgICAgICAgdmFyIG1tID0gZ3NhcC5tYXRjaE1lZGlhKCksXG4gICAgICAgICAgICAgICAgcDtcblxuICAgICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgICAgICAgbW0uYWRkKHAsIHZhcnNbcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbW07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFJbml0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9yZWNvcmRTY3JvbGxQb3NpdGlvbnMoKTtcblxuICAgICAgICAgICAgX3JldmVydEFsbCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFSZXZlcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXZlcnRSZWNvcmRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3JlZnJlc2hBbGwoMCwgMSk7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZ3NhcC5tYXRjaE1lZGlhKCkuYWRkKFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2hlbiBvcmllbnRhdGlvbiBjaGFuZ2VzLCB3ZSBzaG91bGQgdGFrZSBuZXcgYmFzZSBtZWFzdXJlbWVudHMgZm9yIHRoZSBpZ25vcmVNb2JpbGVSZXNpemUgZmVhdHVyZS5cbiAgICAgICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3NldEJhc2VEaW1lbnNpb25zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlJlcXVpcmVzIEdTQVAgMy4xMS4wIG9yIGxhdGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldEJhc2VEaW1lbnNpb25zKCk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7IC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lKSwgdGhlIHdpbmRvdyBzdG9wcyBkaXNwYXRjaGluZyBzY3JvbGwgZXZlbnRzIG9uIHRoZSB3aW5kb3cgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCwgYnV0IGl0J3MgY29uc2lzdGVudCBvbiB0aGUgZG9jdW1lbnQhXG5cblxuICAgICAgICB2YXIgYm9keUhhc1N0eWxlID0gX2JvZHkuaGFzQXR0cmlidXRlKFwic3R5bGVcIiksXG4gICAgICAgICAgICBib2R5U3R5bGUgPSBfYm9keS5zdHlsZSxcbiAgICAgICAgICAgIGJvcmRlciA9IGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSxcbiAgICAgICAgICAgIEFuaW1hdGlvblByb3RvID0gZ3NhcC5jb3JlLkFuaW1hdGlvbi5wcm90b3R5cGUsXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIEFuaW1hdGlvblByb3RvLnJldmVydCB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uUHJvdG8sIFwicmV2ZXJ0XCIsIHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lKC0wLjAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoQW5pbWF0aW9uLnJldmVydCgpIHdhcyBhZGRlZCBhZnRlciAzLjEwLjQpXG5cbiAgICAgICAgYm9keVN0eWxlLmJvcmRlclRvcFN0eWxlID0gXCJzb2xpZFwiOyAvLyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgd2hlcmUgYSBtYXJnaW4gb2YgYSBjaGlsZCBlbGVtZW50IGNvdWxkIHRocm93IG9mZiB0aGUgYm91bmRzIG9mIHRoZSBfYm9keSwgbWFraW5nIGl0IHNlZW0gbGlrZSB0aGVyZSdzIGEgbWFyZ2luIHdoZW4gdGhlcmUgYWN0dWFsbHkgaXNuJ3QuIFRoZSBib3JkZXIgZW5zdXJlcyB0aGF0IHRoZSBib3VuZHMgYXJlIGFjY3VyYXRlLlxuXG4gICAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMoX2JvZHkpO1xuICAgICAgICBfdmVydGljYWwubSA9IE1hdGgucm91bmQoYm91bmRzLnRvcCArIF92ZXJ0aWNhbC5zYygpKSB8fCAwOyAvLyBhY2NvbW1vZGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSA8Ym9keT4gY2F1c2VkIGJ5IG1hcmdpbnMgYW5kL29yIHBhZGRpbmdcblxuICAgICAgICBfaG9yaXpvbnRhbC5tID0gTWF0aC5yb3VuZChib3VuZHMubGVmdCArIF9ob3Jpem9udGFsLnNjKCkpIHx8IDA7XG4gICAgICAgIGJvcmRlciA/IGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSA9IGJvcmRlciA6IGJvZHlTdHlsZS5yZW1vdmVQcm9wZXJ0eShcImJvcmRlci10b3Atc3R5bGVcIik7XG5cbiAgICAgICAgaWYgKCFib2R5SGFzU3R5bGUpIHtcbiAgICAgICAgICAvLyBTU1IgZnJhbWV3b3JrcyBsaWtlIE5leHQuanMgY29tcGxhaW4gaWYgdGhpcyBhdHRyaWJ1dGUgZ2V0cyBhZGRlZC5cbiAgICAgICAgICBfYm9keS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKTsgLy8gaXQncyBub3QgZW5vdWdoIHRvIGp1c3QgcmVtb3ZlQXR0cmlidXRlKCkgLSB3ZSBtdXN0IGZpcnN0IHNldCBpdCB0byBlbXB0eSwgb3RoZXJ3aXNlIE5leHQuanMgY29tcGxhaW5zLlxuXG5cbiAgICAgICAgICBfYm9keS5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgICAgfSAvLyBUT0RPOiAoPykgbWF5YmUgbW92ZSB0byBsZXZlcmFnaW5nIHRoZSB2ZWxvY2l0eSBtZWNoYW5pc20gaW4gT2JzZXJ2ZXIgYW5kIHNraXAgaW50ZXJ2YWxzLlxuXG5cbiAgICAgICAgX3N5bmNJbnRlcnZhbCA9IHNldEludGVydmFsKF9zeW5jLCAyNTApO1xuICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuNSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfc3RhcnR1cCA9IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcInRvdWNoY2FuY2VsXCIsIF9wYXNzVGhyb3VnaCk7IC8vIHNvbWUgb2xkZXIgQW5kcm9pZCBkZXZpY2VzIGludGVybWl0dGVudGx5IHN0b3AgZGlzcGF0Y2hpbmcgXCJ0b3VjaG1vdmVcIiBldmVudHMgaWYgd2UgZG9uJ3QgbGlzdGVuIGZvciBcInRvdWNoY2FuY2VsXCIgb24gdGhlIGRvY3VtZW50LlxuXG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cblxuICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgX3BvaW50ZXJEb3duSGFuZGxlcik7XG5cbiAgICAgICAgX211bHRpTGlzdGVuZXIoX2FkZExpc3RlbmVyLCBfZG9jLCBcInBvaW50ZXJ1cCx0b3VjaGVuZCxtb3VzZXVwXCIsIF9wb2ludGVyVXBIYW5kbGVyKTtcblxuICAgICAgICBfdHJhbnNmb3JtUHJvcCA9IGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0cmFuc2Zvcm1cIik7XG5cbiAgICAgICAgX3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgICAgX2NvcmVJbml0dGVkID0gX2dldFRpbWUoKTtcbiAgICAgICAgX3Jlc2l6ZURlbGF5ID0gZ3NhcC5kZWxheWVkQ2FsbCgwLjIsIF9yZWZyZXNoQWxsKS5wYXVzZSgpO1xuICAgICAgICBfYXV0b1JlZnJlc2ggPSBbX2RvYywgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdyA9IF93aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgaCA9IF93aW4uaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAoX2RvYy5oaWRkZW4pIHtcbiAgICAgICAgICAgIF9wcmV2V2lkdGggPSB3O1xuICAgICAgICAgICAgX3ByZXZIZWlnaHQgPSBoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3ByZXZXaWR0aCAhPT0gdyB8fCBfcHJldkhlaWdodCAhPT0gaCkge1xuICAgICAgICAgICAgX29uUmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwibG9hZFwiLCBfcmVmcmVzaEFsbCwgX3dpbiwgXCJyZXNpemVcIiwgX29uUmVzaXplXTtcblxuICAgICAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9hZGRMaXN0ZW5lcik7XG5cbiAgICAgICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlci5lbmFibGUoMCwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAxXSk7XG5cbiAgICAgICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmNvbmZpZyA9IGZ1bmN0aW9uIGNvbmZpZyh2YXJzKSB7XG4gICAgXCJsaW1pdENhbGxiYWNrc1wiIGluIHZhcnMgJiYgKF9saW1pdENhbGxiYWNrcyA9ICEhdmFycy5saW1pdENhbGxiYWNrcyk7XG4gICAgdmFyIG1zID0gdmFycy5zeW5jSW50ZXJ2YWw7XG4gICAgbXMgJiYgY2xlYXJJbnRlcnZhbChfc3luY0ludGVydmFsKSB8fCAoX3N5bmNJbnRlcnZhbCA9IG1zKSAmJiBzZXRJbnRlcnZhbChfc3luYywgbXMpO1xuICAgIFwiaWdub3JlTW9iaWxlUmVzaXplXCIgaW4gdmFycyAmJiAoX2lnbm9yZU1vYmlsZVJlc2l6ZSA9IFNjcm9sbFRyaWdnZXIuaXNUb3VjaCA9PT0gMSAmJiB2YXJzLmlnbm9yZU1vYmlsZVJlc2l6ZSk7XG5cbiAgICBpZiAoXCJhdXRvUmVmcmVzaEV2ZW50c1wiIGluIHZhcnMpIHtcbiAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX3JlbW92ZUxpc3RlbmVyKSB8fCBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9hZGRMaXN0ZW5lciwgdmFycy5hdXRvUmVmcmVzaEV2ZW50cyB8fCBcIm5vbmVcIik7XG4gICAgICBfaWdub3JlUmVzaXplID0gKHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgKyBcIlwiKS5pbmRleE9mKFwicmVzaXplXCIpID09PSAtMTtcbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5zY3JvbGxlclByb3h5ID0gZnVuY3Rpb24gc2Nyb2xsZXJQcm94eSh0YXJnZXQsIHZhcnMpIHtcbiAgICB2YXIgdCA9IF9nZXRUYXJnZXQodGFyZ2V0KSxcbiAgICAgICAgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZih0KSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHQpO1xuXG4gICAgaWYgKH5pKSB7XG4gICAgICBfc2Nyb2xsZXJzLnNwbGljZShpLCBpc1ZpZXdwb3J0ID8gNiA6IDIpO1xuICAgIH1cblxuICAgIGlmICh2YXJzKSB7XG4gICAgICBpc1ZpZXdwb3J0ID8gX3Byb3hpZXMudW5zaGlmdChfd2luLCB2YXJzLCBfYm9keSwgdmFycywgX2RvY0VsLCB2YXJzKSA6IF9wcm94aWVzLnVuc2hpZnQodCwgdmFycyk7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuY2xlYXJNYXRjaE1lZGlhID0gZnVuY3Rpb24gY2xlYXJNYXRjaE1lZGlhKHF1ZXJ5KSB7XG4gICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0Ll9jdHggJiYgdC5fY3R4LnF1ZXJ5ID09PSBxdWVyeSAmJiB0Ll9jdHgua2lsbCh0cnVlLCB0cnVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmlzSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIGlzSW5WaWV3cG9ydChlbGVtZW50LCByYXRpbywgaG9yaXpvbnRhbCkge1xuICAgIHZhciBib3VuZHMgPSAoX2lzU3RyaW5nKGVsZW1lbnQpID8gX2dldFRhcmdldChlbGVtZW50KSA6IGVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBvZmZzZXQgPSBib3VuZHNbaG9yaXpvbnRhbCA/IF93aWR0aCA6IF9oZWlnaHRdICogcmF0aW8gfHwgMDtcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IGJvdW5kcy5yaWdodCAtIG9mZnNldCA+IDAgJiYgYm91bmRzLmxlZnQgKyBvZmZzZXQgPCBfd2luLmlubmVyV2lkdGggOiBib3VuZHMuYm90dG9tIC0gb2Zmc2V0ID4gMCAmJiBib3VuZHMudG9wICsgb2Zmc2V0IDwgX3dpbi5pbm5lckhlaWdodDtcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLnBvc2l0aW9uSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIHBvc2l0aW9uSW5WaWV3cG9ydChlbGVtZW50LCByZWZlcmVuY2VQb2ludCwgaG9yaXpvbnRhbCkge1xuICAgIF9pc1N0cmluZyhlbGVtZW50KSAmJiAoZWxlbWVudCA9IF9nZXRUYXJnZXQoZWxlbWVudCkpO1xuICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBzaXplID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSxcbiAgICAgICAgb2Zmc2V0ID0gcmVmZXJlbmNlUG9pbnQgPT0gbnVsbCA/IHNpemUgLyAyIDogcmVmZXJlbmNlUG9pbnQgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3JlZmVyZW5jZVBvaW50XSAqIHNpemUgOiB+cmVmZXJlbmNlUG9pbnQuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHJlZmVyZW5jZVBvaW50KSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHJlZmVyZW5jZVBvaW50KSB8fCAwO1xuICAgIHJldHVybiBob3Jpem9udGFsID8gKGJvdW5kcy5sZWZ0ICsgb2Zmc2V0KSAvIF93aW4uaW5uZXJXaWR0aCA6IChib3VuZHMudG9wICsgb2Zmc2V0KSAvIF93aW4uaW5uZXJIZWlnaHQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5raWxsQWxsID0gZnVuY3Rpb24ga2lsbEFsbChhbGxvd0xpc3RlbmVycykge1xuICAgIF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC52YXJzLmlkICE9PSBcIlNjcm9sbFNtb290aGVyXCIgJiYgdC5raWxsKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoYWxsb3dMaXN0ZW5lcnMgIT09IHRydWUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzLmtpbGxBbGwgfHwgW107XG4gICAgICBfbGlzdGVuZXJzID0ge307XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTY3JvbGxUcmlnZ2VyO1xufSgpO1xuU2Nyb2xsVHJpZ2dlci52ZXJzaW9uID0gXCIzLjE0LjJcIjtcblxuU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgcmV0dXJuIHRhcmdldHMgPyBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAvLyBzYXZlZCBzdHlsZXMgYXJlIHJlY29yZGVkIGluIGEgY29uc2VjdXRpdmUgYWx0ZXJuYXRpbmcgQXJyYXksIGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIGNhY2hlLCBtYXRjaE1lZGlhLCAuLi5dXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuc3R5bGUpIHtcbiAgICAgIHZhciBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaSA+PSAwICYmIF9zYXZlZFN0eWxlcy5zcGxpY2UoaSwgNSk7XG5cbiAgICAgIF9zYXZlZFN0eWxlcy5wdXNoKHRhcmdldCwgdGFyZ2V0LnN0eWxlLmNzc1RleHQsIHRhcmdldC5nZXRCQm94ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksIGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLCBfY29udGV4dCgpKTtcbiAgICB9XG4gIH0pIDogX3NhdmVkU3R5bGVzO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZXZlcnQgPSBmdW5jdGlvbiAoc29mdCwgbWVkaWEpIHtcbiAgcmV0dXJuIF9yZXZlcnRBbGwoIXNvZnQsIG1lZGlhKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuY3JlYXRlID0gZnVuY3Rpb24gKHZhcnMsIGFuaW1hdGlvbikge1xuICByZXR1cm4gbmV3IFNjcm9sbFRyaWdnZXIodmFycywgYW5pbWF0aW9uKTtcbn07XG5cblNjcm9sbFRyaWdnZXIucmVmcmVzaCA9IGZ1bmN0aW9uIChzYWZlKSB7XG4gIHJldHVybiBzYWZlID8gX29uUmVzaXplKHRydWUpIDogKF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKCkpICYmIF9yZWZyZXNoQWxsKHRydWUpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgcmV0dXJuICsrX3Njcm9sbGVycy5jYWNoZSAmJiBfdXBkYXRlQWxsKGZvcmNlID09PSB0cnVlID8gMiA6IDApO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jbGVhclNjcm9sbE1lbW9yeSA9IF9jbGVhclNjcm9sbE1lbW9yeTtcblxuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xuICByZXR1cm4gX21heFNjcm9sbChlbGVtZW50LCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRTY3JvbGxGdW5jID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9nZXRTY3JvbGxGdW5jKF9nZXRUYXJnZXQoZWxlbWVudCksIGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9pZHNbaWRdO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudmFycy5pZCAhPT0gXCJTY3JvbGxTbW9vdGhlclwiO1xuICB9KTtcbn07IC8vIGl0J3MgY29tbW9uIGZvciBwZW9wbGUgdG8gU2Nyb2xsVHJpZ2dlci5nZXRBbGwodCA9PiB0LmtpbGwoKSkgb24gcGFnZSByb3V0ZXMsIGZvciBleGFtcGxlLCBhbmQgd2UgZG9uJ3Qgd2FudCBpdCB0byBydWluIHNtb290aCBzY3JvbGxpbmcgYnkga2lsbGluZyB0aGUgbWFpbiBTY3JvbGxTbW9vdGhlciBvbmUuXG5cblxuU2Nyb2xsVHJpZ2dlci5pc1Njcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhX2xhc3RTY3JvbGxUaW1lO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5zbmFwRGlyZWN0aW9uYWwgPSBfc25hcERpcmVjdGlvbmFsO1xuXG5TY3JvbGxUcmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICB+YS5pbmRleE9mKGNhbGxiYWNrKSB8fCBhLnB1c2goY2FsbGJhY2spO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgIGkgPSBhICYmIGEuaW5kZXhPZihjYWxsYmFjayk7XG4gIGkgPj0gMCAmJiBhLnNwbGljZShpLCAxKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuYmF0Y2ggPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycykge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICB2YXJzQ29weSA9IHt9LFxuICAgICAgaW50ZXJ2YWwgPSB2YXJzLmludGVydmFsIHx8IDAuMDE2LFxuICAgICAgYmF0Y2hNYXggPSB2YXJzLmJhdGNoTWF4IHx8IDFlOSxcbiAgICAgIHByb3h5Q2FsbGJhY2sgPSBmdW5jdGlvbiBwcm94eUNhbGxiYWNrKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW10sXG4gICAgICAgIHRyaWdnZXJzID0gW10sXG4gICAgICAgIGRlbGF5ID0gZ3NhcC5kZWxheWVkQ2FsbChpbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZWxlbWVudHMsIHRyaWdnZXJzKTtcbiAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICB0cmlnZ2VycyA9IFtdO1xuICAgIH0pLnBhdXNlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBlbGVtZW50cy5sZW5ndGggfHwgZGVsYXkucmVzdGFydCh0cnVlKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goc2VsZi50cmlnZ2VyKTtcbiAgICAgIHRyaWdnZXJzLnB1c2goc2VsZik7XG4gICAgICBiYXRjaE1heCA8PSBlbGVtZW50cy5sZW5ndGggJiYgZGVsYXkucHJvZ3Jlc3MoMSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICB2YXJzQ29weVtwXSA9IHAuc3Vic3RyKDAsIDIpID09PSBcIm9uXCIgJiYgX2lzRnVuY3Rpb24odmFyc1twXSkgJiYgcCAhPT0gXCJvblJlZnJlc2hJbml0XCIgPyBwcm94eUNhbGxiYWNrKHAsIHZhcnNbcF0pIDogdmFyc1twXTtcbiAgfVxuXG4gIGlmIChfaXNGdW5jdGlvbihiYXRjaE1heCkpIHtcbiAgICBiYXRjaE1heCA9IGJhdGNoTWF4KCk7XG5cbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXgoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF90b0FycmF5KHRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIGZvciAocCBpbiB2YXJzQ29weSkge1xuICAgICAgY29uZmlnW3BdID0gdmFyc0NvcHlbcF07XG4gICAgfVxuXG4gICAgY29uZmlnLnRyaWdnZXIgPSB0YXJnZXQ7XG4gICAgcmVzdWx0LnB1c2goU2Nyb2xsVHJpZ2dlci5jcmVhdGUoY29uZmlnKSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyB0byByZWR1Y2UgZmlsZSBzaXplLiBjbGFtcHMgdGhlIHNjcm9sbCBhbmQgYWxzbyByZXR1cm5zIGEgZHVyYXRpb24gbXVsdGlwbGllciBzbyB0aGF0IGlmIHRoZSBzY3JvbGwgZ2V0cyBjaG9wcGVkIHNob3J0ZXIsIHRoZSBkdXJhdGlvbiBnZXRzIGN1cnRhaWxlZCBhcyB3ZWxsIChvdGhlcndpc2UgaWYgeW91J3JlIHZlcnkgY2xvc2UgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSwgZm9yIGV4YW1wbGUsIGFuZCBzd2lwZSB1cCByZWFsbHkgZmFzdCwgaXQnbGwgc3VkZGVubHkgc2xvdyBkb3duIGFuZCB0YWtlIGEgbG9uZyB0aW1lIHRvIHJlYWNoIHRoZSB0b3ApLlxuXG5cbnZhciBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIgPSBmdW5jdGlvbiBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIoc2Nyb2xsRnVuYywgY3VycmVudCwgZW5kLCBtYXgpIHtcbiAgY3VycmVudCA+IG1heCA/IHNjcm9sbEZ1bmMobWF4KSA6IGN1cnJlbnQgPCAwICYmIHNjcm9sbEZ1bmMoMCk7XG4gIHJldHVybiBlbmQgPiBtYXggPyAobWF4IC0gY3VycmVudCkgLyAoZW5kIC0gY3VycmVudCkgOiBlbmQgPCAwID8gY3VycmVudCAvIChjdXJyZW50IC0gZW5kKSA6IDE7XG59LFxuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcgPSBmdW5jdGlvbiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IHRydWUpIHtcbiAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3VjaC1hY3Rpb25cIik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnN0eWxlLnRvdWNoQWN0aW9uID0gZGlyZWN0aW9uID09PSB0cnVlID8gXCJhdXRvXCIgOiBkaXJlY3Rpb24gPyBcInBhbi1cIiArIGRpcmVjdGlvbiArIChPYnNlcnZlci5pc1RvdWNoID8gXCIgcGluY2gtem9vbVwiIDogXCJcIikgOiBcIm5vbmVcIjsgLy8gbm90ZTogRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgaXQgcGluY2gtem9vbSBwcm9wZXJseSwgYXQgbGVhc3QgaW4gYWRkaXRpb24gdG8gYSBwYW4teCBvciBwYW4teS5cbiAgfVxuXG4gIHRhcmdldCA9PT0gX2RvY0VsICYmIF9hbGxvd05hdGl2ZVBhbm5pbmcoX2JvZHksIGRpcmVjdGlvbik7XG59LFxuICAgIF9vdmVyZmxvdyA9IHtcbiAgYXV0bzogMSxcbiAgc2Nyb2xsOiAxXG59LFxuICAgIF9uZXN0ZWRTY3JvbGwgPSBmdW5jdGlvbiBfbmVzdGVkU2Nyb2xsKF9yZWY1KSB7XG4gIHZhciBldmVudCA9IF9yZWY1LmV2ZW50LFxuICAgICAgdGFyZ2V0ID0gX3JlZjUudGFyZ2V0LFxuICAgICAgYXhpcyA9IF9yZWY1LmF4aXM7XG5cbiAgdmFyIG5vZGUgPSAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50KS50YXJnZXQsXG4gICAgICBjYWNoZSA9IG5vZGUuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKG5vZGUpLFxuICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICBjcztcblxuICBpZiAoIWNhY2hlLl9pc1Njcm9sbFQgfHwgdGltZSAtIGNhY2hlLl9pc1Njcm9sbFQgPiAyMDAwKSB7XG4gICAgLy8gY2FjaGUgZm9yIDIgc2Vjb25kcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IF9ib2R5ICYmIChub2RlLnNjcm9sbEhlaWdodCA8PSBub2RlLmNsaWVudEhlaWdodCAmJiBub2RlLnNjcm9sbFdpZHRoIDw9IG5vZGUuY2xpZW50V2lkdGggfHwgIShfb3ZlcmZsb3dbKGNzID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSkpLm92ZXJmbG93WV0gfHwgX292ZXJmbG93W2NzLm92ZXJmbG93WF0pKSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBjYWNoZS5faXNTY3JvbGwgPSBub2RlICYmIG5vZGUgIT09IHRhcmdldCAmJiAhX2lzVmlld3BvcnQobm9kZSkgJiYgKF9vdmVyZmxvd1soY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSkub3ZlcmZsb3dZXSB8fCBfb3ZlcmZsb3dbY3Mub3ZlcmZsb3dYXSk7XG4gICAgY2FjaGUuX2lzU2Nyb2xsVCA9IHRpbWU7XG4gIH1cblxuICBpZiAoY2FjaGUuX2lzU2Nyb2xsIHx8IGF4aXMgPT09IFwieFwiKSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQuX2dzYXBBbGxvdyA9IHRydWU7XG4gIH1cbn0sXG4gICAgLy8gY2FwdHVyZSBldmVudHMgb24gc2Nyb2xsYWJsZSBlbGVtZW50cyBJTlNJREUgdGhlIDxib2R5PiBhbmQgYWxsb3cgdGhvc2UgYnkgY2FsbGluZyBzdG9wUHJvcGFnYXRpb24oKSB3aGVuIHdlIGZpbmQgYSBzY3JvbGxhYmxlIGFuY2VzdG9yXG5faW5wdXRPYnNlcnZlciA9IGZ1bmN0aW9uIF9pbnB1dE9ic2VydmVyKHRhcmdldCwgdHlwZSwgaW5wdXRzLCBuZXN0ZWQpIHtcbiAgcmV0dXJuIE9ic2VydmVyLmNyZWF0ZSh7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgY2FwdHVyZTogdHJ1ZSxcbiAgICBkZWJvdW5jZTogZmFsc2UsXG4gICAgbG9ja0F4aXM6IHRydWUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBvbldoZWVsOiBuZXN0ZWQgPSBuZXN0ZWQgJiYgX25lc3RlZFNjcm9sbCxcbiAgICBvblByZXNzOiBuZXN0ZWQsXG4gICAgb25EcmFnOiBuZXN0ZWQsXG4gICAgb25TY3JvbGw6IG5lc3RlZCxcbiAgICBvbkVuYWJsZTogZnVuY3Rpb24gb25FbmFibGUoKSB7XG4gICAgICByZXR1cm4gaW5wdXRzICYmIF9hZGRMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgZmFsc2UsIHRydWUpO1xuICAgIH0sXG4gICAgb25EaXNhYmxlOiBmdW5jdGlvbiBvbkRpc2FibGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZUxpc3RlbmVyKF9kb2MsIE9ic2VydmVyLmV2ZW50VHlwZXNbMF0sIF9jYXB0dXJlSW5wdXRzLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufSxcbiAgICBfaW5wdXRFeHAgPSAvKGlucHV0fGxhYmVsfHNlbGVjdHx0ZXh0YXJlYSkvaSxcbiAgICBfaW5wdXRJc0ZvY3VzZWQsXG4gICAgX2NhcHR1cmVJbnB1dHMgPSBmdW5jdGlvbiBfY2FwdHVyZUlucHV0cyhlKSB7XG4gIHZhciBpc0lucHV0ID0gX2lucHV0RXhwLnRlc3QoZS50YXJnZXQudGFnTmFtZSk7XG5cbiAgaWYgKGlzSW5wdXQgfHwgX2lucHV0SXNGb2N1c2VkKSB7XG4gICAgZS5fZ3NhcEFsbG93ID0gdHJ1ZTtcbiAgICBfaW5wdXRJc0ZvY3VzZWQgPSBpc0lucHV0O1xuICB9XG59LFxuICAgIF9nZXRTY3JvbGxOb3JtYWxpemVyID0gZnVuY3Rpb24gX2dldFNjcm9sbE5vcm1hbGl6ZXIodmFycykge1xuICBfaXNPYmplY3QodmFycykgfHwgKHZhcnMgPSB7fSk7XG4gIHZhcnMucHJldmVudERlZmF1bHQgPSB2YXJzLmlzTm9ybWFsaXplciA9IHZhcnMuYWxsb3dDbGlja3MgPSB0cnVlO1xuICB2YXJzLnR5cGUgfHwgKHZhcnMudHlwZSA9IFwid2hlZWwsdG91Y2hcIik7XG4gIHZhcnMuZGVib3VuY2UgPSAhIXZhcnMuZGVib3VuY2U7XG4gIHZhcnMuaWQgPSB2YXJzLmlkIHx8IFwibm9ybWFsaXplclwiO1xuXG4gIHZhciBfdmFyczIgPSB2YXJzLFxuICAgICAgbm9ybWFsaXplU2Nyb2xsWCA9IF92YXJzMi5ub3JtYWxpemVTY3JvbGxYLFxuICAgICAgbW9tZW50dW0gPSBfdmFyczIubW9tZW50dW0sXG4gICAgICBhbGxvd05lc3RlZFNjcm9sbCA9IF92YXJzMi5hbGxvd05lc3RlZFNjcm9sbCxcbiAgICAgIG9uUmVsZWFzZSA9IF92YXJzMi5vblJlbGVhc2UsXG4gICAgICBzZWxmLFxuICAgICAgbWF4WSxcbiAgICAgIHRhcmdldCA9IF9nZXRUYXJnZXQodmFycy50YXJnZXQpIHx8IF9kb2NFbCxcbiAgICAgIHNtb290aGVyID0gZ3NhcC5jb3JlLmdsb2JhbHMoKS5TY3JvbGxTbW9vdGhlcixcbiAgICAgIHNtb290aGVySW5zdGFuY2UgPSBzbW9vdGhlciAmJiBzbW9vdGhlci5nZXQoKSxcbiAgICAgIGNvbnRlbnQgPSBfZml4SU9TQnVnICYmICh2YXJzLmNvbnRlbnQgJiYgX2dldFRhcmdldCh2YXJzLmNvbnRlbnQpIHx8IHNtb290aGVySW5zdGFuY2UgJiYgdmFycy5jb250ZW50ICE9PSBmYWxzZSAmJiAhc21vb3RoZXJJbnN0YW5jZS5zbW9vdGgoKSAmJiBzbW9vdGhlckluc3RhbmNlLmNvbnRlbnQoKSksXG4gICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICBzY2FsZSA9IDEsXG4gICAgICBpbml0aWFsU2NhbGUgPSAoT2JzZXJ2ZXIuaXNUb3VjaCAmJiBfd2luLnZpc3VhbFZpZXdwb3J0ID8gX3dpbi52aXN1YWxWaWV3cG9ydC5zY2FsZSAqIF93aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiBfd2luLm91dGVyV2lkdGgpIC8gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgd2hlZWxSZWZyZXNoID0gMCxcbiAgICAgIHJlc29sdmVNb21lbnR1bUR1cmF0aW9uID0gX2lzRnVuY3Rpb24obW9tZW50dW0pID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtb21lbnR1bShzZWxmKTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0gfHwgMi44O1xuICB9LFxuICAgICAgbGFzdFJlZnJlc2hJRCxcbiAgICAgIHNraXBUb3VjaE1vdmUsXG4gICAgICBpbnB1dE9ic2VydmVyID0gX2lucHV0T2JzZXJ2ZXIodGFyZ2V0LCB2YXJzLnR5cGUsIHRydWUsIGFsbG93TmVzdGVkU2Nyb2xsKSxcbiAgICAgIHJlc3VtZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIHJlc3VtZVRvdWNoTW92ZSgpIHtcbiAgICByZXR1cm4gc2tpcFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9LFxuICAgICAgc2Nyb2xsQ2xhbXBYID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgc2Nyb2xsQ2xhbXBZID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgdXBkYXRlQ2xhbXBzID0gZnVuY3Rpb24gdXBkYXRlQ2xhbXBzKCkge1xuICAgIG1heFkgPSBfbWF4U2Nyb2xsKHRhcmdldCwgX3ZlcnRpY2FsKTtcbiAgICBzY3JvbGxDbGFtcFkgPSBfY2xhbXAoX2ZpeElPU0J1ZyA/IDEgOiAwLCBtYXhZKTtcbiAgICBub3JtYWxpemVTY3JvbGxYICYmIChzY3JvbGxDbGFtcFggPSBfY2xhbXAoMCwgX21heFNjcm9sbCh0YXJnZXQsIF9ob3Jpem9udGFsKSkpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9LFxuICAgICAgcmVtb3ZlQ29udGVudE9mZnNldCA9IGZ1bmN0aW9uIHJlbW92ZUNvbnRlbnRPZmZzZXQoKSB7XG4gICAgY29udGVudC5fZ3NhcC55ID0gX3JvdW5kKHBhcnNlRmxvYXQoY29udGVudC5fZ3NhcC55KSArIHNjcm9sbEZ1bmNZLm9mZnNldCkgKyBcInB4XCI7XG4gICAgY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgcGFyc2VGbG9hdChjb250ZW50Ll9nc2FwLnkpICsgXCIsIDAsIDEpXCI7XG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ID0gc2Nyb2xsRnVuY1kuY2FjaGVJRCA9IDA7XG4gIH0sXG4gICAgICBpZ25vcmVEcmFnID0gZnVuY3Rpb24gaWdub3JlRHJhZygpIHtcbiAgICBpZiAoc2tpcFRvdWNoTW92ZSkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZVRvdWNoTW92ZSk7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBfcm91bmQoc2VsZi5kZWx0YVkgLyAyKSxcbiAgICAgICAgICBzY3JvbGwgPSBzY3JvbGxDbGFtcFkoc2Nyb2xsRnVuY1kudiAtIG9mZnNldCk7XG5cbiAgICAgIGlmIChjb250ZW50ICYmIHNjcm9sbCAhPT0gc2Nyb2xsRnVuY1kudiArIHNjcm9sbEZ1bmNZLm9mZnNldCkge1xuICAgICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGwgLSBzY3JvbGxGdW5jWS52O1xuXG4gICAgICAgIHZhciB5ID0gX3JvdW5kKChwYXJzZUZsb2F0KGNvbnRlbnQgJiYgY29udGVudC5fZ3NhcC55KSB8fCAwKSAtIHNjcm9sbEZ1bmNZLm9mZnNldCk7XG5cbiAgICAgICAgY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgeSArIFwiLCAwLCAxKVwiO1xuICAgICAgICBjb250ZW50Ll9nc2FwLnkgPSB5ICsgXCJweFwiO1xuICAgICAgICBzY3JvbGxGdW5jWS5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcblxuICAgICAgICBfdXBkYXRlQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNjcm9sbEZ1bmNZLm9mZnNldCAmJiByZW1vdmVDb250ZW50T2Zmc2V0KCk7XG4gICAgc2tpcFRvdWNoTW92ZSA9IHRydWU7XG4gIH0sXG4gICAgICB0d2VlbixcbiAgICAgIHN0YXJ0U2Nyb2xsWCxcbiAgICAgIHN0YXJ0U2Nyb2xsWSxcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLFxuICAgICAgb25SZXNpemUgPSBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAvLyBpZiB0aGUgd2luZG93IHJlc2l6ZXMsIGxpa2Ugb24gYW4gaVBob25lIHdoaWNoIEFwcGxlIEZPUkNFUyB0aGUgYWRkcmVzcyBiYXIgdG8gc2hvdy9oaWRlIGV2ZW4gaWYgd2UgZXZlbnQucHJldmVudERlZmF1bHQoKSwgaXQgbWF5IGJlIHNjcm9sbGluZyB0b28gZmFyIG5vdyB0aGF0IHRoZSBhZGRyZXNzIGJhciBpcyBzaG93aW5nLCBzbyB3ZSBtdXN0IGR5bmFtaWNhbGx5IGFkanVzdCB0aGUgbW9tZW50dW0gdHdlZW4uXG4gICAgdXBkYXRlQ2xhbXBzKCk7XG5cbiAgICBpZiAodHdlZW4uaXNBY3RpdmUoKSAmJiB0d2Vlbi52YXJzLnNjcm9sbFkgPiBtYXhZKSB7XG4gICAgICBzY3JvbGxGdW5jWSgpID4gbWF4WSA/IHR3ZWVuLnByb2dyZXNzKDEpICYmIHNjcm9sbEZ1bmNZKG1heFkpIDogdHdlZW4ucmVzZXRUbyhcInNjcm9sbFlcIiwgbWF4WSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnRlbnQgJiYgZ3NhcC5zZXQoY29udGVudCwge1xuICAgIHk6IFwiKz0wXCJcbiAgfSk7IC8vIHRvIGVuc3VyZSB0aGVyZSdzIGEgY2FjaGUgKGVsZW1lbnQuX2dzYXApXG5cbiAgdmFycy5pZ25vcmVDaGVjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIF9maXhJT1NCdWcgJiYgZS50eXBlID09PSBcInRvdWNobW92ZVwiICYmIGlnbm9yZURyYWcoZSkgfHwgc2NhbGUgPiAxLjA1ICYmIGUudHlwZSAhPT0gXCJ0b3VjaHN0YXJ0XCIgfHwgc2VsZi5pc0dlc3R1cmluZyB8fCBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDE7XG4gIH07XG5cbiAgdmFycy5vblByZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHNraXBUb3VjaE1vdmUgPSBmYWxzZTtcbiAgICB2YXIgcHJldlNjYWxlID0gc2NhbGU7XG4gICAgc2NhbGUgPSBfcm91bmQoKF93aW4udmlzdWFsVmlld3BvcnQgJiYgX3dpbi52aXN1YWxWaWV3cG9ydC5zY2FsZSB8fCAxKSAvIGluaXRpYWxTY2FsZSk7XG4gICAgdHdlZW4ucGF1c2UoKTtcbiAgICBwcmV2U2NhbGUgIT09IHNjYWxlICYmIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCBzY2FsZSA+IDEuMDEgPyB0cnVlIDogbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuICAgIHN0YXJ0U2Nyb2xsWCA9IHNjcm9sbEZ1bmNYKCk7XG4gICAgc3RhcnRTY3JvbGxZID0gc2Nyb2xsRnVuY1koKTtcbiAgICB1cGRhdGVDbGFtcHMoKTtcbiAgICBsYXN0UmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgfTtcblxuICB2YXJzLm9uUmVsZWFzZSA9IHZhcnMub25HZXN0dXJlU3RhcnQgPSBmdW5jdGlvbiAoc2VsZiwgd2FzRHJhZ2dpbmcpIHtcbiAgICBzY3JvbGxGdW5jWS5vZmZzZXQgJiYgcmVtb3ZlQ29udGVudE9mZnNldCgpO1xuXG4gICAgaWYgKCF3YXNEcmFnZ2luZykge1xuICAgICAgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Njcm9sbGVycy5jYWNoZSsrOyAvLyBtYWtlIHN1cmUgd2UncmUgcHVsbGluZyB0aGUgbm9uLWNhY2hlZCB2YWx1ZVxuICAgICAgLy8gYWx0ZXJuYXRlIGFsZ29yaXRobTogZHVyWCA9IE1hdGgubWluKDYsIE1hdGguYWJzKHNlbGYudmVsb2NpdHlYIC8gODAwKSksXHRkdXIgPSBNYXRoLm1heChkdXJYLCBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WSAvIDgwMCkpKTsgZHVyID0gZHVyICogKDAuNCArICgxIC0gX3Bvd2VyNEluKGR1ciAvIDYpKSAqIDAuNikpICogKG1vbWVudHVtU3BlZWQgfHwgMSlcblxuICAgICAgdmFyIGR1ciA9IHJlc29sdmVNb21lbnR1bUR1cmF0aW9uKCksXG4gICAgICAgICAgY3VycmVudFNjcm9sbCxcbiAgICAgICAgICBlbmRTY3JvbGw7XG5cbiAgICAgIGlmIChub3JtYWxpemVTY3JvbGxYKSB7XG4gICAgICAgIGN1cnJlbnRTY3JvbGwgPSBzY3JvbGxGdW5jWCgpO1xuICAgICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WCAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KS4gdmVsb2NpdHkgaXMgaW52ZXJ0ZWQgYmVjYXVzZSBzY3JvbGxpbmcgZ29lcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuXG4gICAgICAgIGR1ciAqPSBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIoc2Nyb2xsRnVuY1gsIGN1cnJlbnRTY3JvbGwsIGVuZFNjcm9sbCwgX21heFNjcm9sbCh0YXJnZXQsIF9ob3Jpem9udGFsKSk7XG4gICAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWCA9IHNjcm9sbENsYW1wWChlbmRTY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsRnVuY1koKTtcbiAgICAgIGVuZFNjcm9sbCA9IGN1cnJlbnRTY3JvbGwgKyBkdXIgKiAwLjA1ICogLXNlbGYudmVsb2NpdHlZIC8gMC4yMjc7IC8vIHRoZSBjb25zdGFudCAuMjI3IGlzIGZyb20gcG93ZXI0KDAuMDUpXG5cbiAgICAgIGR1ciAqPSBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIoc2Nyb2xsRnVuY1ksIGN1cnJlbnRTY3JvbGwsIGVuZFNjcm9sbCwgX21heFNjcm9sbCh0YXJnZXQsIF92ZXJ0aWNhbCkpO1xuICAgICAgdHdlZW4udmFycy5zY3JvbGxZID0gc2Nyb2xsQ2xhbXBZKGVuZFNjcm9sbCk7XG4gICAgICB0d2Vlbi5pbnZhbGlkYXRlKCkuZHVyYXRpb24oZHVyKS5wbGF5KDAuMDEpO1xuXG4gICAgICBpZiAoX2ZpeElPU0J1ZyAmJiB0d2Vlbi52YXJzLnNjcm9sbFkgPj0gbWF4WSB8fCBjdXJyZW50U2Nyb2xsID49IG1heFkgLSAxKSB7XG4gICAgICAgIC8vIGlPUyBidWc6IGl0J2xsIHNob3cgdGhlIGFkZHJlc3MgYmFyIGJ1dCBOT1QgZmlyZSB0aGUgd2luZG93IFwicmVzaXplXCIgZXZlbnQgdW50aWwgdGhlIGFuaW1hdGlvbiBpcyBkb25lIGJ1dCB3ZSBtdXN0IHByb3RlY3QgYWdhaW5zdCBvdmVyc2hvb3Qgc28gd2UgbGV2ZXJhZ2UgYW4gb25VcGRhdGUgdG8gZG8gc28uXG4gICAgICAgIGdzYXAudG8oe30sIHtcbiAgICAgICAgICBvblVwZGF0ZTogb25SZXNpemUsXG4gICAgICAgICAgZHVyYXRpb246IGR1clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvblJlbGVhc2UgJiYgb25SZWxlYXNlKHNlbGYpO1xuICB9O1xuXG4gIHZhcnMub25XaGVlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0d2Vlbi5fdHMgJiYgdHdlZW4ucGF1c2UoKTtcblxuICAgIGlmIChfZ2V0VGltZSgpIC0gd2hlZWxSZWZyZXNoID4gMTAwMCkge1xuICAgICAgLy8gYWZ0ZXIgMSBzZWNvbmQsIHJlZnJlc2ggdGhlIGNsYW1wcyBvdGhlcndpc2UgdGhhdCdsbCBvbmx5IGhhcHBlbiB3aGVuIFNjcm9sbFRyaWdnZXIucmVmcmVzaCgpIGlzIGNhbGxlZCBvciBmb3IgdG91Y2gtc2Nyb2xsaW5nLlxuICAgICAgbGFzdFJlZnJlc2hJRCA9IDA7XG4gICAgICB3aGVlbFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXJzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHNlbGYsIGR4LCBkeSwgeEFycmF5LCB5QXJyYXkpIHtcbiAgICBfcmVmcmVzaElEICE9PSBsYXN0UmVmcmVzaElEICYmIHVwZGF0ZUNsYW1wcygpO1xuICAgIGR4ICYmIG5vcm1hbGl6ZVNjcm9sbFggJiYgc2Nyb2xsRnVuY1goc2Nyb2xsQ2xhbXBYKHhBcnJheVsyXSA9PT0gZHggPyBzdGFydFNjcm9sbFggKyAoc2VsZi5zdGFydFggLSBzZWxmLngpIDogc2Nyb2xsRnVuY1goKSArIGR4IC0geEFycmF5WzFdKSk7IC8vIGZvciBtb3JlIHByZWNpc2lvbiwgd2UgdHJhY2sgcG9pbnRlci90b3VjaCBtb3ZlbWVudCBmcm9tIHRoZSBzdGFydCwgb3RoZXJ3aXNlIGl0J2xsIGRyaWZ0LlxuXG4gICAgaWYgKGR5KSB7XG4gICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgJiYgcmVtb3ZlQ29udGVudE9mZnNldCgpO1xuICAgICAgdmFyIGlzVG91Y2ggPSB5QXJyYXlbMl0gPT09IGR5LFxuICAgICAgICAgIHkgPSBpc1RvdWNoID8gc3RhcnRTY3JvbGxZICsgc2VsZi5zdGFydFkgLSBzZWxmLnkgOiBzY3JvbGxGdW5jWSgpICsgZHkgLSB5QXJyYXlbMV0sXG4gICAgICAgICAgeUNsYW1wZWQgPSBzY3JvbGxDbGFtcFkoeSk7XG4gICAgICBpc1RvdWNoICYmIHkgIT09IHlDbGFtcGVkICYmIChzdGFydFNjcm9sbFkgKz0geUNsYW1wZWQgLSB5KTtcbiAgICAgIHNjcm9sbEZ1bmNZKHlDbGFtcGVkKTtcbiAgICB9XG5cbiAgICAoZHkgfHwgZHgpICYmIF91cGRhdGVBbGwoKTtcbiAgfTtcblxuICB2YXJzLm9uRW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCBub3JtYWxpemVTY3JvbGxYID8gZmFsc2UgOiBcInhcIik7XG5cbiAgICBTY3JvbGxUcmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWZyZXNoXCIsIG9uUmVzaXplKTtcblxuICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG5cbiAgICBpZiAoc2Nyb2xsRnVuY1kuc21vb3RoKSB7XG4gICAgICBzY3JvbGxGdW5jWS50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgICAgIHNjcm9sbEZ1bmNZLnNtb290aCA9IHNjcm9sbEZ1bmNYLnNtb290aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlucHV0T2JzZXJ2ZXIuZW5hYmxlKCk7XG4gIH07XG5cbiAgdmFycy5vbkRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIHRydWUpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF93aW4sIFwicmVzaXplXCIsIG9uUmVzaXplKTtcblxuICAgIFNjcm9sbFRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlZnJlc2hcIiwgb25SZXNpemUpO1xuICAgIGlucHV0T2JzZXJ2ZXIua2lsbCgpO1xuICB9O1xuXG4gIHZhcnMubG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzICE9PSBmYWxzZTtcbiAgc2VsZiA9IG5ldyBPYnNlcnZlcih2YXJzKTtcbiAgc2VsZi5pT1MgPSBfZml4SU9TQnVnOyAvLyB1c2VkIGluIHRoZSBPYnNlcnZlciBnZXRDYWNoZWRTY3JvbGwoKSBmdW5jdGlvbiB0byB3b3JrIGFyb3VuZCBhbiBpT1MgYnVnIHRoYXQgd3JlYWtzIGhhdm9jIHdpdGggVG91Y2hFdmVudC5jbGllbnRZIGlmIHdlIGFsbG93IHNjcm9sbCB0byBnbyBhbGwgdGhlIHdheSBiYWNrIHRvIDAuXG5cbiAgX2ZpeElPU0J1ZyAmJiAhc2Nyb2xsRnVuY1koKSAmJiBzY3JvbGxGdW5jWSgxKTsgLy8gaU9TIGJ1ZyBjYXVzZXMgZXZlbnQuY2xpZW50WSB2YWx1ZXMgdG8gZnJlYWsgb3V0ICh3aWxkbHkgaW5hY2N1cmF0ZSkgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBleGFjdGx5IDAuXG5cbiAgX2ZpeElPU0J1ZyAmJiBnc2FwLnRpY2tlci5hZGQoX3Bhc3NUaHJvdWdoKTsgLy8gcHJldmVudCB0aGUgdGlja2VyIGZyb20gc2xlZXBpbmdcblxuICBvblN0b3BEZWxheWVkQ2FsbCA9IHNlbGYuX2RjO1xuICB0d2VlbiA9IGdzYXAudG8oc2VsZiwge1xuICAgIGVhc2U6IFwicG93ZXI0XCIsXG4gICAgcGF1c2VkOiB0cnVlLFxuICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIHNjcm9sbFg6IG5vcm1hbGl6ZVNjcm9sbFggPyBcIis9MC4xXCIgOiBcIis9MFwiLFxuICAgIHNjcm9sbFk6IFwiKz0wLjFcIixcbiAgICBtb2RpZmllcnM6IHtcbiAgICAgIHNjcm9sbFk6IF9pbnRlcnJ1cHRpb25UcmFja2VyKHNjcm9sbEZ1bmNZLCBzY3JvbGxGdW5jWSgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0d2Vlbi5wYXVzZSgpO1xuICAgICAgfSlcbiAgICB9LFxuICAgIG9uVXBkYXRlOiBfdXBkYXRlQWxsLFxuICAgIG9uQ29tcGxldGU6IG9uU3RvcERlbGF5ZWRDYWxsLnZhcnMub25Db21wbGV0ZVxuICB9KTsgLy8gd2UgbmVlZCB0aGUgbW9kaWZpZXIgdG8gc2Vuc2UgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBhbHRlcmVkIG91dHNpZGUgb2YgdGhlIG1vbWVudHVtIHR3ZWVuIChsaWtlIHdpdGggYSBzY3JvbGxUbyB0d2Vlbikgc28gd2UgY2FuIHBhdXNlKCkgaXQgdG8gcHJldmVudCBjb25mbGljdHMuXG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnNvcnQgPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAoX2lzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm4gX3RyaWdnZXJzLnNvcnQoZnVuYyk7XG4gIH1cblxuICB2YXIgc2Nyb2xsID0gX3dpbi5wYWdlWU9mZnNldCB8fCAwO1xuICBTY3JvbGxUcmlnZ2VyLmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fc29ydFkgPSB0LnRyaWdnZXIgPyBzY3JvbGwgKyB0LnRyaWdnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogdC5zdGFydCArIF93aW4uaW5uZXJIZWlnaHQ7XG4gIH0pO1xuICByZXR1cm4gX3RyaWdnZXJzLnNvcnQoZnVuYyB8fCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYS52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYgKyAoYS52YXJzLmNvbnRhaW5lckFuaW1hdGlvbiA/IDFlNiA6IGEuX3NvcnRZKSAtICgoYi52YXJzLmNvbnRhaW5lckFuaW1hdGlvbiA/IDFlNiA6IGIuX3NvcnRZKSArIChiLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNik7XG4gIH0pOyAvLyBhbnl0aGluZyB3aXRoIGEgY29udGFpbmVyQW5pbWF0aW9uIHNob3VsZCByZWZyZXNoIGxhc3QuXG59O1xuXG5TY3JvbGxUcmlnZ2VyLm9ic2VydmUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwgPSBmdW5jdGlvbiAodmFycykge1xuICBpZiAodHlwZW9mIHZhcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZXI7XG4gIH1cblxuICBpZiAodmFycyA9PT0gdHJ1ZSAmJiBfbm9ybWFsaXplcikge1xuICAgIHJldHVybiBfbm9ybWFsaXplci5lbmFibGUoKTtcbiAgfVxuXG4gIGlmICh2YXJzID09PSBmYWxzZSkge1xuICAgIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgICBfbm9ybWFsaXplciA9IHZhcnM7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZXIgPSB2YXJzIGluc3RhbmNlb2YgT2JzZXJ2ZXIgPyB2YXJzIDogX2dldFNjcm9sbE5vcm1hbGl6ZXIodmFycyk7XG4gIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLnRhcmdldCA9PT0gbm9ybWFsaXplci50YXJnZXQgJiYgX25vcm1hbGl6ZXIua2lsbCgpO1xuICBfaXNWaWV3cG9ydChub3JtYWxpemVyLnRhcmdldCkgJiYgKF9ub3JtYWxpemVyID0gbm9ybWFsaXplcik7XG4gIHJldHVybiBub3JtYWxpemVyO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jb3JlID0ge1xuICAvLyBzbWFsbGVyIGZpbGUgc2l6ZSB3YXkgdG8gbGV2ZXJhZ2UgaW4gU2Nyb2xsU21vb3RoZXIgYW5kIE9ic2VydmVyXG4gIF9nZXRWZWxvY2l0eVByb3A6IF9nZXRWZWxvY2l0eVByb3AsXG4gIF9pbnB1dE9ic2VydmVyOiBfaW5wdXRPYnNlcnZlcixcbiAgX3Njcm9sbGVyczogX3Njcm9sbGVycyxcbiAgX3Byb3hpZXM6IF9wcm94aWVzLFxuICBicmlkZ2U6IHtcbiAgICAvLyB3aGVuIG5vcm1hbGl6ZVNjcm9sbCBzZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gKHNzID0gc2V0U2Nyb2xsKVxuICAgIHNzOiBmdW5jdGlvbiBzcygpIHtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAvLyBhIHdheSB0byBnZXQgdGhlIF9yZWZyZXNoaW5nIHZhbHVlIGluIE9ic2VydmVyXG4gICAgcmVmOiBmdW5jdGlvbiByZWYoKSB7XG4gICAgICByZXR1cm4gX3JlZnJlc2hpbmc7XG4gICAgfVxuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuZXhwb3J0IHsgU2Nyb2xsVHJpZ2dlciBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbIk9ic2VydmVyIiwiX2dldFRhcmdldCIsIl92ZXJ0aWNhbCIsIl9ob3Jpem9udGFsIiwiX3Njcm9sbGVycyIsIl9wcm94aWVzIiwiX2dldFNjcm9sbEZ1bmMiLCJfZ2V0UHJveHlQcm9wIiwiX2dldFZlbG9jaXR5UHJvcCIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfd2luIiwiX2RvYyIsIl9kb2NFbCIsIl9ib2R5IiwiX3Jvb3QiLCJfcmVzaXplRGVsYXkiLCJfdG9BcnJheSIsIl9jbGFtcCIsIl90aW1lMiIsIl9zeW5jSW50ZXJ2YWwiLCJfcmVmcmVzaGluZyIsIl9wb2ludGVySXNEb3duIiwiX3RyYW5zZm9ybVByb3AiLCJfaSIsIl9wcmV2V2lkdGgiLCJfcHJldkhlaWdodCIsIl9hdXRvUmVmcmVzaCIsIl9zb3J0IiwiX3N1cHByZXNzT3ZlcndyaXRlcyIsIl9pZ25vcmVSZXNpemUiLCJfbm9ybWFsaXplciIsIl9pZ25vcmVNb2JpbGVSZXNpemUiLCJfYmFzZVNjcmVlbkhlaWdodCIsIl9iYXNlU2NyZWVuV2lkdGgiLCJfZml4SU9TQnVnIiwiX2NvbnRleHQiLCJfc2Nyb2xsUmVzdG9yYXRpb24iLCJfZGl2MTAwdmgiLCJfMTAwdmgiLCJfaXNSZXZlcnRlZCIsIl9jbGFtcGluZ01heCIsIl9saW1pdENhbGxiYWNrcyIsIl9zdGFydHVwIiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiX3RpbWUxIiwiX2xhc3RTY3JvbGxUaW1lIiwiX2VuYWJsZWQiLCJfcGFyc2VDbGFtcCIsInZhbHVlIiwidHlwZSIsInNlbGYiLCJjbGFtcCIsIl9pc1N0cmluZyIsInN1YnN0ciIsImluZGV4T2YiLCJsZW5ndGgiLCJfa2VlcENsYW1wIiwiX3JhZkJ1Z0ZpeCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9wb2ludGVyRG93bkhhbmRsZXIiLCJfcG9pbnRlclVwSGFuZGxlciIsIl9wYXNzVGhyb3VnaCIsInYiLCJfcm91bmQiLCJNYXRoIiwicm91bmQiLCJfd2luZG93RXhpc3RzIiwiX2dldEdTQVAiLCJ3aW5kb3ciLCJyZWdpc3RlclBsdWdpbiIsIl9pc1ZpZXdwb3J0IiwiZSIsIl9nZXRWaWV3cG9ydERpbWVuc2lvbiIsImRpbWVuc2lvblByb3BlcnR5IiwiX2dldEJvdW5kc0Z1bmMiLCJlbGVtZW50IiwiX3dpbk9mZnNldHMiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJfZ2V0Qm91bmRzIiwiX2dldFNpemVGdW5jIiwic2Nyb2xsZXIiLCJpc1ZpZXdwb3J0IiwiX3JlZiIsImQiLCJkMiIsImEiLCJfZ2V0T2Zmc2V0c0Z1bmMiLCJfbWF4U2Nyb2xsIiwiX3JlZjIiLCJzIiwibWF4IiwiX2l0ZXJhdGVBdXRvUmVmcmVzaCIsImZ1bmMiLCJldmVudHMiLCJpIiwiX2lzRnVuY3Rpb24iLCJfaXNOdW1iZXIiLCJfaXNPYmplY3QiLCJfZW5kQW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwicmV2ZXJzZWQiLCJwYXVzZSIsInByb2dyZXNzIiwiX2NhbGxiYWNrIiwiZW5hYmxlZCIsInJlc3VsdCIsIl9jdHgiLCJhZGQiLCJ0b3RhbFRpbWUiLCJjYWxsYmFja0FuaW1hdGlvbiIsIl9hYnMiLCJhYnMiLCJfbGVmdCIsIl90b3AiLCJfcmlnaHQiLCJfYm90dG9tIiwiX3dpZHRoIiwiX2hlaWdodCIsIl9SaWdodCIsIl9MZWZ0IiwiX1RvcCIsIl9Cb3R0b20iLCJfcGFkZGluZyIsIl9tYXJnaW4iLCJfV2lkdGgiLCJfSGVpZ2h0IiwiX3B4IiwiX2dldENvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiX21ha2VQb3NpdGlvbmFibGUiLCJwb3NpdGlvbiIsInN0eWxlIiwiX3NldERlZmF1bHRzIiwib2JqIiwiZGVmYXVsdHMiLCJwIiwid2l0aG91dFRyYW5zZm9ybXMiLCJ0d2VlbiIsInRvIiwieCIsInkiLCJ4UGVyY2VudCIsInlQZXJjZW50Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJzY2FsZSIsInNrZXdYIiwic2tld1kiLCJib3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJraWxsIiwiX2dldFNpemUiLCJfcmVmMyIsIl9nZXRMYWJlbFJhdGlvQXJyYXkiLCJ0aW1lbGluZSIsImxhYmVscyIsImR1cmF0aW9uIiwicHVzaCIsIl9nZXRDbG9zZXN0TGFiZWwiLCJ1dGlscyIsInNuYXAiLCJfc25hcERpcmVjdGlvbmFsIiwic25hcEluY3JlbWVudE9yQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInNvcnQiLCJiIiwiZGlyZWN0aW9uIiwidGhyZXNob2xkIiwic25hcHBlZCIsIl9nZXRMYWJlbEF0RGlyZWN0aW9uIiwic3QiLCJfbXVsdGlMaXN0ZW5lciIsInR5cGVzIiwiY2FsbGJhY2siLCJzcGxpdCIsImZvckVhY2giLCJfYWRkTGlzdGVuZXIiLCJub25QYXNzaXZlIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl93aGVlbExpc3RlbmVyIiwiZWwiLCJzY3JvbGxGdW5jIiwid2hlZWxIYW5kbGVyIiwiX21hcmtlckRlZmF1bHRzIiwic3RhcnRDb2xvciIsImVuZENvbG9yIiwiaW5kZW50IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwiX2RlZmF1bHRzIiwidG9nZ2xlQWN0aW9ucyIsImFudGljaXBhdGVQaW4iLCJfa2V5d29yZHMiLCJ0b3AiLCJsZWZ0IiwiY2VudGVyIiwiYm90dG9tIiwicmlnaHQiLCJfb2Zmc2V0VG9QeCIsInNpemUiLCJlcUluZGV4IiwicmVsYXRpdmUiLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwiX2NyZWF0ZU1hcmtlciIsIm5hbWUiLCJjb250YWluZXIiLCJfcmVmNCIsIm9mZnNldCIsIm1hdGNoV2lkdGhFbCIsImNvbnRhaW5lckFuaW1hdGlvbiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VGaXhlZFBvc2l0aW9uIiwiaXNTY3JvbGxlciIsInBhcmVudCIsImlzU3RhcnQiLCJjb2xvciIsImNzcyIsIm9mZnNldFdpZHRoIiwiX2lzU3RhcnQiLCJzZXRBdHRyaWJ1dGUiLCJjc3NUZXh0IiwiaW5uZXJUZXh0IiwiY2hpbGRyZW4iLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsIl9vZmZzZXQiLCJvcCIsIl9wb3NpdGlvbk1hcmtlciIsIm1hcmtlciIsInN0YXJ0IiwiZmxpcHBlZCIsInZhcnMiLCJkaXNwbGF5Iiwic2lkZSIsIm9wcG9zaXRlU2lkZSIsIl9pc0ZsaXBwZWQiLCJzZXQiLCJfdHJpZ2dlcnMiLCJfaWRzIiwiX3JhZklEIiwiX3N5bmMiLCJfdXBkYXRlQWxsIiwiX29uU2Nyb2xsIiwiaXNQcmVzc2VkIiwic3RhcnRYIiwiY2xpZW50V2lkdGgiLCJjYWNoZSIsIl9kaXNwYXRjaCIsIl9zZXRCYXNlRGltZW5zaW9ucyIsImlubmVySGVpZ2h0IiwiX29uUmVzaXplIiwiZm9yY2UiLCJmdWxsc2NyZWVuRWxlbWVudCIsIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IiwicmVzdGFydCIsIl9saXN0ZW5lcnMiLCJfZW1wdHlBcnJheSIsIl9zb2Z0UmVmcmVzaCIsIlNjcm9sbFRyaWdnZXIiLCJfcmVmcmVzaEFsbCIsIm1hcCIsImYiLCJfc2F2ZWRTdHlsZXMiLCJfcmV2ZXJ0UmVjb3JkZWQiLCJtZWRpYSIsInF1ZXJ5IiwiZ2V0QkJveCIsInVuY2FjaGUiLCJfcmVjb3JkU2Nyb2xsUG9zaXRpb25zIiwiY2FjaGVJRCIsInJlYyIsIl9yZXZlcnRBbGwiLCJ0cmlnZ2VyIiwicmV2ZXJ0IiwiX2NsZWFyU2Nyb2xsTWVtb3J5Iiwic2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmcmVzaGluZ0FsbCIsImhpc3RvcnkiLCJfcmVmcmVzaElEIiwiX3F1ZXVlUmVmcmVzaElEIiwiX3F1ZXVlUmVmcmVzaEFsbCIsImlkIiwiX3JlZnJlc2gxMDB2aCIsIm9mZnNldEhlaWdodCIsInJlbW92ZUNoaWxkIiwiX2hpZGVBbGxNYXJrZXJzIiwiaGlkZSIsInNraXBSZXZlcnQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwiaXNSZWZyZXNoaW5nIiwicmVmcmVzaEluaXRzIiwic21vb3RoIiwidGFyZ2V0Iiwic2Nyb2xsQmVoYXZpb3IiLCJ0IiwicmVmcmVzaCIsIl9zdWJQaW5PZmZzZXQiLCJwaW4iLCJwcm9wIiwiaG9yaXpvbnRhbCIsIm9yaWdpbmFsIiwiYWRqdXN0UGluU3BhY2luZyIsIl9kaXIiLCJlbmRDbGFtcCIsImVuZCIsIl9lbmRDbGFtcCIsInN0YXJ0Q2xhbXAiLCJfc3RhcnRDbGFtcCIsInNldFBvc2l0aW9ucyIsInJlbmRlciIsIm9uUmVmcmVzaCIsIl9sYXN0U2Nyb2xsIiwiX2RpcmVjdGlvbiIsIl9wcmltYXJ5IiwiaXNVcGRhdGluZyIsInVwZGF0ZSIsImwiLCJ0aW1lIiwicmVjb3JkVmVsb2NpdHkiLCJzY3JvbGwiLCJfcHJvcE5hbWVzVG9Db3B5IiwiX3N0YXRlUHJvcHMiLCJjb25jYXQiLCJfc3dhcFBpbk91dCIsInNwYWNlciIsInN0YXRlIiwiX3NldFN0YXRlIiwiX2dzYXAiLCJzcGFjZXJJc05hdGl2ZSIsInNwYWNlclN0YXRlIiwic3dhcHBlZEluIiwicGFyZW50Tm9kZSIsIl9zd2FwUGluSW4iLCJjcyIsInNwYWNlclN0eWxlIiwicGluU3R5bGUiLCJmbGV4QmFzaXMiLCJvdmVyZmxvdyIsImJveFNpemluZyIsIl9jYXBzRXhwIiwiY29yZSIsImdldENhY2hlIiwicmVtb3ZlUHJvcGVydHkiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJfZ2V0U3RhdGUiLCJfY29weVN0YXRlIiwib3ZlcnJpZGUiLCJvbWl0T2Zmc2V0cyIsIl9wYXJzZVBvc2l0aW9uIiwic2Nyb2xsZXJTaXplIiwibWFya2VyU2Nyb2xsZXIiLCJzY3JvbGxlckJvdW5kcyIsImJvcmRlcldpZHRoIiwic2Nyb2xsZXJNYXgiLCJjbGFtcFplcm9Qcm9wIiwicDEiLCJwMiIsInNlZWsiLCJpc05hTiIsIm9mZnNldHMiLCJsb2NhbE9mZnNldCIsImdsb2JhbE9mZnNldCIsIm1hcFJhbmdlIiwic2Nyb2xsVHJpZ2dlciIsIm0iLCJfY2FTY3JvbGxEaXN0IiwiX3ByZWZpeEV4cCIsIl9yZXBhcmVudCIsIl9zdE9yaWciLCJ0ZXN0IiwiX2ludGVycnVwdGlvblRyYWNrZXIiLCJnZXRWYWx1ZUZ1bmMiLCJpbml0aWFsVmFsdWUiLCJvbkludGVycnVwdCIsImxhc3QxIiwibGFzdDIiLCJjdXJyZW50IiwiX3NoaWZ0TWFya2VyIiwiX2dldFR3ZWVuQ3JlYXRvciIsImdldFNjcm9sbCIsImdldFR3ZWVuIiwic2Nyb2xsVG8iLCJjaGFuZ2UxIiwiY2hhbmdlMiIsIm9uQ29tcGxldGUiLCJtb2RpZmllcnMiLCJjaGVja0ZvckludGVycnVwdGlvbiIsImluaGVyaXQiLCJyYXRpbyIsIm9uVXBkYXRlIiwiY2FsbCIsImlzVG91Y2giLCJyZWdpc3RlciIsImNvbnNvbGUiLCJ3YXJuIiwiaW5pdCIsIl9wcm90byIsInByb3RvdHlwZSIsIm5vZGVUeXBlIiwiX3ZhcnMiLCJ0b2dnbGVDbGFzcyIsIm9uVG9nZ2xlIiwic2NydWIiLCJwaW5TcGFjaW5nIiwiaW52YWxpZGF0ZU9uUmVmcmVzaCIsIm9uU2NydWJDb21wbGV0ZSIsIm9uU25hcENvbXBsZXRlIiwib25jZSIsInBpblJlcGFyZW50IiwicGluU3BhY2VyIiwiZmFzdFNjcm9sbEVuZCIsInByZXZlbnRPdmVybGFwcyIsImlzVG9nZ2xlIiwic2Nyb2xsZXJDYWNoZSIsInBpblR5cGUiLCJjYWxsYmFja3MiLCJvbkVudGVyIiwib25MZWF2ZSIsIm9uRW50ZXJCYWNrIiwib25MZWF2ZUJhY2siLCJtYXJrZXJzIiwib25SZWZyZXNoSW5pdCIsImdldFNjcm9sbGVyU2l6ZSIsImdldFNjcm9sbGVyT2Zmc2V0cyIsImxhc3RTbmFwIiwibGFzdFJlZnJlc2giLCJwcmV2UHJvZ3Jlc3MiLCJ0d2VlblRvIiwicGluQ2FjaGUiLCJzbmFwRnVuYyIsInNjcm9sbDEiLCJzY3JvbGwyIiwibWFya2VyU3RhcnQiLCJtYXJrZXJFbmQiLCJtYXJrZXJTdGFydFRyaWdnZXIiLCJtYXJrZXJFbmRUcmlnZ2VyIiwibWFya2VyVmFycyIsImV4ZWN1dGluZ09uUmVmcmVzaCIsImNoYW5nZSIsInBpbk9yaWdpbmFsU3RhdGUiLCJwaW5BY3RpdmVTdGF0ZSIsInBpblN0YXRlIiwicGluR2V0dGVyIiwicGluU2V0dGVyIiwicGluU3RhcnQiLCJwaW5DaGFuZ2UiLCJzcGFjaW5nU3RhcnQiLCJtYXJrZXJTdGFydFNldHRlciIsInBpbk1vdmVzIiwibWFya2VyRW5kU2V0dGVyIiwic25hcDEiLCJzbmFwMiIsInNjcnViVHdlZW4iLCJzY3J1YlNtb290aCIsInNuYXBEdXJDbGFtcCIsInNuYXBEZWxheWVkQ2FsbCIsInByZXZTY3JvbGwiLCJwcmV2QW5pbVByb2dyZXNzIiwiY2FNYXJrZXJTZXR0ZXIiLCJjdXN0b21SZXZlcnRSZXR1cm4iLCJiaW5kIiwicmVmcmVzaFByaW9yaXR5IiwidHdlZW5TY3JvbGwiLCJzY3J1YkR1cmF0aW9uIiwiZWFzZSIsInRvdGFsUHJvZ3Jlc3MiLCJwYXVzZWQiLCJsYXp5IiwiX2luaXR0ZWQiLCJpc1JldmVydGVkIiwiaW1tZWRpYXRlUmVuZGVyIiwic25hcFRvIiwibyIsInNjcm9sbGluZ0VsZW1lbnQiLCJkaXJlY3Rpb25hbCIsIm1pbiIsImRlbGF5ZWRDYWxsIiwiZGVsYXkiLCJyZWZyZXNoZWRSZWNlbnRseSIsImdldFZlbG9jaXR5IiwidmVsb2NpdHkiLCJuYXR1cmFsRW5kIiwiaW5lcnRpYSIsImVuZFZhbHVlIiwiZW5kU2Nyb2xsIiwiX3NuYXAiLCJvblN0YXJ0IiwiX29uSW50ZXJydXB0IiwiX29uQ29tcGxldGUiLCJkYXRhIiwicmVzZXRUbyIsIl90VGltZSIsIl90RHVyIiwiaXNBY3RpdmUiLCJzdFJldmVydCIsInRhcmdldHMiLCJjbGFzc05hbWUiLCJuYXRpdmVFbGVtZW50IiwiY2xhc3NMaXN0IiwiZm9yY2UzRCIsIm9zMiIsImdldFByb3BlcnR5IiwicXVpY2tTZXR0ZXIiLCJjb250ZW50Iiwib2xkT25VcGRhdGUiLCJvbGRQYXJhbXMiLCJvblVwZGF0ZVBhcmFtcyIsImV2ZW50Q2FsbGJhY2siLCJhcHBseSIsInByZXZpb3VzIiwibmV4dCIsInRlbXAiLCJyIiwicHJldlJlZnJlc2hpbmciLCJzb2Z0IiwicGluT2Zmc2V0IiwiaW52YWxpZGF0ZSIsImdldENoaWxkcmVuIiwiaXNGaXJzdFJlZnJlc2giLCJvdGhlclBpbk9mZnNldCIsInBhcnNlZEVuZCIsInBhcnNlZEVuZFRyaWdnZXIiLCJlbmRUcmlnZ2VyIiwicGFyc2VkU3RhcnQiLCJwaW5uZWRDb250YWluZXIiLCJ0cmlnZ2VySW5kZXgiLCJpc1ZlcnRpY2FsIiwiY3VyVHJpZ2dlciIsImN1clBpbiIsIm9wcG9zaXRlU2Nyb2xsIiwiaW5pdHRlZCIsInJldmVydGVkUGlucyIsImZvcmNlZE92ZXJmbG93IiwibWFya2VyU3RhcnRPZmZzZXQiLCJtYXJrZXJFbmRPZmZzZXQiLCJ1bnNoaWZ0IiwiX3BpblB1c2giLCJub3JtYWxpemUiLCJ0b1VwcGVyQ2FzZSIsImNlaWwiLCJzcGxpY2UiLCJfcGluT2Zmc2V0IiwiZW5kQW5pbWF0aW9uIiwibGFiZWxUb1Njcm9sbCIsImxhYmVsIiwiZ2V0VHJhaWxpbmciLCJyZXZlcnNlIiwiZmlsdGVyIiwicmVzZXQiLCJmb3JjZUZha2UiLCJjbGlwcGVkIiwid2FzQWN0aXZlIiwidG9nZ2xlU3RhdGUiLCJhY3Rpb24iLCJzdGF0ZUNoYW5nZWQiLCJ0b2dnbGVkIiwiaXNBdE1heCIsImlzVGFraW5nQWN0aW9uIiwiX2RwIiwiX3RpbWUiLCJfc3RhcnQiLCJuIiwiZW5hYmxlIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJrZWVwQ2xhbXAiLCJfY2hhbmdlIiwiYW1vdW50IiwiZGlzYWJsZSIsImFsbG93QW5pbWF0aW9uIiwib25LaWxsIiwidXBkYXRlRnVuYyIsImRvY3VtZW50IiwiY29uZmlnIiwiY2xlYXJJbnRlcnZhbCIsInRvQXJyYXkiLCJjb250ZXh0Iiwic3VwcHJlc3NPdmVyd3JpdGVzIiwicGFnZVlPZmZzZXQiLCJnbG9iYWxzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibWF0Y2hNZWRpYSIsIm1tIiwiYm9keUhhc1N0eWxlIiwiaGFzQXR0cmlidXRlIiwiYm9keVN0eWxlIiwiYm9yZGVyIiwiYm9yZGVyVG9wU3R5bGUiLCJBbmltYXRpb25Qcm90byIsIkFuaW1hdGlvbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic2MiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRJbnRlcnZhbCIsImNoZWNrUHJlZml4IiwidyIsImgiLCJoaWRkZW4iLCJsaW1pdENhbGxiYWNrcyIsIm1zIiwic3luY0ludGVydmFsIiwiaWdub3JlTW9iaWxlUmVzaXplIiwiYXV0b1JlZnJlc2hFdmVudHMiLCJzY3JvbGxlclByb3h5IiwiY2xlYXJNYXRjaE1lZGlhIiwiaXNJblZpZXdwb3J0IiwicG9zaXRpb25JblZpZXdwb3J0IiwicmVmZXJlbmNlUG9pbnQiLCJraWxsQWxsIiwiYWxsb3dMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJ2ZXJzaW9uIiwic2F2ZVN0eWxlcyIsImdldEF0dHJpYnV0ZSIsImNyZWF0ZSIsInNhZmUiLCJjbGVhclNjcm9sbE1lbW9yeSIsIm1heFNjcm9sbCIsImdldFNjcm9sbEZ1bmMiLCJnZXRCeUlkIiwiZ2V0QWxsIiwiaXNTY3JvbGxpbmciLCJzbmFwRGlyZWN0aW9uYWwiLCJiYXRjaCIsInZhcnNDb3B5IiwiaW50ZXJ2YWwiLCJiYXRjaE1heCIsInByb3h5Q2FsbGJhY2siLCJlbGVtZW50cyIsInRyaWdnZXJzIiwiX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyIiwiX2FsbG93TmF0aXZlUGFubmluZyIsInRvdWNoQWN0aW9uIiwiX292ZXJmbG93IiwiYXV0byIsIl9uZXN0ZWRTY3JvbGwiLCJfcmVmNSIsImV2ZW50IiwiYXhpcyIsIm5vZGUiLCJjaGFuZ2VkVG91Y2hlcyIsIl9pc1Njcm9sbFQiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIl9pc1Njcm9sbCIsInN0b3BQcm9wYWdhdGlvbiIsIl9nc2FwQWxsb3ciLCJfaW5wdXRPYnNlcnZlciIsImlucHV0cyIsIm5lc3RlZCIsImRlYm91bmNlIiwibG9ja0F4aXMiLCJvbldoZWVsIiwib25QcmVzcyIsIm9uRHJhZyIsIm9uU2Nyb2xsIiwib25FbmFibGUiLCJldmVudFR5cGVzIiwiX2NhcHR1cmVJbnB1dHMiLCJvbkRpc2FibGUiLCJfaW5wdXRFeHAiLCJfaW5wdXRJc0ZvY3VzZWQiLCJpc0lucHV0IiwidGFnTmFtZSIsIl9nZXRTY3JvbGxOb3JtYWxpemVyIiwicHJldmVudERlZmF1bHQiLCJpc05vcm1hbGl6ZXIiLCJhbGxvd0NsaWNrcyIsIl92YXJzMiIsIm5vcm1hbGl6ZVNjcm9sbFgiLCJtb21lbnR1bSIsImFsbG93TmVzdGVkU2Nyb2xsIiwib25SZWxlYXNlIiwibWF4WSIsInNtb290aGVyIiwiU2Nyb2xsU21vb3RoZXIiLCJzbW9vdGhlckluc3RhbmNlIiwiZ2V0Iiwic2Nyb2xsRnVuY1kiLCJzY3JvbGxGdW5jWCIsImluaXRpYWxTY2FsZSIsInZpc3VhbFZpZXdwb3J0Iiwib3V0ZXJXaWR0aCIsIndoZWVsUmVmcmVzaCIsInJlc29sdmVNb21lbnR1bUR1cmF0aW9uIiwibGFzdFJlZnJlc2hJRCIsInNraXBUb3VjaE1vdmUiLCJpbnB1dE9ic2VydmVyIiwicmVzdW1lVG91Y2hNb3ZlIiwic2Nyb2xsQ2xhbXBYIiwic2Nyb2xsQ2xhbXBZIiwidXBkYXRlQ2xhbXBzIiwicmVtb3ZlQ29udGVudE9mZnNldCIsInRyYW5zZm9ybSIsImlnbm9yZURyYWciLCJkZWx0YVkiLCJzdGFydFNjcm9sbFgiLCJzdGFydFNjcm9sbFkiLCJvblN0b3BEZWxheWVkQ2FsbCIsIm9uUmVzaXplIiwic2Nyb2xsWSIsImlnbm9yZUNoZWNrIiwiaXNHZXN0dXJpbmciLCJ0b3VjaGVzIiwicHJldlNjYWxlIiwib25HZXN0dXJlU3RhcnQiLCJ3YXNEcmFnZ2luZyIsImR1ciIsImN1cnJlbnRTY3JvbGwiLCJ2ZWxvY2l0eVgiLCJzY3JvbGxYIiwidmVsb2NpdHlZIiwicGxheSIsIl90cyIsIm9uQ2hhbmdlIiwiZHgiLCJkeSIsInhBcnJheSIsInlBcnJheSIsInN0YXJ0WSIsInlDbGFtcGVkIiwiaU9TIiwidGlja2VyIiwiX2RjIiwiX3NvcnRZIiwib2JzZXJ2ZSIsIm5vcm1hbGl6ZVNjcm9sbCIsIm5vcm1hbGl6ZXIiLCJicmlkZ2UiLCJzcyIsInJlZiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/ScrollTrigger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ HomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_TextType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/TextType */ \"(app-pages-browser)/./src/components/TextType.tsx\");\n/* harmony import */ var _components_ScrollReveal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/ScrollReveal */ \"(app-pages-browser)/./src/components/ScrollReveal.tsx\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/.pnpm/framer-motion@12.30.0_react_d5b1dee457b11a2e15b957ddefe5ca3b/node_modules/framer-motion/dist/es/value/use-scroll.mjs\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/.pnpm/framer-motion@12.30.0_react_d5b1dee457b11a2e15b957ddefe5ca3b/node_modules/framer-motion/dist/es/value/use-transform.mjs\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/.pnpm/framer-motion@12.30.0_react_d5b1dee457b11a2e15b957ddefe5ca3b/node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* harmony import */ var _components_ScrollNav__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/ScrollNav */ \"(app-pages-browser)/./src/components/ScrollNav.tsx\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dynamic */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/api/app-dynamic.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst Antigravity = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"_app-pages-browser_src_components_Antigravity_tsx\").then(__webpack_require__.bind(__webpack_require__, /*! @/components/Antigravity */ \"(app-pages-browser)/./src/components/Antigravity.tsx\")), {\n    loadableGenerated: {\n        modules: [\n            \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx -> \" + \"@/components/Antigravity\"\n        ]\n    },\n    ssr: false\n});\n_c = Antigravity;\nfunction HomePage() {\n    _s();\n    // ONE scroll hook only\n    const { scrollYProgress } = (0,framer_motion__WEBPACK_IMPORTED_MODULE_6__.useScroll)();\n    // Subtle background shifts per section\n    const background = (0,framer_motion__WEBPACK_IMPORTED_MODULE_7__.useTransform)(scrollYProgress, [\n        0,\n        0.15,\n        0.35,\n        0.55,\n        0.75,\n        1\n    ], [\n        \"#0b0b0f\",\n        \"#0f1015\",\n        \"#0d1417\",\n        \"#12101a\",\n        \"#0f1114\",\n        \"#11130f\"\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_8__.motion.div, {\n        style: {\n            background\n        },\n        className: \"min-h-screen transition-colors duration-500\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ScrollNav__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"relative min-h-screen flex flex-col justify-center px-6 max-w-6xl mx-auto overflow-hidden\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute inset-0 z-0 opacity-25\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Antigravity, {\n                            count: 150,\n                            magnetRadius: 6,\n                            ringRadius: 7,\n                            waveSpeed: 0.4,\n                            waveAmplitude: 1,\n                            particleSize: 1.5,\n                            lerpSpeed: 0.05,\n                            color: \"#46ed3a\",\n                            autoAnimate: true,\n                            particleVariance: 1,\n                            rotationSpeed: 0,\n                            depthFactor: 1,\n                            pulseSpeed: 3,\n                            particleShape: \"capsule\",\n                            fieldStrength: 10\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                            lineNumber: 52,\n                            columnNumber: 5\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 3\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"relative z-10\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-5xl md:text-6xl lg:text-7xl font-bold mb-4\",\n                                children: \"Siddhant Shitole\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                                lineNumber: 74,\n                                columnNumber: 5\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_TextType__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                as: \"h1\",\n                                text: [\n                                    \"Backend & Systems Engineer\",\n                                    \"AI/ML Practitioner\",\n                                    \"Builder of Scalable Solutions\",\n                                    \"Problem  Experiment  Build  Refine  Connect\"\n                                ],\n                                typingSpeed: 70,\n                                deletingSpeed: 40,\n                                pauseDuration: 1500,\n                                variableSpeed: {\n                                    min: 40,\n                                    max: 90\n                                },\n                                initialDelay: 400,\n                                loop: true,\n                                showCursor: true,\n                                cursorCharacter: \"|\",\n                                className: \"text-xl md:text-2xl text-green font-medium\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                                lineNumber: 77,\n                                columnNumber: 5\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ScrollReveal__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                baseOpacity: 0.15,\n                                blurStrength: 6,\n                                baseRotation: 2,\n                                containerClassName: \"mt-8\",\n                                textClassName: \"text-gray max-w-3xl leading-relaxed\",\n                                children: \"Software engineer focused on backend systems and applied AI, with a strong interest in building reliable, scalable solutions to real-world problems. My work combines solid engineering fundamentalsdata structures, system design, and clean architecturewith hands-on experimentation in machine learning, computer vision, and intelligent applications. I approach projects with a problem-first mindset: understanding the core challenge, experimenting with possible solutions, and refining them into practical, production-style systems. Im constantly learning, building, and iterating, aiming to grow into an engineer who can design robust systems and contribute meaningfully to high-impact technology.\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                                lineNumber: 100,\n                                columnNumber: 4\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                        lineNumber: 73,\n                        columnNumber: 3\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 48,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                id: \"projects\",\n                className: \"min-h-screen px-6 max-w-6xl mx-auto py-32 border-t border-darkgray/50\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"text-2xl md:text-3xl font-semibold mb-10 text-green\",\n                    children: \"Projects\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 122,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 117,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                id: \"experiments\",\n                className: \"min-h-screen px-6 max-w-6xl mx-auto py-32\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"text-2xl md:text-3xl font-semibold mb-10 text-green\",\n                    children: \"Experiments\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 130,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 126,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                id: \"blog\",\n                className: \"min-h-screen px-6 max-w-6xl mx-auto py-32\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"text-2xl md:text-3xl font-semibold mb-10 text-green\",\n                    children: \"Blog\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                    lineNumber: 138,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 134,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                id: \"resume\",\n                className: \"min-h-screen px-6 max-w-6xl mx-auto py-32\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-2xl md:text-3xl font-semibold mb-10 text-green\",\n                        children: \"Resume\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                        lineNumber: 146,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        href: \"/resume\",\n                        className: \"text-white font-medium hover:text-gray transition\",\n                        children: \"View Resume \"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                        lineNumber: 147,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 142,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                id: \"contact\",\n                className: \"min-h-screen px-6 max-w-6xl mx-auto py-32\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-2xl md:text-3xl font-semibold mb-10 text-green\",\n                        children: \"Contact\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                        lineNumber: 157,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        href: \"/contact\",\n                        className: \"text-white font-medium hover:text-gray transition\",\n                        children: \"Get in touch \"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                        lineNumber: 158,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n                lineNumber: 153,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\app\\\\page.tsx\",\n        lineNumber: 41,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"j589ZjcvRFhVs2O5m5xKiMB1nIg=\", false, function() {\n    return [\n        framer_motion__WEBPACK_IMPORTED_MODULE_6__.useScroll,\n        framer_motion__WEBPACK_IMPORTED_MODULE_7__.useTransform\n    ];\n});\n_c1 = HomePage;\nvar _c, _c1;\n$RefreshReg$(_c, \"Antigravity\");\n$RefreshReg$(_c1, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQzZDO0FBTVE7QUFFVztBQUNqQjtBQUNsQjtBQUNNO0FBRW5DLE1BQU1RLGNBQWNELHdEQUFPQSxDQUN6QixJQUFNLHNPQUFrQzs7Ozs7O0lBQ3RDRSxLQUFLOztLQUZIRDtBQU1TLFNBQVNFOztJQUN0Qix1QkFBdUI7SUFDdkIsTUFBTSxFQUFFQyxlQUFlLEVBQUUsR0FBR1Isd0RBQVNBO0lBR3JDLHVDQUF1QztJQUN2QyxNQUFNUyxhQUFhUiwyREFBWUEsQ0FDN0JPLGlCQUNBO1FBQUM7UUFBRztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUUsRUFDOUI7UUFDRTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUdILHFCQUNFLDhEQUFDVCxpREFBTUEsQ0FBQ1csR0FBRztRQUNUQyxPQUFPO1lBQUVGO1FBQVc7UUFDcEJHLFdBQVU7OzBCQUVWLDhEQUFDViw2REFBU0E7Ozs7OzBCQUdWLDhEQUFDVztnQkFBUUQsV0FBVTs7a0NBR3ZCLDhEQUFDRjt3QkFBSUUsV0FBVTtrQ0FDYiw0RUFBQ1A7NEJBQ0NTLE9BQU87NEJBQ1BDLGNBQWM7NEJBQ2RDLFlBQVk7NEJBQ1pDLFdBQVc7NEJBQ1hDLGVBQWU7NEJBQ2ZDLGNBQWM7NEJBQ2RDLFdBQVc7NEJBQ1hDLE9BQU07NEJBRU5DLFdBQVc7NEJBQ1hDLGtCQUFrQjs0QkFDbEJDLGVBQWU7NEJBQ2ZDLGFBQWE7NEJBQ2JDLFlBQVk7NEJBQ1pDLGVBQWM7NEJBQ2RDLGVBQWU7Ozs7Ozs7Ozs7O2tDQUtuQiw4REFBQ2xCO3dCQUFJRSxXQUFVOzswQ0FDYiw4REFBQ2lCO2dDQUFHakIsV0FBVTswQ0FBa0Q7Ozs7OzswQ0FHaEUsOERBQUNmLDREQUFRQTtnQ0FDWGlDLElBQUc7Z0NBRUhDLE1BQU07b0NBQ047b0NBQ0E7b0NBQ0E7b0NBQ0E7aUNBQ0Q7Z0NBRUNDLGFBQWE7Z0NBQ2JDLGVBQWU7Z0NBQ2ZDLGVBQWU7Z0NBQ2ZDLGVBQWU7b0NBQUVDLEtBQUs7b0NBQUlDLEtBQUs7Z0NBQUc7Z0NBQ2xDQyxjQUFjO2dDQUNkQyxJQUFJO2dDQUNKQyxVQUFVO2dDQUNWQyxpQkFBZ0I7Z0NBQ2hCN0IsV0FBVTs7Ozs7OzBDQUtULDhEQUFDZCxnRUFBWUE7Z0NBQ2Q0QyxhQUFhO2dDQUNiQyxjQUFjO2dDQUNkQyxjQUFjO2dDQUNkQyxvQkFBbUI7Z0NBQ25CQyxlQUFjOzBDQUNmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBV0ssOERBQUNqQztnQkFDQ2tDLElBQUc7Z0JBQ0huQyxXQUFVOzBCQUdWLDRFQUFDb0M7b0JBQUdwQyxXQUFVOzhCQUFzRDs7Ozs7Ozs7Ozs7MEJBSXRFLDhEQUFDQztnQkFDQ2tDLElBQUc7Z0JBQ0huQyxXQUFVOzBCQUVWLDRFQUFDb0M7b0JBQUdwQyxXQUFVOzhCQUFzRDs7Ozs7Ozs7Ozs7MEJBSXRFLDhEQUFDQztnQkFDQ2tDLElBQUc7Z0JBQ0huQyxXQUFVOzBCQUVWLDRFQUFDb0M7b0JBQUdwQyxXQUFVOzhCQUFzRDs7Ozs7Ozs7Ozs7MEJBSXRFLDhEQUFDQztnQkFDQ2tDLElBQUc7Z0JBQ0huQyxXQUFVOztrQ0FFViw4REFBQ29DO3dCQUFHcEMsV0FBVTtrQ0FBc0Q7Ozs7OztrQ0FDcEUsOERBQUNULGlEQUFJQTt3QkFBQzhDLE1BQUs7d0JBQVVyQyxXQUFVO2tDQUFvRDs7Ozs7Ozs7Ozs7OzBCQU1yRiw4REFBQ0M7Z0JBQ0NrQyxJQUFHO2dCQUNIbkMsV0FBVTs7a0NBRVYsOERBQUNvQzt3QkFBR3BDLFdBQVU7a0NBQXNEOzs7Ozs7a0NBQ3BFLDhEQUFDVCxpREFBSUE7d0JBQUM4QyxNQUFLO3dCQUFXckMsV0FBVTtrQ0FBb0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU01RjtHQS9Jd0JMOztRQUVNUCxvREFBU0E7UUFJbEJDLHVEQUFZQTs7O01BTlRNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvcGFnZS50c3g/ZjY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IFRleHRUeXBlIGZyb20gXCJAL2NvbXBvbmVudHMvVGV4dFR5cGVcIjsgICBcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBnc2FwIH0gZnJvbSAnZ3NhcCc7XHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInO1xyXG5cclxuaW1wb3J0IFNjcm9sbFJldmVhbCBmcm9tIFwiQC9jb21wb25lbnRzL1Njcm9sbFJldmVhbFwiO1xyXG5cclxuaW1wb3J0IHsgbW90aW9uLCB1c2VTY3JvbGwsIHVzZVRyYW5zZm9ybSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XHJcbmltcG9ydCBTY3JvbGxOYXYgZnJvbSBcIkAvY29tcG9uZW50cy9TY3JvbGxOYXZcIjtcclxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xyXG5pbXBvcnQgZHluYW1pYyBmcm9tIFwibmV4dC9keW5hbWljXCI7XHJcblxyXG5jb25zdCBBbnRpZ3Jhdml0eSA9IGR5bmFtaWMoXHJcbiAgKCkgPT4gaW1wb3J0KFwiQC9jb21wb25lbnRzL0FudGlncmF2aXR5XCIpLFxyXG4gIHsgc3NyOiBmYWxzZSB9XHJcbik7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZVBhZ2UoKSB7XHJcbiAgLy8gT05FIHNjcm9sbCBob29rIG9ubHlcclxuICBjb25zdCB7IHNjcm9sbFlQcm9ncmVzcyB9ID0gdXNlU2Nyb2xsKCk7XHJcblxyXG5cclxuICAvLyBTdWJ0bGUgYmFja2dyb3VuZCBzaGlmdHMgcGVyIHNlY3Rpb25cclxuICBjb25zdCBiYWNrZ3JvdW5kID0gdXNlVHJhbnNmb3JtKFxyXG4gICAgc2Nyb2xsWVByb2dyZXNzLFxyXG4gICAgWzAsIDAuMTUsIDAuMzUsIDAuNTUsIDAuNzUsIDFdLFxyXG4gICAgW1xyXG4gICAgICBcIiMwYjBiMGZcIiwgLy8gSGVyb1xyXG4gICAgICBcIiMwZjEwMTVcIiwgLy8gUHJvamVjdHNcclxuICAgICAgXCIjMGQxNDE3XCIsIC8vIEV4cGVyaW1lbnRzXHJcbiAgICAgIFwiIzEyMTAxYVwiLCAvLyBCbG9nXHJcbiAgICAgIFwiIzBmMTExNFwiLCAvLyBSZXN1bWVcclxuICAgICAgXCIjMTExMzBmXCIsIC8vIENvbnRhY3RcclxuICAgIF1cclxuICApO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPG1vdGlvbi5kaXZcclxuICAgICAgc3R5bGU9e3sgYmFja2dyb3VuZCB9fVxyXG4gICAgICBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tNTAwXCJcclxuICAgID5cclxuICAgICAgPFNjcm9sbE5hdiAvPlxyXG5cclxuICAgICAgey8qIEhFUk8gKi99XHJcbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInJlbGF0aXZlIG1pbi1oLXNjcmVlbiBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIHB4LTYgbWF4LXctNnhsIG14LWF1dG8gb3ZlcmZsb3ctaGlkZGVuXCI+XHJcblxyXG4gIHsvKiBBbnRpZ3Jhdml0eSBiYWNrZ3JvdW5kICovfVxyXG4gIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCB6LTAgb3BhY2l0eS0yNVwiPlxyXG4gICAgPEFudGlncmF2aXR5XHJcbiAgICAgIGNvdW50PXsxNTB9XHJcbiAgICAgIG1hZ25ldFJhZGl1cz17Nn1cclxuICAgICAgcmluZ1JhZGl1cz17N31cclxuICAgICAgd2F2ZVNwZWVkPXswLjR9XHJcbiAgICAgIHdhdmVBbXBsaXR1ZGU9ezF9XHJcbiAgICAgIHBhcnRpY2xlU2l6ZT17MS41fVxyXG4gICAgICBsZXJwU3BlZWQ9ezAuMDV9XHJcbiAgICAgIGNvbG9yPVwiIzQ2ZWQzYVwiXHJcblxyXG4gICAgICBhdXRvQW5pbWF0ZVxyXG4gICAgICBwYXJ0aWNsZVZhcmlhbmNlPXsxfVxyXG4gICAgICByb3RhdGlvblNwZWVkPXswfVxyXG4gICAgICBkZXB0aEZhY3Rvcj17MX1cclxuICAgICAgcHVsc2VTcGVlZD17M31cclxuICAgICAgcGFydGljbGVTaGFwZT1cImNhcHN1bGVcIlxyXG4gICAgICBmaWVsZFN0cmVuZ3RoPXsxMH1cclxuICAgIC8+XHJcbiAgPC9kaXY+XHJcblxyXG4gIHsvKiBGb3JlZ3JvdW5kIGNvbnRlbnQgKi99XHJcbiAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB6LTEwXCI+XHJcbiAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC01eGwgbWQ6dGV4dC02eGwgbGc6dGV4dC03eGwgZm9udC1ib2xkIG1iLTRcIj5cclxuICBTaWRkaGFudCBTaGl0b2xlXHJcbjwvaDE+XHJcbiAgICA8VGV4dFR5cGVcclxuICBhcz1cImgxXCJcclxuICBcclxuICB0ZXh0PXtbXHJcbiAgXCJCYWNrZW5kICYgU3lzdGVtcyBFbmdpbmVlclwiLFxyXG4gIFwiQUkvTUwgUHJhY3RpdGlvbmVyXCIsXHJcbiAgXCJCdWlsZGVyIG9mIFNjYWxhYmxlIFNvbHV0aW9uc1wiLFxyXG4gIFwiUHJvYmxlbSDihpIgRXhwZXJpbWVudCDihpIgQnVpbGQg4oaSIFJlZmluZSDihpIgQ29ubmVjdFwiLFxyXG5dfVxyXG5cclxuICB0eXBpbmdTcGVlZD17NzB9XHJcbiAgZGVsZXRpbmdTcGVlZD17NDB9XHJcbiAgcGF1c2VEdXJhdGlvbj17MTUwMH1cclxuICB2YXJpYWJsZVNwZWVkPXt7IG1pbjogNDAsIG1heDogOTAgfX1cclxuICBpbml0aWFsRGVsYXk9ezQwMH1cclxuICBsb29wXHJcbiAgc2hvd0N1cnNvclxyXG4gIGN1cnNvckNoYXJhY3Rlcj1cInxcIlxyXG4gIGNsYXNzTmFtZT1cInRleHQteGwgbWQ6dGV4dC0yeGwgdGV4dC1ncmVlbiBmb250LW1lZGl1bVwiXHJcbi8+XHJcblxyXG5cclxuXHJcbiAgIDxTY3JvbGxSZXZlYWxcclxuICBiYXNlT3BhY2l0eT17MC4xNX1cclxuICBibHVyU3RyZW5ndGg9ezZ9XHJcbiAgYmFzZVJvdGF0aW9uPXsyfVxyXG4gIGNvbnRhaW5lckNsYXNzTmFtZT1cIm10LThcIlxyXG4gIHRleHRDbGFzc05hbWU9XCJ0ZXh0LWdyYXkgbWF4LXctM3hsIGxlYWRpbmctcmVsYXhlZFwiXHJcbj5cclxuICBTb2Z0d2FyZSBlbmdpbmVlciBmb2N1c2VkIG9uIGJhY2tlbmQgc3lzdGVtcyBhbmQgYXBwbGllZCBBSSwgd2l0aCBhIHN0cm9uZyBpbnRlcmVzdCBpbiBidWlsZGluZyByZWxpYWJsZSwgc2NhbGFibGUgc29sdXRpb25zIHRvIHJlYWwtd29ybGQgcHJvYmxlbXMuIE15IHdvcmsgY29tYmluZXMgc29saWQgZW5naW5lZXJpbmcgZnVuZGFtZW50YWxz4oCUZGF0YSBzdHJ1Y3R1cmVzLCBzeXN0ZW0gZGVzaWduLCBhbmQgY2xlYW4gYXJjaGl0ZWN0dXJl4oCUd2l0aCBoYW5kcy1vbiBleHBlcmltZW50YXRpb24gaW4gbWFjaGluZSBsZWFybmluZywgY29tcHV0ZXIgdmlzaW9uLCBhbmQgaW50ZWxsaWdlbnQgYXBwbGljYXRpb25zLiBJIGFwcHJvYWNoIHByb2plY3RzIHdpdGggYSBwcm9ibGVtLWZpcnN0IG1pbmRzZXQ6IHVuZGVyc3RhbmRpbmcgdGhlIGNvcmUgY2hhbGxlbmdlLCBleHBlcmltZW50aW5nIHdpdGggcG9zc2libGUgc29sdXRpb25zLCBhbmQgcmVmaW5pbmcgdGhlbSBpbnRvIHByYWN0aWNhbCwgcHJvZHVjdGlvbi1zdHlsZSBzeXN0ZW1zLiBJ4oCZbSBjb25zdGFudGx5IGxlYXJuaW5nLCBidWlsZGluZywgYW5kIGl0ZXJhdGluZywgYWltaW5nIHRvIGdyb3cgaW50byBhbiBlbmdpbmVlciB3aG8gY2FuIGRlc2lnbiByb2J1c3Qgc3lzdGVtcyBhbmQgY29udHJpYnV0ZSBtZWFuaW5nZnVsbHkgdG8gaGlnaC1pbXBhY3QgdGVjaG5vbG9neS5cclxuICAgIDwvU2Nyb2xsUmV2ZWFsPlxyXG5cclxuXHJcbiAgICBcclxuICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG5cclxuXHJcbiAgICAgIHsvKiBQUk9KRUNUUyAqL31cclxuICAgICAgPHNlY3Rpb25cclxuICAgICAgICBpZD1cInByb2plY3RzXCJcclxuICAgICAgICBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gcHgtNiBtYXgtdy02eGwgbXgtYXV0byBweS0zMiBib3JkZXItdCBib3JkZXItZGFya2dyYXkvNTBcIlxyXG4gICAgICA+XHJcblxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBtZDp0ZXh0LTN4bCBmb250LXNlbWlib2xkIG1iLTEwIHRleHQtZ3JlZW5cIj5Qcm9qZWN0czwvaDI+XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuXHJcbiAgICAgIHsvKiBFWFBFUklNRU5UUyAqL31cclxuICAgICAgPHNlY3Rpb25cclxuICAgICAgICBpZD1cImV4cGVyaW1lbnRzXCJcclxuICAgICAgICBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gcHgtNiBtYXgtdy02eGwgbXgtYXV0byBweS0zMlwiXHJcbiAgICAgID5cclxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0yeGwgbWQ6dGV4dC0zeGwgZm9udC1zZW1pYm9sZCBtYi0xMCB0ZXh0LWdyZWVuXCI+RXhwZXJpbWVudHM8L2gyPlxyXG4gICAgICA8L3NlY3Rpb24+XHJcblxyXG4gICAgICB7LyogQkxPRyAqL31cclxuICAgICAgPHNlY3Rpb25cclxuICAgICAgICBpZD1cImJsb2dcIlxyXG4gICAgICAgIGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBweC02IG1heC13LTZ4bCBteC1hdXRvIHB5LTMyXCJcclxuICAgICAgPlxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBtZDp0ZXh0LTN4bCBmb250LXNlbWlib2xkIG1iLTEwIHRleHQtZ3JlZW5cIj5CbG9nPC9oMj5cclxuICAgICAgPC9zZWN0aW9uPlxyXG5cclxuICAgICAgey8qIFJFU1VNRSAqL31cclxuICAgICAgPHNlY3Rpb25cclxuICAgICAgICBpZD1cInJlc3VtZVwiXHJcbiAgICAgICAgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIHB4LTYgbWF4LXctNnhsIG14LWF1dG8gcHktMzJcIlxyXG4gICAgICA+XHJcbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIG1kOnRleHQtM3hsIGZvbnQtc2VtaWJvbGQgbWItMTAgdGV4dC1ncmVlblwiPlJlc3VtZTwvaDI+XHJcbiAgICAgICAgPExpbmsgaHJlZj1cIi9yZXN1bWVcIiBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIGZvbnQtbWVkaXVtIGhvdmVyOnRleHQtZ3JheSB0cmFuc2l0aW9uXCI+XHJcbiAgICAgICAgICBWaWV3IFJlc3VtZSDihpJcclxuICAgICAgICA8L0xpbms+XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuXHJcbiAgICAgIHsvKiBDT05UQUNUICovfVxyXG4gICAgICA8c2VjdGlvblxyXG4gICAgICAgIGlkPVwiY29udGFjdFwiXHJcbiAgICAgICAgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIHB4LTYgbWF4LXctNnhsIG14LWF1dG8gcHktMzJcIlxyXG4gICAgICA+XHJcbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIG1kOnRleHQtM3hsIGZvbnQtc2VtaWJvbGQgbWItMTAgdGV4dC1ncmVlblwiPkNvbnRhY3Q8L2gyPlxyXG4gICAgICAgIDxMaW5rIGhyZWY9XCIvY29udGFjdFwiIGNsYXNzTmFtZT1cInRleHQtd2hpdGUgZm9udC1tZWRpdW0gaG92ZXI6dGV4dC1ncmF5IHRyYW5zaXRpb25cIj5cclxuICAgICAgICAgIEdldCBpbiB0b3VjaCDihpJcclxuICAgICAgICA8L0xpbms+XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuICAgIDwvbW90aW9uLmRpdj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJUZXh0VHlwZSIsIlNjcm9sbFJldmVhbCIsIm1vdGlvbiIsInVzZVNjcm9sbCIsInVzZVRyYW5zZm9ybSIsIlNjcm9sbE5hdiIsIkxpbmsiLCJkeW5hbWljIiwiQW50aWdyYXZpdHkiLCJzc3IiLCJIb21lUGFnZSIsInNjcm9sbFlQcm9ncmVzcyIsImJhY2tncm91bmQiLCJkaXYiLCJzdHlsZSIsImNsYXNzTmFtZSIsInNlY3Rpb24iLCJjb3VudCIsIm1hZ25ldFJhZGl1cyIsInJpbmdSYWRpdXMiLCJ3YXZlU3BlZWQiLCJ3YXZlQW1wbGl0dWRlIiwicGFydGljbGVTaXplIiwibGVycFNwZWVkIiwiY29sb3IiLCJhdXRvQW5pbWF0ZSIsInBhcnRpY2xlVmFyaWFuY2UiLCJyb3RhdGlvblNwZWVkIiwiZGVwdGhGYWN0b3IiLCJwdWxzZVNwZWVkIiwicGFydGljbGVTaGFwZSIsImZpZWxkU3RyZW5ndGgiLCJoMSIsImFzIiwidGV4dCIsInR5cGluZ1NwZWVkIiwiZGVsZXRpbmdTcGVlZCIsInBhdXNlRHVyYXRpb24iLCJ2YXJpYWJsZVNwZWVkIiwibWluIiwibWF4IiwiaW5pdGlhbERlbGF5IiwibG9vcCIsInNob3dDdXJzb3IiLCJjdXJzb3JDaGFyYWN0ZXIiLCJiYXNlT3BhY2l0eSIsImJsdXJTdHJlbmd0aCIsImJhc2VSb3RhdGlvbiIsImNvbnRhaW5lckNsYXNzTmFtZSIsInRleHRDbGFzc05hbWUiLCJpZCIsImgyIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ScrollReveal.tsx":
/*!*****************************************!*\
  !*** ./src/components/ScrollReveal.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/index.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.14.2/node_modules/gsap/ScrollTrigger.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\ngsap__WEBPACK_IMPORTED_MODULE_2__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_3__.ScrollTrigger);\ngsap__WEBPACK_IMPORTED_MODULE_2__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_3__.ScrollTrigger);\nconst ScrollReveal = (param)=>{\n    let { children, scrollContainerRef, enableBlur = true, baseOpacity = 0.1, baseRotation = 3, blurStrength = 4, containerClassName = \"\", textClassName = \"\", rotationEnd = \"bottom bottom\", wordAnimationEnd = \"bottom bottom\" } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const splitText = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const text = typeof children === \"string\" ? children : \"\";\n        return text.split(/(\\s+)/).map((word, index)=>{\n            if (word.match(/^\\s+$/)) return word;\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"inline-block word\",\n                children: word\n            }, index, false, {\n                fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\components\\\\ScrollReveal.tsx\",\n                lineNumber: 30,\n                columnNumber: 9\n            }, undefined);\n        });\n    }, [\n        children\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const el = containerRef.current;\n        if (!el) return;\n        const scroller = scrollContainerRef && scrollContainerRef.current ? scrollContainerRef.current : window;\n        gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.fromTo(el, {\n            transformOrigin: \"0% 50%\",\n            rotate: baseRotation\n        }, {\n            ease: \"none\",\n            rotate: 0,\n            scrollTrigger: {\n                trigger: el,\n                scroller,\n                start: \"top bottom\",\n                end: rotationEnd,\n                scrub: true\n            }\n        });\n        const wordElements = el.querySelectorAll(\".word\");\n        gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.fromTo(wordElements, {\n            opacity: baseOpacity,\n            willChange: \"opacity\"\n        }, {\n            ease: \"none\",\n            opacity: 1,\n            stagger: 0.05,\n            scrollTrigger: {\n                trigger: el,\n                scroller,\n                start: \"top bottom-=20%\",\n                end: wordAnimationEnd,\n                scrub: true\n            }\n        });\n        if (enableBlur) {\n            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.fromTo(wordElements, {\n                filter: \"blur(\".concat(blurStrength, \"px)\")\n            }, {\n                ease: \"none\",\n                filter: \"blur(0px)\",\n                stagger: 0.05,\n                scrollTrigger: {\n                    trigger: el,\n                    scroller,\n                    start: \"top bottom-=20%\",\n                    end: wordAnimationEnd,\n                    scrub: true\n                }\n            });\n        }\n        return ()=>{\n            gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_3__.ScrollTrigger.getAll().forEach((trigger)=>trigger.kill());\n        };\n    }, [\n        scrollContainerRef,\n        enableBlur,\n        baseRotation,\n        baseOpacity,\n        rotationEnd,\n        wordAnimationEnd,\n        blurStrength\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n        ref: containerRef,\n        className: \"my-5 \".concat(containerClassName),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n            className: \"text-base md:text-lg leading-relaxed text-gray \".concat(textClassName),\n            children: splitText\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\components\\\\ScrollReveal.tsx\",\n            lineNumber: 104,\n            columnNumber: 1\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Siddhant\\\\Desktop\\\\Portfolio\\\\Portfolio\\\\src\\\\components\\\\ScrollReveal.tsx\",\n        lineNumber: 103,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ScrollReveal, \"hIZrZL5u/LWmVxtB2uNEyPh5EJc=\");\n_c = ScrollReveal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ScrollReveal);\nvar _c;\n$RefreshReg$(_c, \"ScrollReveal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1Njcm9sbFJldmVhbC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFbUQ7QUFDdkI7QUFDdUI7QUFFbkRHLHNDQUFJQSxDQUFDRSxjQUFjLENBQUNELDZEQUFhQTtBQUVqQ0Qsc0NBQUlBLENBQUNFLGNBQWMsQ0FBQ0QsNkRBQWFBO0FBRWpDLE1BQU1FLGVBQWU7UUFBQyxFQUNwQkMsUUFBUSxFQUNSQyxrQkFBa0IsRUFDbEJDLGFBQWEsSUFBSSxFQUNqQkMsY0FBYyxHQUFHLEVBQ2pCQyxlQUFlLENBQUMsRUFDaEJDLGVBQWUsQ0FBQyxFQUNoQkMscUJBQXFCLEVBQUUsRUFDdkJDLGdCQUFnQixFQUFFLEVBQ2xCQyxjQUFjLGVBQWUsRUFDN0JDLG1CQUFtQixlQUFlLEVBQ25DOztJQUNDLE1BQU1DLGVBQWVoQiw2Q0FBTUEsQ0FBQztJQUU1QixNQUFNaUIsWUFBWWhCLDhDQUFPQSxDQUFDO1FBQ3hCLE1BQU1pQixPQUFPLE9BQU9aLGFBQWEsV0FBV0EsV0FBVztRQUN2RCxPQUFPWSxLQUFLQyxLQUFLLENBQUMsU0FBU0MsR0FBRyxDQUFDLENBQUNDLE1BQU1DO1lBQ3BDLElBQUlELEtBQUtFLEtBQUssQ0FBQyxVQUFVLE9BQU9GO1lBQ2hDLHFCQUNFLDhEQUFDRztnQkFBS0MsV0FBVTswQkFDYko7ZUFEc0NDOzs7OztRQUk3QztJQUNGLEdBQUc7UUFBQ2hCO0tBQVM7SUFFYlAsZ0RBQVNBLENBQUM7UUFDUixNQUFNMkIsS0FBS1YsYUFBYVcsT0FBTztRQUMvQixJQUFJLENBQUNELElBQUk7UUFFVCxNQUFNRSxXQUFXckIsc0JBQXNCQSxtQkFBbUJvQixPQUFPLEdBQUdwQixtQkFBbUJvQixPQUFPLEdBQUdFO1FBRWpHM0Isc0NBQUlBLENBQUM0QixNQUFNLENBQ1RKLElBQ0E7WUFBRUssaUJBQWlCO1lBQVVDLFFBQVF0QjtRQUFhLEdBQ2xEO1lBQ0V1QixNQUFNO1lBQ05ELFFBQVE7WUFDUkUsZUFBZTtnQkFDYkMsU0FBU1Q7Z0JBQ1RFO2dCQUNBUSxPQUFPO2dCQUNQQyxLQUFLdkI7Z0JBQ0x3QixPQUFPO1lBQ1Q7UUFDRjtRQUdGLE1BQU1DLGVBQWViLEdBQUdjLGdCQUFnQixDQUFDO1FBRXpDdEMsc0NBQUlBLENBQUM0QixNQUFNLENBQ1RTLGNBQ0E7WUFBRUUsU0FBU2hDO1lBQWFpQyxZQUFZO1FBQVUsR0FDOUM7WUFDRVQsTUFBTTtZQUNOUSxTQUFTO1lBQ1RFLFNBQVM7WUFDVFQsZUFBZTtnQkFDYkMsU0FBU1Q7Z0JBQ1RFO2dCQUNBUSxPQUFPO2dCQUNQQyxLQUFLdEI7Z0JBQ0x1QixPQUFPO1lBQ1Q7UUFDRjtRQUdGLElBQUk5QixZQUFZO1lBQ2ROLHNDQUFJQSxDQUFDNEIsTUFBTSxDQUNUUyxjQUNBO2dCQUFFSyxRQUFRLFFBQXFCLE9BQWJqQyxjQUFhO1lBQUssR0FDcEM7Z0JBQ0VzQixNQUFNO2dCQUNOVyxRQUFRO2dCQUNSRCxTQUFTO2dCQUNUVCxlQUFlO29CQUNiQyxTQUFTVDtvQkFDVEU7b0JBQ0FRLE9BQU87b0JBQ1BDLEtBQUt0QjtvQkFDTHVCLE9BQU87Z0JBQ1Q7WUFDRjtRQUVKO1FBRUEsT0FBTztZQUNMbkMsNkRBQWFBLENBQUMwQyxNQUFNLEdBQUdDLE9BQU8sQ0FBQ1gsQ0FBQUEsVUFBV0EsUUFBUVksSUFBSTtRQUN4RDtJQUNGLEdBQUc7UUFBQ3hDO1FBQW9CQztRQUFZRTtRQUFjRDtRQUFhSztRQUFhQztRQUFrQko7S0FBYTtJQUUzRyxxQkFDRSw4REFBQ3FDO1FBQUdDLEtBQUtqQztRQUFjUyxXQUFXLFFBQTJCLE9BQW5CYjtrQkFDOUMsNEVBQUNzQztZQUFFekIsV0FBVyxrREFBZ0UsT0FBZFo7c0JBQzdESTs7Ozs7Ozs7Ozs7QUFJSDtHQWxHTVo7S0FBQUE7QUFvR04sK0RBQWVBLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvU2Nyb2xsUmV2ZWFsLnRzeD84NzRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgZ3NhcCB9IGZyb20gXCJnc2FwXCI7XHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tIFwiZ3NhcC9TY3JvbGxUcmlnZ2VyXCI7XHJcblxyXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xyXG5cclxuZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTtcclxuXHJcbmNvbnN0IFNjcm9sbFJldmVhbCA9ICh7XHJcbiAgY2hpbGRyZW4sXHJcbiAgc2Nyb2xsQ29udGFpbmVyUmVmLFxyXG4gIGVuYWJsZUJsdXIgPSB0cnVlLFxyXG4gIGJhc2VPcGFjaXR5ID0gMC4xLFxyXG4gIGJhc2VSb3RhdGlvbiA9IDMsXHJcbiAgYmx1clN0cmVuZ3RoID0gNCxcclxuICBjb250YWluZXJDbGFzc05hbWUgPSAnJyxcclxuICB0ZXh0Q2xhc3NOYW1lID0gJycsXHJcbiAgcm90YXRpb25FbmQgPSAnYm90dG9tIGJvdHRvbScsXHJcbiAgd29yZEFuaW1hdGlvbkVuZCA9ICdib3R0b20gYm90dG9tJ1xyXG59KSA9PiB7XHJcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICBjb25zdCBzcGxpdFRleHQgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGNvbnN0IHRleHQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiAnJztcclxuICAgIHJldHVybiB0ZXh0LnNwbGl0KC8oXFxzKykvKS5tYXAoKHdvcmQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmICh3b3JkLm1hdGNoKC9eXFxzKyQvKSkgcmV0dXJuIHdvcmQ7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaW5saW5lLWJsb2NrIHdvcmRcIiBrZXk9e2luZGV4fT5cclxuICAgICAgICAgIHt3b3JkfVxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0sIFtjaGlsZHJlbl0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgZWwgPSBjb250YWluZXJSZWYuY3VycmVudDtcclxuICAgIGlmICghZWwpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBzY3JvbGxlciA9IHNjcm9sbENvbnRhaW5lclJlZiAmJiBzY3JvbGxDb250YWluZXJSZWYuY3VycmVudCA/IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50IDogd2luZG93O1xyXG5cclxuICAgIGdzYXAuZnJvbVRvKFxyXG4gICAgICBlbCxcclxuICAgICAgeyB0cmFuc2Zvcm1PcmlnaW46ICcwJSA1MCUnLCByb3RhdGU6IGJhc2VSb3RhdGlvbiB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgZWFzZTogJ25vbmUnLFxyXG4gICAgICAgIHJvdGF0ZTogMCxcclxuICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XHJcbiAgICAgICAgICB0cmlnZ2VyOiBlbCxcclxuICAgICAgICAgIHNjcm9sbGVyLFxyXG4gICAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tJyxcclxuICAgICAgICAgIGVuZDogcm90YXRpb25FbmQsXHJcbiAgICAgICAgICBzY3J1YjogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCB3b3JkRWxlbWVudHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xyXG5cclxuICAgIGdzYXAuZnJvbVRvKFxyXG4gICAgICB3b3JkRWxlbWVudHMsXHJcbiAgICAgIHsgb3BhY2l0eTogYmFzZU9wYWNpdHksIHdpbGxDaGFuZ2U6ICdvcGFjaXR5JyB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgZWFzZTogJ25vbmUnLFxyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgc3RhZ2dlcjogMC4wNSxcclxuICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XHJcbiAgICAgICAgICB0cmlnZ2VyOiBlbCxcclxuICAgICAgICAgIHNjcm9sbGVyLFxyXG4gICAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tLT0yMCUnLFxyXG4gICAgICAgICAgZW5kOiB3b3JkQW5pbWF0aW9uRW5kLFxyXG4gICAgICAgICAgc2NydWI6IHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgaWYgKGVuYWJsZUJsdXIpIHtcclxuICAgICAgZ3NhcC5mcm9tVG8oXHJcbiAgICAgICAgd29yZEVsZW1lbnRzLFxyXG4gICAgICAgIHsgZmlsdGVyOiBgYmx1cigke2JsdXJTdHJlbmd0aH1weClgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZWFzZTogJ25vbmUnLFxyXG4gICAgICAgICAgZmlsdGVyOiAnYmx1cigwcHgpJyxcclxuICAgICAgICAgIHN0YWdnZXI6IDAuMDUsXHJcbiAgICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XHJcbiAgICAgICAgICAgIHRyaWdnZXI6IGVsLFxyXG4gICAgICAgICAgICBzY3JvbGxlcixcclxuICAgICAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tLT0yMCUnLFxyXG4gICAgICAgICAgICBlbmQ6IHdvcmRBbmltYXRpb25FbmQsXHJcbiAgICAgICAgICAgIHNjcnViOiB0cnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIFNjcm9sbFRyaWdnZXIuZ2V0QWxsKCkuZm9yRWFjaCh0cmlnZ2VyID0+IHRyaWdnZXIua2lsbCgpKTtcclxuICAgIH07XHJcbiAgfSwgW3Njcm9sbENvbnRhaW5lclJlZiwgZW5hYmxlQmx1ciwgYmFzZVJvdGF0aW9uLCBiYXNlT3BhY2l0eSwgcm90YXRpb25FbmQsIHdvcmRBbmltYXRpb25FbmQsIGJsdXJTdHJlbmd0aF0pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGgyIHJlZj17Y29udGFpbmVyUmVmfSBjbGFzc05hbWU9e2BteS01ICR7Y29udGFpbmVyQ2xhc3NOYW1lfWB9PlxyXG48cCBjbGFzc05hbWU9e2B0ZXh0LWJhc2UgbWQ6dGV4dC1sZyBsZWFkaW5nLXJlbGF4ZWQgdGV4dC1ncmF5ICR7dGV4dENsYXNzTmFtZX1gfT5cclxuICB7c3BsaXRUZXh0fVxyXG48L3A+XHJcbiAgICA8L2gyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxSZXZlYWw7XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VNZW1vIiwiZ3NhcCIsIlNjcm9sbFRyaWdnZXIiLCJyZWdpc3RlclBsdWdpbiIsIlNjcm9sbFJldmVhbCIsImNoaWxkcmVuIiwic2Nyb2xsQ29udGFpbmVyUmVmIiwiZW5hYmxlQmx1ciIsImJhc2VPcGFjaXR5IiwiYmFzZVJvdGF0aW9uIiwiYmx1clN0cmVuZ3RoIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwidGV4dENsYXNzTmFtZSIsInJvdGF0aW9uRW5kIiwid29yZEFuaW1hdGlvbkVuZCIsImNvbnRhaW5lclJlZiIsInNwbGl0VGV4dCIsInRleHQiLCJzcGxpdCIsIm1hcCIsIndvcmQiLCJpbmRleCIsIm1hdGNoIiwic3BhbiIsImNsYXNzTmFtZSIsImVsIiwiY3VycmVudCIsInNjcm9sbGVyIiwid2luZG93IiwiZnJvbVRvIiwidHJhbnNmb3JtT3JpZ2luIiwicm90YXRlIiwiZWFzZSIsInNjcm9sbFRyaWdnZXIiLCJ0cmlnZ2VyIiwic3RhcnQiLCJlbmQiLCJzY3J1YiIsIndvcmRFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvcGFjaXR5Iiwid2lsbENoYW5nZSIsInN0YWdnZXIiLCJmaWx0ZXIiLCJnZXRBbGwiLCJmb3JFYWNoIiwia2lsbCIsImgyIiwicmVmIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ScrollReveal.tsx\n"));

/***/ })

});